<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青萍水袖</title>
  
  <subtitle>做一些简单的事情 把有用的东西写下来 总有一天你能用的到</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lbrjms.github.io/"/>
  <updated>2019-08-14T16:22:14.544Z</updated>
  <id>http://lbrjms.github.io/</id>
  
  <author>
    <name>WJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS生成二维码</title>
    <link href="http://lbrjms.github.io/2019/08/15/iOS%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://lbrjms.github.io/2019/08/15/iOS生成二维码/</id>
    <published>2019-08-14T16:21:49.000Z</published>
    <updated>2019-08-14T16:22:14.544Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/** 根据字符串生成指定颜色大小的黑白二维码 */</span><br><span class="line">+ (UIImage *)wl_createQRImageWithString:(NSString *)string bgColor:(UIColor *)bgColor contentColor:(UIColor *)ctColor size:(CGSize)size&#123;</span><br><span class="line">    NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding];</span><br><span class="line">    CIFilter *qrFilter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;];</span><br><span class="line">    [qrFilter setValue:stringData forKey:@&quot;inputMessage&quot;];</span><br><span class="line">    /**</span><br><span class="line">     inputCorrectionLevel</span><br><span class="line">     等级  容错率</span><br><span class="line">     L     7%</span><br><span class="line">     M     15%  默认值</span><br><span class="line">     Q     25%</span><br><span class="line">     H     30%</span><br><span class="line">     */</span><br><span class="line">    [qrFilter setValue:@&quot;M&quot; forKey:@&quot;inputCorrectionLevel&quot;];</span><br><span class="line">    // 颜色滤镜</span><br><span class="line">    CIFilter *colorFilter = [CIFilter filterWithName:@&quot;CIFalseColor&quot; keysAndValues:@&quot;inputImage&quot;, qrFilter.outputImage,@&quot;inputColor0&quot;,ctColor?[CIColor colorWithCGColor:ctColor.CGColor]:[CIColor colorWithCGColor:[UIColor blackColor].CGColor],@&quot;inputColor1&quot;,bgColor?[CIColor colorWithCGColor:bgColor.CGColor]:[CIColor colorWithCGColor:[UIColor whiteColor].CGColor],nil];</span><br><span class="line">    CIImage *qrImage = colorFilter.outputImage;</span><br><span class="line">    //放大并绘制二维码 (上面生成的二维码很小，需要放大)</span><br><span class="line">    CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent];</span><br><span class="line">    UIGraphicsBeginImageContext(size);</span><br><span class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</span><br><span class="line">    CGContextSetInterpolationQuality(context, kCGInterpolationNone);</span><br><span class="line">    //翻转一下图片 不然生成的QRCode就是上下颠倒的</span><br><span class="line">    CGContextScaleCTM(context, 1.0, -1.0);</span><br><span class="line">    CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage);</span><br><span class="line">    UIImage *codeImage = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line"></span><br><span class="line">    CGImageRelease(cgImage);</span><br><span class="line"></span><br><span class="line">    return codeImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>KVO的内部实现</title>
    <link href="http://lbrjms.github.io/2019/08/13/KVO%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://lbrjms.github.io/2019/08/13/KVO的内部实现/</id>
    <published>2019-08-13T03:23:45.000Z</published>
    <updated>2019-08-14T10:25:49.721Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KVO的使用"><a href="#KVO的使用" class="headerlink" title="KVO的使用"></a>KVO的使用</h3><ul><li>添加观察</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;</span><br></pre></td></tr></table></figure><ul><li>属性变化回调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context;</span><br></pre></td></tr></table></figure><ul><li>移除观察者</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure><h3 id="KVO的内部实现原理"><a href="#KVO的内部实现原理" class="headerlink" title="KVO的内部实现原理"></a>KVO的内部实现原理</h3><ul><li><p>通过控制台输出可以看出kvo内部是动态创建了监听对象的子类出来 NSKVONotifying_+类名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A * a = [[A alloc] init];</span><br><span class="line">[a setName:@&quot;qwe&quot;];</span><br><span class="line">[a addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">(lldb) po object_getClassName(a)</span><br><span class="line">&quot;A&quot;</span><br><span class="line">(lldb) po object_getClassName(a)</span><br><span class="line">&quot;NSKVONotifying_A&quot;</span><br></pre></td></tr></table></figure></li><li><p>内部还做了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po [a methodForSelector:@selector(setName:)]</span><br><span class="line">(TTTTTT`-[A setName:] at A.h:14)</span><br><span class="line"></span><br><span class="line">(lldb) po [a methodForSelector:@selector(setName:)]</span><br><span class="line">(Foundation`_NSSetObjectValueAndNotify)</span><br><span class="line"></span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure></li></ul><p>发现方法实现变了，内部调用了系统Foundation框架下的_NSSetObjectValueAndNotify方法。那么这个框架内部又是怎么实现的呢，我们可以下断点，查看下函数调用栈：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#00x0000000103a1f21c in -[ViewController observeValueForKeyPath:ofObject:change:context:] at /Users/lwj/Desktop/TTTTTT/TTTTTT/ViewController.m:159</span><br><span class="line">#10x0000000103d7afeb in NSKeyValueNotifyObserver ()</span><br><span class="line">#20x0000000103d7e696 in NSKeyValueDidChange ()</span><br><span class="line">#30x0000000103d7df85 in -[NSObject(NSKeyValueObservingPrivate) _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:] ()</span><br><span class="line">#40x0000000103d7e8ad in -[NSObject(NSKeyValueObservingPrivate) _changeValueForKey:key:key:usingBlock:] ()</span><br><span class="line">#50x0000000103d78739 in _NSSetObjectValueAndNotify ()</span><br></pre></td></tr></table></figure><ul><li><p>简化成OC的伪代码大致如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)setName:(NSString *)name&#123;</span><br><span class="line">    _NSSetObjectValueAndNotify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _NSSetObjectValueAndNotify &#123;</span><br><span class="line">    [self willChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">    [super setName:name];</span><br><span class="line">    [self didChangeValueForKey:@&quot;name&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didChangeValueForKey:(NSString *)key&#123;</span><br><span class="line">    [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>runtime打印NSKVONotifying_A重写了那些方法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">unsigned int count;</span><br><span class="line">Method *methods = class_copyMethodList(object_getClass(a), &amp;count);</span><br><span class="line">for (NSInteger i=0;i&lt; count; i++) &#123;</span><br><span class="line">   Method *met = methods[i];</span><br><span class="line">   NSLog(@&quot;===%@&quot;,NSStringFromSelector(method_getName(met)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-08-13 13:01:08.595571+0800 TTTTTT[60128:4304199] ===setName:</span><br><span class="line">2019-08-13 13:01:08.596093+0800 TTTTTT[60128:4304199] ===class</span><br><span class="line">2019-08-13 13:01:08.596315+0800 TTTTTT[60128:4304199] ===dealloc</span><br><span class="line">2019-08-13 13:01:08.596409+0800 TTTTTT[60128:4304199] ===_isKVOA</span><br></pre></td></tr></table></figure><p>简单分析下重写这些方法的作用：<br>class：重写这个方法，是为了伪装苹果自动为我们生成的中间类。<br>dealloc：应该是处理对象销毁之前的一些收尾工作<br>哈_isKVOA：告诉系统使用了kvo</p><ul><li>动态注册类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 创建类</span><br><span class="line">Class customClass = objc_allocateClassPair([NSObject class], &quot;AClass&quot;, 0);</span><br><span class="line">// 添加实例变量</span><br><span class="line">class_addIvar(customClass, &quot;name&quot;, sizeof(int), 0, &quot;i&quot;);</span><br><span class="line">// 添加方法</span><br><span class="line">class_addMethod(customClass, @selector(text), (IMP)test, &quot;V@:&quot;);</span><br><span class="line">// 注册到运行时环境</span><br><span class="line">objc_registerClassPair(customClass);</span><br></pre></td></tr></table></figure><ul><li>自己实现一个KVO</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">///NSObject的类别</span><br><span class="line">#import &quot;NSObject+KVO.h&quot;</span><br><span class="line">#import &lt;objc/message.h&gt;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line">@implementation NSObject (KVO)</span><br><span class="line">- (void)wj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context</span><br><span class="line">&#123;</span><br><span class="line">    NSString *originClassName = NSStringFromClass([self class]);</span><br><span class="line">    NSString *newClassName = [@&quot;WJKVO_&quot; stringByAppendingString:originClassName];</span><br><span class="line">    const char *newName = [newClassName UTF8String];</span><br><span class="line">    // 继承自当前类，创建一个子类 此时的self是调用当前方法的类</span><br><span class="line">    Class kvoClass = objc_allocateClassPair([self class], newName, 0);</span><br><span class="line">    // 添加setter方法</span><br><span class="line">    class_addMethod(kvoClass, @selector(setName:), (IMP)setName, &quot;v@:@&quot;);</span><br><span class="line">    //注册新添加的这个类</span><br><span class="line">    objc_registerClassPair(kvoClass);</span><br><span class="line">    // 修改isa指针，由A指向WJKVO_A 这样之后用a对象调方法 实际上走的是 我们新建的子类的方法</span><br><span class="line">    object_setClass(self, kvoClass);</span><br><span class="line">    // 保存观察者属性到当前类中</span><br><span class="line">    objc_setAssociatedObject(self, (__bridge const void *)@&quot;observer&quot;, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - 重写父类方法</span><br><span class="line"></span><br><span class="line">void setName(id self, SEL _cmd, NSString *name) &#123;</span><br><span class="line"></span><br><span class="line">    // 保存当前KVO的类</span><br><span class="line">    Class kvoClass = [self class];</span><br><span class="line">    // 将self的isa指针指向父类A，调用父类setter方法</span><br><span class="line">    object_setClass(self, class_getSuperclass([self class]));</span><br><span class="line">    // 调用父类setter方法，重新复制</span><br><span class="line">    objc_msgSend(self, @selector(setName:), name);</span><br><span class="line">    // 取出WJKVO_A观察者</span><br><span class="line">    id objc = objc_getAssociatedObject(self, (__bridge const void *)@&quot;observer&quot;);</span><br><span class="line">    // 通知观察者，执行通知方法 并且传对应的参数</span><br><span class="line">    objc_msgSend(objc, @selector(observeValueForKeyPath:ofObject:change:context:),name,self,@&#123;@&quot;aa&quot;:@&quot;ss&quot;&#125;,nil);</span><br><span class="line">    // 重新修改为WJKVO_A类</span><br><span class="line">    object_setClass(self, kvoClass);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="浅谈FBKVOController"><a href="#浅谈FBKVOController" class="headerlink" title="浅谈FBKVOController"></a>浅谈FBKVOController</h3><ul><li>可以看到他是做了一层嫁接 把需要释放的东西都放在了FBKVOController的dealloc里面</li></ul><p><em>pthread_mutex：这是一种超级易用的互斥锁，使用的时候，只需要初始化一个 pthread_mutex_t，用 pthread_mutex_lock 来锁定， pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1、</span><br><span class="line">+ (instancetype)controllerWithObserver:(nullable id)observer</span><br><span class="line">&#123;</span><br><span class="line">  return [[self alloc] initWithObserver:observer];</span><br><span class="line">&#125;</span><br><span class="line">//2、初始化observer，并依据retainObserved值决定内存策略</span><br><span class="line">- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved</span><br><span class="line">&#123;</span><br><span class="line">  self = [super init];</span><br><span class="line">  if (nil != self) &#123;</span><br><span class="line">    _observer = observer;</span><br><span class="line">    NSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality;</span><br><span class="line">    _objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0];</span><br><span class="line">    //初始化互斥锁</span><br><span class="line">    pthread_mutex_init(&amp;_lock, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line">//3、</span><br><span class="line">- (instancetype)initWithObserver:(nullable id)observer</span><br><span class="line">&#123;</span><br><span class="line">  return [self initWithObserver:observer retainObserved:YES];</span><br><span class="line">&#125;</span><br><span class="line">//4、在dealloc注销所有监听并且销毁上面的互斥锁</span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">  [self unobserveAll];</span><br><span class="line">  pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到把监听对象作为key 存的info信息作为值存在了_objectInfosMap里面 相应的block回调等信息都从info里面取 如果需要销毁也通过_objectInfosMap销毁对应的信息</p><p><strong>个人感觉 这应该是一种投机取巧的思想 我自己害怕出问题 然后我自己就不去干这个而是让另一个人（主业的 不容易出问题）去做</strong></p><h3 id="NSHashTable和NSMapTable"><a href="#NSHashTable和NSMapTable" class="headerlink" title="NSHashTable和NSMapTable"></a>NSHashTable和NSMapTable</h3><p><em>对于NSSet，object是强引用的，和NSDictionary中的value是一样的。而NSDictionary中的key则是copy的，因此当开发者想要使NSSet的objects或者NSDictionary的values为weak，或者NSDictionary使用没有实现协议的对象作为key时，比较麻烦（需要使用NSValue的方法valueWithNonretainedObject）</em></p><ul><li>NSDictionary 的局限性</li></ul><p>NSDictionary 提供了 key -&gt; object 的映射。从本质上讲，NSDictionary 中存储的 object 位置是由 key 来索引的。</p><p>由于对象存储在特定位置，NSDictionary 中要求 key 的值不能改变（否则 object 的位置会错误）。为了保证这一点，NSDictionary 会始终复制 key 到自己私有空间。</p><p>这个 key 的复制行为也是 NSDictionary 如何工作的基础，但这也有一个限制：你只能使用 OC 对象作为 NSDictionary 的 key，并且必须支持 NSCopying 协议。此外，key 应该是小且高效的，以至于复制的时候不会对 CPU 和内存造成负担。</p><p>这意味着，NSDictionary 中真的只适合将值类型的对象作为 key（如简短字符串和数字）。并不适合自己的模型类来做对象到对象的映射。</p><ul><li>对象到对象的映射</li></ul><p>NSMapTable（顾名思义）更适合于一般来说的映射概念。这取决于它的设计方式，NSMapTable 可以处理的 key -&gt; obj 式映射如 NSDictionary，但它也可以处理 obj -&gt; obj 的映射 - 也被称为 “关联数组” 或简称为 “map”。</p><p>比如一个 NSMapTable 的构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMapTable *mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];</span><br></pre></td></tr></table></figure><p>这将会和 NSMutableDictionary 用起来一样一样的，复制 key，并对它的 object 引用计数 +1。<br>一个真正的对象到对象(object-to-object)的映射可以构造如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSMapTable *mapTable = [NSMapTable strongToStrongObjectsMapTable];</span><br></pre></td></tr></table></figure><p>如果想要将teacher对象作为key，则需要让Teacher类遵循NSCopying协议，而且NSDictionary/NSMutable使用hash表来实现key和value之间的映射和存储，所以作为key值的类型必须重写<br>++- (NSUInteger)hash++<br>和++- (BOOL)isEqual:(id)object++<br>两个方法，其中hash方法计算该对象的hash值，hash值决定该对象在hash表中存储的位置，isEqual方法通过hash值来定位对象在hash表中的位置。具体代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Teacher.m</span><br><span class="line">@implementation Teacher</span><br><span class="line"></span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    Teacher *teacher = [[Teacher allocWithZone:zone] init];</span><br><span class="line">    teacher.name = self.name;</span><br><span class="line">    teacher.age = self.age;</span><br><span class="line">    return teacher;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)isEqual:(id)object</span><br><span class="line">&#123;</span><br><span class="line">    // 比较hash值是否相等</span><br><span class="line">    return [self hash] == [object hash];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSUInteger)hash</span><br><span class="line">&#123;</span><br><span class="line">    // 调用父类的hash方法，也可以自定义</span><br><span class="line">    return [super hash];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KVO的使用&quot;&gt;&lt;a href=&quot;#KVO的使用&quot; class=&quot;headerlink&quot; title=&quot;KVO的使用&quot;&gt;&lt;/a&gt;KVO的使用&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;添加观察&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
    
      <category term="KVO,iOS" scheme="http://lbrjms.github.io/tags/KVO-iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发的之RunTime</title>
    <link href="http://lbrjms.github.io/2019/08/12/iOS%E5%BC%80%E5%8F%91%E7%9A%84%E4%B9%8BRunTime/"/>
    <id>http://lbrjms.github.io/2019/08/12/iOS开发的之RunTime/</id>
    <published>2019-08-12T03:35:38.000Z</published>
    <updated>2019-08-12T03:58:07.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建NSObject分类"><a href="#创建NSObject分类" class="headerlink" title="创建NSObject分类"></a>创建NSObject分类</h3><ul><li>重写 +(void)load</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark -- 数组越界protect</span><br><span class="line"></span><br><span class="line">    exchangeMethod(objc_getClass(&quot;__NSArrayI&quot;), NSSelectorFromString(@&quot;objectAtIndex:&quot;), NSSelectorFromString(@&quot;iris_objectAtIndex:&quot;));</span><br><span class="line"></span><br><span class="line">    exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), NSSelectorFromString(@&quot;objectAtIndex:&quot;), NSSelectorFromString(@&quot;irisM_objectAtIndex:&quot;));</span><br><span class="line">#pragma mark -- 容器 nil protect</span><br><span class="line">    exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(addObject:), NSSelectorFromString(@&quot;iris_addObject:&quot;));</span><br><span class="line">    exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(insertObject:atIndex:), NSSelectorFromString(@&quot;iris_insertObject:atIndex:&quot;));</span><br></pre></td></tr></table></figure><ul><li>方法替换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void exchangeMethod(Class class ,SEL originalSelector, SEL swizzlingSelector) &#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzlingMethod = class_getInstanceMethod(class, swizzlingSelector);</span><br><span class="line">        BOOL isAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzlingMethod), method_getTypeEncoding(swizzlingMethod));</span><br><span class="line">        if (isAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzlingSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzlingMethod);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>NSMutableArray、NSArray的分类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">@interface NSArray (IRISExtension)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSArray (IRISExtension)</span><br><span class="line"></span><br><span class="line">- (id)iris_objectAtIndex:(NSInteger) index &#123;</span><br><span class="line">    if (self.count - 1 &lt; index) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            return [self iris_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        @catch(NSException *exception) &#123;</span><br><span class="line">            NSLog(@&quot;%s Crash Because Method %s&quot;,class_getName([self class]), __func__);</span><br><span class="line">            NSLog(@&quot;%@&quot;, [exception callStackSymbols]);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self iris_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface NSMutableArray (IRISExtension)</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation NSMutableArray (IRISExtension)</span><br><span class="line"></span><br><span class="line">- (id)irisM_objectAtIndex:(NSInteger) index &#123;</span><br><span class="line">    if (self.count - 1 &lt; index  || self.count == nil) &#123;</span><br><span class="line">        @try &#123;</span><br><span class="line">            return [self irisM_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        @catch(NSException *exception) &#123;</span><br><span class="line">            NSLog(@&quot;%s Crash Because Method %s&quot;,class_getName([self class]), __func__);</span><br><span class="line">            NSLog(@&quot;%@&quot;, [exception callStackSymbols]);</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line">        @finally &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return [self irisM_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (void)iris_addObject:(id)anObject&#123;</span><br><span class="line">    if (!anObject) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self iris_addObject:anObject];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)iris_insertObject:(id)anObject atIndex:(NSUInteger) index &#123;</span><br><span class="line">    if (!anObject) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self iris_insertObject:anObject atIndex:index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h3 id="未识别消息的转发也在NSObject的分类中实现"><a href="#未识别消息的转发也在NSObject的分类中实现" class="headerlink" title="未识别消息的转发也在NSObject的分类中实现"></a>未识别消息的转发也在NSObject的分类中实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#pragma mark ----- 未识别方法 unRecognizedSelector Protect</span><br><span class="line">    NSString *methodName = NSStringFromSelector(aSelector);</span><br><span class="line">    NSString *oriClassName = NSStringFromClass([self class]);</span><br><span class="line"></span><br><span class="line">    if ([self isKindOfClass:NSClassFromString(@&quot;UITextInputController&quot;)]</span><br><span class="line">        || [NSStringFromClass([self class]) hasPrefix:@&quot;UIKeyboard&quot;]</span><br><span class="line">        || [methodName isEqualToString:@&quot;dealloc&quot;]) &#123;</span><br><span class="line"></span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    if ([oriClassName hasPrefix:@&quot;_&quot;]</span><br><span class="line">        &amp;&amp; ![oriClassName containsString:@&quot;__NSArray&quot;])&#123;</span><br><span class="line">        // 过滤可变数组和不可变数组</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;**********************************************************************&quot;);</span><br><span class="line">    NSLog(@&quot;** [%@ class] :unRecognizedSelector: %@ **&quot;,NSStringFromClass([self class]), NSStringFromSelector(aSelector));</span><br><span class="line">    NSLog(@&quot;**********************************************************************&quot;);</span><br><span class="line"></span><br><span class="line">    NSString *className = [NSString stringWithFormat:@&quot;IRISBase%@&quot;,oriClassName];</span><br><span class="line">    className = [className stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;&quot;];</span><br><span class="line">    Class originalClass = object_getClass([IRISObject class]);</span><br><span class="line">    Method classMethod = class_getInstanceMethod(originalClass, @selector(baseMethod:));</span><br><span class="line">    const char *types = method_getTypeEncoding(classMethod);</span><br><span class="line">    IMP baseImp = method_getImplementation(classMethod);</span><br><span class="line">    class_addMethod([IRISObject class], aSelector, baseImp, types);</span><br><span class="line"></span><br><span class="line">    u_int count = 0;</span><br><span class="line">    Method *methodList = class_copyMethodList([IRISObject class], &amp;count);</span><br><span class="line">    for (int i = 0; i &lt; count; i ++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        SEL aSel = method_getName(method);</span><br><span class="line">        DLog(@&quot;类名:%@ 方法器:%@&quot;,NSStringFromClass([IRISObject class]) ,NSStringFromSelector(aSel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return [IRISObject new];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点要对键盘相关和textfiled相关的做不处理判断</strong></p><h3 id="三步消息转发"><a href="#三步消息转发" class="headerlink" title="三步消息转发"></a>三步消息转发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 第一步 实例方法专用  方法解析</span><br><span class="line"> **/</span><br><span class="line"></span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;%@&quot;,NSStringFromSelector(sel));</span><br><span class="line"></span><br><span class="line">    if(sel == @selector(DoThings:Num:))&#123;</span><br><span class="line">        class_addMethod([self class], sel, (IMP)MyMethodIMP, &quot;v@:&quot;);</span><br><span class="line">        return YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return  [super resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 第二步 如果第一步未处理，那么让别的对象去处理这个方法</span><br><span class="line"> **/</span><br><span class="line">-(id)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    if([NSStringFromSelector(aSelector) isEqualToString:@&quot;DoThings:Num:&quot;])&#123;</span><br><span class="line">        return [[Tools alloc]init];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 第三步 如果前两步未处理，这是最后处理的机会将目标函数以其他形式执行</span><br><span class="line"> **/</span><br><span class="line">-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line"></span><br><span class="line">    NSString *SelStr = NSStringFromSelector(aSelector);</span><br><span class="line">    if([SelStr isEqualToString:@&quot;DoThings:Num:&quot;])&#123;</span><br><span class="line">        [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    return [super methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)forwardInvocation:(NSInvocation *)anInvocation&#123;</span><br><span class="line"></span><br><span class="line">    //改变消息接受者对象</span><br><span class="line">    [anInvocation invokeWithTarget:[[Tools alloc]init]];</span><br><span class="line"></span><br><span class="line">    //改变消息的SEL</span><br><span class="line">    anInvocation.selector = @selector(flyGame);</span><br><span class="line">    [anInvocation invokeWithTarget:self];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)flyGame&#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;我要飞翔追逐梦想！&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)GG_initWithDictionaryForModel:(NSDictionary *)dic&#123;</span><br><span class="line"></span><br><span class="line">    id myObj = [[self alloc] init];</span><br><span class="line">    unsigned int outCount;     //获取类中的所有成员属性</span><br><span class="line">    objc_property_t *arrPropertys = class_copyPropertyList([self class], &amp;outCount);</span><br><span class="line"></span><br><span class="line">    for (NSInteger i = 0; i &lt; outCount; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        //获取属性名字符串</span><br><span class="line">        objc_property_t property = arrPropertys[i];</span><br><span class="line">        //model中的属性名</span><br><span class="line">        NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)];</span><br><span class="line"></span><br><span class="line">        id propertyValue = dic[propertyName];</span><br><span class="line">        if (propertyValue != nil) &#123;</span><br><span class="line">            [myObj setValue:propertyValue forKey:propertyName];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //注意在runtime获取属性的时候，并不是ARC Objective-C的对象所有需要释放</span><br><span class="line">    free(arrPropertys);</span><br><span class="line">    return myObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/2b61270cd038" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      runtime解决数组越界 方法找不到崩溃问题
    
    </summary>
    
    
      <category term="iOS" scheme="http://lbrjms.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发的内存|循环引用问题</title>
    <link href="http://lbrjms.github.io/2019/08/08/iOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://lbrjms.github.io/2019/08/08/iOS开发的内存-循环引用问题/</id>
    <published>2019-08-08T13:19:23.000Z</published>
    <updated>2019-08-10T15:20:03.053Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>我们知道oc存储主要分成数据区、堆区和栈区，</em></strong></p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>B控制器中有block属性 A跳转B 并且在A中实现B的block 并调用了self属性</p><p>如果A持有了B那么此时就造成循环引用</p><p>因为A持有了B 并且B的block中持有了self（A）这样就无法执行dealloc 方法造成循环引用（self是一个指向实例对象的指针，它的生命周期至少是伴随着当前的实例对象的）</p><p>有时候B中的block会在B之后销毁 那么就需要用__strong修饰weakSelf 虽然此时也是强引用 但是strongSelf只是局部变量 他的作用域仅限于局部代码，而程序一旦跳出作用域，strongSelf就会被释放，这个临时产生的“循环引用”就会被自动打破 接下来self就会被销毁</p><h3 id="weak关键字"><a href="#weak关键字" class="headerlink" title="weak关键字"></a>weak关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case OPERATION_retain:</span><br><span class="line">    CFBasicHashAddValue( table, obj );</span><br><span class="line">    return obj;</span><br><span class="line">case OPERATION_retainCount:</span><br><span class="line">    count = CFBasicHashGetCountOfKey( table, obj );</span><br><span class="line">    return count;</span><br><span class="line">case OPERATION_release:</span><br><span class="line">    count = CFBasicHashRemoveValue( table, obj );</span><br><span class="line">    return 0 == count;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wzzvictory/article/details/17694129" target="_blank" rel="noopener">Objective-C高级编程：iOS与OS X多线程和内存管理</a></p><h3 id="局部变量的销毁时机"><a href="#局部变量的销毁时机" class="headerlink" title="局部变量的销毁时机"></a>局部变量的销毁时机</h3><p>在 ARC下，方法会自动调用 -autorelease 方法。<br>调用后，该变量会被添加到自动释放池。<br>在主线程中，临时变量会在 runloop 运行结束时释放。<br>在非主线程中，临时变量会在 线程退出时释放。<br>所以，当有大量的临时对象时，官方建议我们使用 @autoreleasepool 进行内存管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0;i &lt; 50000; i++) &#123;</span><br><span class="line"></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *fileContents = @&quot;test&quot;;</span><br><span class="line">        NSLog(@&quot;%@&quot;,fileContents);</span><br><span class="line">        /* Process the string, creating and autoreleasing more objects. */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">__NSCFString, 0x600002b690b0</span><br><span class="line">2019-08-09 12:00:58.910312+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695efbf4===1</span><br><span class="line">2019-08-09 12:00:58.910380+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695debf7===11</span><br><span class="line">2019-08-09 12:00:58.910443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb86a4debf6===111</span><br><span class="line">2019-08-09 12:00:58.910529+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebbb7a4debf1===1111</span><br><span class="line">2019-08-09 12:00:58.910611+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1e8ab7a4debf0===11111</span><br><span class="line">2019-08-09 12:00:58.910698+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b2f8ab7a4debf3===111111</span><br><span class="line">2019-08-09 12:00:58.910832+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbaa2f8ab7a4debf2===1111111</span><br><span class="line">2019-08-09 12:00:58.914443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b675c18ec0810d===11111111</span><br><span class="line">2019-08-09 12:00:58.914550+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb85675c18ec0810c===111111111</span><br><span class="line">2019-08-09 12:00:58.914625+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb98c04c3b7a9450f===1111111111</span><br><span class="line">2019-08-09 12:00:58.914713+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbe0c04c3b7a9450e===11111111111</span><br><span class="line">2019-08-09 12:00:58.914783+0800 TTTTTT[15263:1321694] __NSCFString, 0x600002525220===111111111111</span><br></pre></td></tr></table></figure><h3 id="栈对象和堆对象"><a href="#栈对象和堆对象" class="headerlink" title="栈对象和堆对象"></a>栈对象和堆对象</h3><p>在栈上创建对象是非常快的，因为很多东西在编译时就确定了，运行时分配空间几乎不耗时；相对而言在堆上创建对象就非常耗时。栈对象的生命周期是确定的，对象出栈以后就会被释放，不会存在内存泄漏，但这同时也是栈对象的最大缺点。Objective-C 变量有效范围是由 “{}” 包含的块来决定的，也就是说栈对象的生命周期仅限于其所在的块里，出了块立马会被释放。一个对象被创建以后有可能会通过方法调用传递到别的方法，当栈对象的创建方法返回时，栈对象会被一起 pop 出栈而释放，导致其没法在别处被继续持有。此时 retain 操作会失效，除非用 copy 方法在想持有该栈对象的地方重新拷贝一份属于自己的栈对象(block).</p><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><ul><li>我们也可以在WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li><li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li><li>在内存读取上有着3倍的效率，创建时比以前快106倍。由此可见，苹果引入Tagged Pointer<br>，不但减少了64位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。</li></ul><ul><li><p>浪费内存<br>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。<br>所以一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍</p></li><li><p>效率问题<br>为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。</p></li><li><p>问题<br>Tagged Pointer的引入也带来了问题，即Tagged Pointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。所有对象都有 isa指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以不能访问isa</p></li></ul><p><em>为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。</em><br><a href="https://www.jianshu.com/p/c9089494fb6c" target="_blank" rel="noopener">参考</a><br><a href="http://www.cocoachina.com/articles/13449" target="_blank" rel="noopener">Tagged Pointer字符串</a><br><a href="http://www.nscookies.com/tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer</a><br><a href="http://www.nscookies.com/literal/" target="_blank" rel="noopener">字面量(Literal)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;我们知道oc存储主要分成数据区、堆区和栈区，&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;循环引用&quot;&gt;&lt;a href=&quot;#循环引用&quot; class=&quot;headerlink&quot; title=&quot;循环引用&quot;&gt;&lt;/a&gt;循环引用&lt;/h3&gt;&lt;p&gt;B控制器中有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift开发之算法</title>
    <link href="http://lbrjms.github.io/2019/08/05/swift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://lbrjms.github.io/2019/08/05/swift开发之算法/</id>
    <published>2019-08-05T10:58:49.000Z</published>
    <updated>2019-08-06T11:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ list: inout [Int],_ n: Int) &#123;</span><br><span class="line"></span><br><span class="line">   if n&lt;=1 &#123;return&#125;</span><br><span class="line">   for i in 0..&lt;n &#123;</span><br><span class="line">       for j in 0..&lt;n-i-1 &#123;</span><br><span class="line">           if list[i] &gt; list[j+1] &#123;</span><br><span class="line">               list.swapAt(j, j+1)</span><br><span class="line">               print(j)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">///</span><br><span class="line">class InsertSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line"></span><br><span class="line">        var j = 0</span><br><span class="line">        // 每次取出后面未排序的数组的第一个值 与前面有序数组的进行比较 插入到相应的位置</span><br><span class="line">        for i in 1 ..&lt; list.count &#123;</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt; 0 &#123;</span><br><span class="line">                if list[j] &lt; list[j-1] &#123;</span><br><span class="line">                    list.swapAt(j-1, i)</span><br><span class="line">                    j = j - 1</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序</span><br><span class="line">    // 时间复杂度永远是n*n</span><br><span class="line">    func chooseSort(_ list: inout [Int], _ n: Int)  &#123;</span><br><span class="line">        // 数组长度大于一才排序</span><br><span class="line">        if n &lt;= 1 &#123; return &#125;</span><br><span class="line">        var min = 0</span><br><span class="line">        var index = 0</span><br><span class="line">//        为false，断言被触发，终止应用。</span><br><span class="line">//        当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：</span><br><span class="line">//</span><br><span class="line">//        整数类型的下标索引被传入一个自定义小标实现，但是下标索引值可能太小或者太大</span><br><span class="line">//        需要给函数传入一个值，但是非法的值可能导致函数不能正常执行</span><br><span class="line">//        一个可选值现在是nil，但是后面的代码运行需要一个非nil值</span><br><span class="line"></span><br><span class="line">        assert(index != -1, &quot;A person&apos;s age cannot be less than zero&quot;)</span><br><span class="line"></span><br><span class="line">        for i in  0 ..&lt; n &#123;</span><br><span class="line">            min = list[i]</span><br><span class="line">            index = i</span><br><span class="line">            for j in i ..&lt; n &#123;</span><br><span class="line">                // 每次找到未排序数字的最小值</span><br><span class="line">                if list[j] &lt; min &#123;</span><br><span class="line">                    // 如果找到一个比min小的值 就赋值给min 并且记录这个值的索引 直到这层循环结束 找到的就是最小的</span><br><span class="line">                    min = list[j]</span><br><span class="line">                    index = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 找到最小值之后放在前面（已经排序数组的最后面）</span><br><span class="line">            list.swapAt(i, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>希尔排序（把数组通过步长（step）分成 n/step个小数组数组，再分别对这些小数组进行插入排序，直到步长等于0结束）</li><li>[2,35,56,767,989,0,45,345]</li><li>[0,4][1,5],[2,6],[3,7]</li><li>[0,2,4,6][1,3,5,7]</li><li>[0,1,2,3,4,5,6,7]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ShellSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var step = list.count / 2</span><br><span class="line">        var j = 0</span><br><span class="line"></span><br><span class="line">        // 步长等于0结束</span><br><span class="line">        while step &gt; 0 &#123;</span><br><span class="line">            for i in step ..&lt; list.count &#123;</span><br><span class="line">                j = i</span><br><span class="line">                while j &gt;= step &#123;</span><br><span class="line">                    if list[j] &lt; list[j-step] &#123;</span><br><span class="line">                        list.swapAt(j-step, j)</span><br><span class="line">                        j = j - step</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环</span><br><span class="line">                        break</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step = step / 2 //缩小步长</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>分而治之的思想 先把整体分割成n个只有一个数据数组 这时候是有序的</li><li>将这些有序的数组两两结合成有序数组</li><li>重复上面的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MergeSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line"></span><br><span class="line">        // 拆分一个数组 为n个有序数组 放在一个大数组里面</span><br><span class="line">        var totalArr: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">        for item in list &#123;</span><br><span class="line">            var subArray: Array&lt;Int&gt; = []</span><br><span class="line">            subArray.append(item)</span><br><span class="line">            totalArr.append(subArray)</span><br><span class="line">        &#125;</span><br><span class="line">        // 重复拆分工作 直到就剩一个数组</span><br><span class="line">        while totalArr.count != 1 &#123;</span><br><span class="line">            // 每次走完一遍 重新从0开始</span><br><span class="line">            var i = 0</span><br><span class="line">            while i &lt; totalArr.count - 1 &#123;</span><br><span class="line">                // 两两合并</span><br><span class="line">                totalArr[i] = mergeArray(firstList: totalArr[i], secondList: totalArr[i+1])</span><br><span class="line">                totalArr.remove(at: i + 1)</span><br><span class="line">                i = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalArr[0]</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并两个有序数组</span><br><span class="line">    func mergeArray(firstList: Array&lt;Int&gt;, secondList: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var resultList: Array&lt;Int&gt; = []</span><br><span class="line">        var firstIndex = 0</span><br><span class="line">        var secondIndex = 0</span><br><span class="line"></span><br><span class="line">        while firstIndex &lt; firstList.count &amp;&amp; secondIndex &lt; secondList.count &#123;</span><br><span class="line">            if firstList[firstIndex] &lt; secondList[secondIndex] &#123;</span><br><span class="line">                resultList.append(firstList[firstIndex])</span><br><span class="line">                firstIndex = firstIndex + 1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resultList.append(secondList[secondIndex])</span><br><span class="line">                secondIndex = secondIndex + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果其中一个数组还有数据没有放进结果数组里面 就把剩下的放进去</span><br><span class="line">        while firstIndex &lt; firstList.count &#123;</span><br><span class="line">            resultList.append(firstList[firstIndex])</span><br><span class="line">            firstIndex = firstIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line">        while secondIndex &lt; secondList.count &#123;</span><br><span class="line">            resultList.append(secondList[secondIndex])</span><br><span class="line">            secondIndex = secondIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line">        return resultList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//  分而治之的思想</span><br><span class="line"> func quickSort(_ array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">     guard array.count &gt; 1 else &#123;</span><br><span class="line">         return array</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     let pivot = array[array.count/2]</span><br><span class="line">     let left = array.filter&#123; $0 &lt; pivot &#125;</span><br><span class="line">     let middle = array.filter&#123; $0 == pivot &#125;</span><br><span class="line">     let right = array.filter&#123; $0 &gt; pivot &#125;</span><br><span class="line"></span><br><span class="line">     return quickSort(left) + middle + quickSort(right)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">// 降低空间复杂度的快排</span><br><span class="line"> func quickSortPro(_ array: inout [Int], _ n: Int) &#123;</span><br><span class="line">        quickSortC(&amp;array, 0, n-1)</span><br><span class="line">    &#125;</span><br><span class="line">    func quickSortC(_ array: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &gt; right &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        let pivot = partition(&amp;array, left, right)</span><br><span class="line">        quickSortC(&amp;array, left, pivot - 1)</span><br><span class="line">        quickSortC(&amp;array, pivot + 1, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ array: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        let pivot = array[right]</span><br><span class="line">        var i = left</span><br><span class="line">        for j in left ..&lt; right &#123;</span><br><span class="line">            if array[j] &lt; pivot &#123;</span><br><span class="line">                array.swapAt(j, i)</span><br><span class="line">                i = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array.swapAt(i, right)</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class BucketSort: SortType &#123;</span><br><span class="line">//    inout修饰的参数是不能有默认值的，有范围的参数集合也不能被修饰；</span><br><span class="line">//    一个参数一旦被inout修饰，就不能再被var和let修饰了。</span><br><span class="line">//    1.监测属性,其实是给存储属性上添加的一种监测功能,willSet 监测新值,didSet 监测旧值</span><br><span class="line">//    2.如果函数的参数是inout 修饰的,你如果将监测的属性传入这个函数的时候,此时会将属性的值拷贝一份,在函数结束的时候,将值重新付给属性,所以函数执行完毕后,会触发监测函数</span><br><span class="line"></span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var bucket = createBucket()</span><br><span class="line">        let maxNumber = listMaxItem(arr: list)</span><br><span class="line">        let maxLeagth = numberLength(number: maxNumber)</span><br><span class="line"></span><br><span class="line">        for digit in 1 ... maxLeagth &#123;</span><br><span class="line">            // 入桶操作</span><br><span class="line">            for item in list &#123;</span><br><span class="line">                let baseNum = fetchBaseNumber(number: item, digit: digit)</span><br><span class="line">                // 根据基数放入对应的桶中</span><br><span class="line">                bucket[baseNum].append(item)</span><br><span class="line">            &#125;</span><br><span class="line">            var index = 0</span><br><span class="line">            // 出桶</span><br><span class="line">            for i in 0..&lt;bucket.count &#123;</span><br><span class="line">                while !bucket[i].isEmpty &#123;</span><br><span class="line">                    list[index] = bucket[i].remove(at: 0)</span><br><span class="line">                    index = index + 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 创建十个桶</span><br><span class="line">    ///</span><br><span class="line">    /// - Returns: 放着十个桶的数组</span><br><span class="line">    func createBucket() -&gt; Array&lt;Array&lt;Int&gt;&gt;&#123;</span><br><span class="line"></span><br><span class="line">        var buckets: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">        for _ in 0 ..&lt; 10 &#123;</span><br><span class="line">            buckets.append([])</span><br><span class="line">        &#125;</span><br><span class="line">        return buckets</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 取到最大值</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter arr: 数组</span><br><span class="line">    /// - Returns: 最大值</span><br><span class="line">    func listMaxItem(arr : Array&lt;Int&gt;) -&gt; Int &#123;</span><br><span class="line">        var max = arr[0]</span><br><span class="line">        for item in arr &#123;</span><br><span class="line">            if max &lt; item &#123;</span><br><span class="line">                max = item</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 返回最大数字的长度</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter number: 最大值</span><br><span class="line">    /// - Returns: 长度</span><br><span class="line">    func numberLength(number: Int) -&gt; Int &#123;</span><br><span class="line">        return &quot;\(number)&quot;.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 获取相应位上的数字</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameters:</span><br><span class="line">    ///   - number: 操作的数字</span><br><span class="line">    ///   - digit: 位数</span><br><span class="line">    /// - Returns: 返回该位上的数字</span><br><span class="line">    func fetchBaseNumber(number: Int, digit: Int) -&gt; Int &#123;</span><br><span class="line"></span><br><span class="line">        if digit &gt; 0 &amp;&amp; digit &lt;= numberLength(number: number)&#123;</span><br><span class="line">            var numArr: Array&lt;Int&gt; = []</span><br><span class="line">            for char in &quot;\(number)&quot; &#123;</span><br><span class="line">                numArr.append(Int(&quot;\(char)&quot;)!)</span><br><span class="line">            &#125;</span><br><span class="line">            return numArr[numArr.count - digit]</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典之作-二分法"><a href="#经典之作-二分法" class="headerlink" title="经典之作 二分法"></a>经典之作 二分法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/// while循环实现</span><br><span class="line">// Comparable协议继承于Equatable，实现Comparable协议可以在Equatable的基础上使类型支持&gt;，&gt;=，&lt;，&lt;=四种运算符</span><br><span class="line">extension Array where Element: Comparable &#123;</span><br><span class="line"></span><br><span class="line">    public var isSorted: Bool&#123;</span><br><span class="line">        var previousIndex = startIndex</span><br><span class="line">        var currentIndex = previousIndex + 1</span><br><span class="line"></span><br><span class="line">        while currentIndex != endIndex &#123;</span><br><span class="line">            if self[previousIndex] &gt; self[currentIndex]&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousIndex = currentIndex</span><br><span class="line">            currentIndex = currentIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func binarySearch&lt;T: Comparable&gt;(sortedElements: [T], for element: T) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">        assert(sortedElements.isSorted)</span><br><span class="line"></span><br><span class="line">        var m = 0, n = sortedElements.count - 1</span><br><span class="line">        // 二分法</span><br><span class="line">        while m &lt; n &#123;</span><br><span class="line">            let mid = (n-m)/2 + m</span><br><span class="line"></span><br><span class="line">            if sortedElements[mid] == element &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125; else if sortedElements[mid] &lt; element &#123;</span><br><span class="line">                m = mid + 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                n = mid - 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归实现 二分法</span><br><span class="line">    var sortedElements2 = [1,2,3,4,23,24,56,78]</span><br><span class="line">    var element = 56</span><br><span class="line">    func digui(_ m: Int, _ n: Int) -&gt;Int &#123;</span><br><span class="line"></span><br><span class="line">        let mid = (n-m)/2 + m</span><br><span class="line">        var mm = m</span><br><span class="line">        var nn = n</span><br><span class="line"></span><br><span class="line">        if mm&gt;nn &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if sortedElements2[mid] == element &#123;</span><br><span class="line"></span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if sortedElements2[mid] &lt; element &#123;</span><br><span class="line">            mm = mid + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nn = mid - 1</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return digui(mm, nn)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现1到n的和"><a href="#递归实现1到n的和" class="headerlink" title="递归实现1到n的和"></a>递归实现1到n的和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sum(n: Int) -&gt; Int &#123;</span><br><span class="line">     if n == 0 &#123;</span><br><span class="line">         print(&quot;000000&quot;)</span><br><span class="line">         return 0</span><br><span class="line">     &#125;else if n == 1 &#123;</span><br><span class="line">         print(&quot;111111111&quot;)</span><br><span class="line">         return 1</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         print(&quot;\(n)&quot;)</span><br><span class="line">         return (sum(n:(n-1)) + n)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="不借用第三方变量实现交换两个变量"><a href="#不借用第三方变量实现交换两个变量" class="headerlink" title="不借用第三方变量实现交换两个变量"></a>不借用第三方变量实现交换两个变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"></span><br><span class="line">///////////// 按位异或</span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure><h3 id="找出数组中的两个数据值和等于-一个确定的值"><a href="#找出数组中的两个数据值和等于-一个确定的值" class="headerlink" title="找出数组中的两个数据值和等于 一个确定的值"></a>找出数组中的两个数据值和等于 一个确定的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">func choseTwo(numsArr: [Int], targetValue: Int) -&gt; [Int] &#123;</span><br><span class="line">   var dic = [Int: Int]()</span><br><span class="line">   for (i,num) in numsArr.enumerated() &#123;</span><br><span class="line">       if let index = dic[targetValue - num] &#123;</span><br><span class="line">           return [index, i]</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           // 值为键 索引为值 储存数据</span><br><span class="line">           dic[num] = i</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 ：<a href="https://www.cnblogs.com/ludashi/p/6065086.html" target="_blank" rel="noopener">https://www.cnblogs.com/ludashi/p/6065086.html</a><br>      <a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201403/430986.htm</a><br>      <a href="https://www.cnblogs.com/jingmoxukong/p/4303826.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/4303826.html</a><br>      <a href="https://www.jianshu.com/p/77ba54a46ad7" target="_blank" rel="noopener">https://www.jianshu.com/p/77ba54a46ad7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift开发之可POP</title>
    <link href="http://lbrjms.github.io/2019/08/03/swift%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8F%AFPOP/"/>
    <id>http://lbrjms.github.io/2019/08/03/swift开发之可POP/</id>
    <published>2019-08-03T02:55:52.000Z</published>
    <updated>2019-08-03T03:21:21.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OOP的优点"><a href="#OOP的优点" class="headerlink" title="OOP的优点"></a><font color="red">OOP的优点</font></h3><ul><li><font color="blue">封装与权限控制  </font></li></ul><p><em>.h声明公用的变量方法，.m声明私有变量和方法 public/internal/fileprivate/private</em></p><ul><li><font color="blue">命名空间</font></li></ul><p><em>OC没有命名空间，swift有命名空间</em></p><ul><li><font color="blue">扩展性</font></li></ul><p><em>extension category 另外通过代理实现更加灵活的扩展</em></p><ul><li><font color="blue">继承多态</font></li></ul><p><em>公用的方法变量写在父类中，继承的子类根据需求实现对应的功能</em>  </p><h3 id="OOP的缺点"><a href="#OOP的缺点" class="headerlink" title="OOP的缺点"></a><font color="red">OOP的缺点</font></h3><ul><li>隐式共享</li></ul><p>class是引用类型，当在代码中的改变了实例变量的时候，另一处调用此变量收到修改的影响</p><ul><li>冗杂的父类</li></ul><p>代码的迭代，父类越来越冗杂，职权不明确、依赖严重</p><ul><li>多继承</li></ul><h3 id="POP的优点"><a href="#POP的优点" class="headerlink" title="POP的优点"></a><font color="red">POP的优点</font></h3><ul><li>更加灵活</li></ul><p>不再有冗杂的父类，通过不同的协议实现</p>]]></content>
    
    <summary type="html">
    
      2015年WWDC苹果第一次提出了POP，POP成为的swift的灵魂，更加抽象、灵活
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift for循环</title>
    <link href="http://lbrjms.github.io/2019/07/25/swift-for%E5%BE%AA%E7%8E%AF/"/>
    <id>http://lbrjms.github.io/2019/07/25/swift-for循环/</id>
    <published>2019-07-25T13:29:43.000Z</published>
    <updated>2019-07-28T13:24:17.015Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// &lt;font color=&quot;red&quot;&gt;闭区间&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">       let arr = [1, 32, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">       for i in 1...3 &#123;</span><br><span class="line">           i</span><br><span class="line">       &#125;</span><br><span class="line">       // 前闭后开</span><br><span class="line">       for j in 1..&lt;3 &#123;</span><br><span class="line">           j</span><br><span class="line">       &#125;</span><br><span class="line">       // 返回元组</span><br><span class="line">       for (i, value) in arr.enumerated() &#123;</span><br><span class="line">           i</span><br><span class="line">           value</span><br><span class="line">       &#125;</span><br><span class="line">       // 跳步循环</span><br><span class="line">       for i in stride(from: -5, to: 5, by: 0.1) &#123;</span><br><span class="line">           sin(i)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 反向循环</span><br><span class="line">       for p in arr.reversed() &#123;</span><br><span class="line">           p</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><font color="red">闭区间</font></p>]]></content>
    
    <summary type="html">
    
      swift3.0之后废弃了传统的for循环
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS更换项目名</title>
    <link href="http://lbrjms.github.io/2019/07/19/iOS%E6%9B%B4%E6%8D%A2%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
    <id>http://lbrjms.github.io/2019/07/19/iOS更换项目名/</id>
    <published>2019-07-19T09:42:14.000Z</published>
    <updated>2019-07-19T10:22:46.806Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># encoding: UTF-8</span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line">require &apos;fileutils&apos;</span><br><span class="line">require &apos;active_support/all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLD_PREFIX = &quot;SetNickNameVC&quot;</span><br><span class="line">NEW_PREFIX = &quot;LHGJResetPswVC&quot;</span><br><span class="line"></span><br><span class="line">FOLDER_EXCLUDE = [&quot;Pods&quot;, &quot;.framework&quot;]</span><br><span class="line">CONTENT_EXCLUDE = [&quot;.xcuserstate&quot;, &quot;.a&quot;, &quot;.mp3&quot;, &quot;.avi&quot;, &quot;.mp4&quot;, &quot;.wmv&quot;, &quot;.webp&quot;, &quot;.png&quot;, &quot;.jpg&quot;, &quot;.rb&quot;]</span><br><span class="line"></span><br><span class="line"># REGEXP = &quot;([^a-zA-Z_0-9]|^)#&#123;OLD_PREFIX&#125;([A-Z].*?)&quot;</span><br><span class="line">REGEXP = &quot;#&#123;OLD_PREFIX&#125;(.*?)&quot;</span><br><span class="line">NEW_STRING = &apos;\1&apos;+NEW_PREFIX+&apos;\2&apos;</span><br><span class="line"></span><br><span class="line">def search(dir)</span><br><span class="line">    Dir[File.join(dir, &apos;*&apos;)].each do |file|</span><br><span class="line">        unless FOLDER_EXCLUDE.include?(File.extname(file).empty? ? File.basename(file) : File.extname(file))</span><br><span class="line">            # 非排除的文件夹，才进入搜索</span><br><span class="line">            if File.directory?(file)</span><br><span class="line">                search(file)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if File.file?(file)</span><br><span class="line">            search_content(file)</span><br><span class="line">        end</span><br><span class="line">        filename = File.basename(file)</span><br><span class="line">        new_filename = filename.gsub(Regexp.new(REGEXP), NEW_STRING)</span><br><span class="line">        if filename != new_filename</span><br><span class="line">            dirname = File.dirname(file)</span><br><span class="line">            new_file = File.join(dirname, new_filename)</span><br><span class="line">            puts &quot;重命名文件: #&#123;file&#125; -&gt; #&#123;new_file&#125;&quot;</span><br><span class="line">            File.rename(file, new_file)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def search_content(file)</span><br><span class="line">    # 不对排查的文件进行内容替换</span><br><span class="line">    return if CONTENT_EXCLUDE.include?(File.extname(file))</span><br><span class="line">    encoding = `file -I &quot;#&#123;file&#125;&quot;`.strip.split(&apos;charset=&apos;).last</span><br><span class="line">    encoding = &quot;utf-8&quot; if encoding.empty?</span><br><span class="line">    puts &quot;分析: #&#123;file&#125; (#&#123;encoding&#125;)&quot;</span><br><span class="line">    content = File.open(file, &quot;rb:#&#123;encoding&#125;&quot;, &amp;:read)</span><br><span class="line">    reg = Regexp.new(REGEXP.encode(encoding))</span><br><span class="line">    new_content = content.gsub(reg, NEW_STRING.encode(encoding))</span><br><span class="line">    if content != new_content</span><br><span class="line">        File.open(file, &quot;w:UTF-8&quot;) do |f|</span><br><span class="line">            f.write(new_content)</span><br><span class="line">        end</span><br><span class="line">        puts &quot;更新文件内容: #&#123;file&#125;&quot;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">search(Dir.pwd)</span><br></pre></td></tr></table></figure><p><em>将以上脚本copy到rename.rb文件放在项目目录下 OLD_PREFIX、 NEW_PREFIX 分别填写你想要改的名字 执行 ruby rename.rb 即可 如果项目集成了cocoapod这时候会报错 只需要重新pod install即可</em></p>]]></content>
    
    <summary type="html">
    
      iOS开发经常会复制另一个项目进行开发更改 这时候要做的第一件事就是更改项目名，下面有一段更改项目名以及文件名的脚本
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Run Script</title>
    <link href="http://lbrjms.github.io/2019/07/19/Run-Script/"/>
    <id>http://lbrjms.github.io/2019/07/19/Run-Script/</id>
    <published>2019-07-19T05:26:33.000Z</published>
    <updated>2019-07-19T09:41:43.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="譬如启动页动态加载版本号"><a href="#譬如启动页动态加载版本号" class="headerlink" title="譬如启动页动态加载版本号"></a>譬如启动页动态加载版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前版本号</span><br><span class="line"># PlistBuddy plist操作工具 可用来对plist文件增删改查</span><br><span class="line">versionNumber=$(/usr/libexec/PlistBuddy -c &quot;Print :CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)</span><br><span class="line"># sed是一个非交互性文本流编辑器，可以与vi一样对文本进行编辑，但其可以在命令行或shell脚本中执行，从而避免了繁重的人机交互式的文件编辑操作</span><br><span class="line">sed -i bak -e &quot;/userLabel=\&quot;AppVersion\&quot;/s/text=\&quot;[^\&quot;]*\&quot;/text=\&quot;版本号：$versionNumber\&quot;/&quot; $PROJECT_DIR/LHGJiOS/Base.lproj/LaunchScreen.storyboard</span><br></pre></td></tr></table></figure><h3 id="常用的脚本"><a href="#常用的脚本" class="headerlink" title="常用的脚本"></a>常用的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">每次构建的时候build号自增</span><br><span class="line">if [ $CONFIGURATION == Release ]; then</span><br><span class="line">    echo &quot;Bumping build number...&quot;</span><br><span class="line">    plist=$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;</span><br><span class="line"></span><br><span class="line">    #increment the build number (ie 115 to 116)</span><br><span class="line">    buildnum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    if [[ &quot;$&#123;buildnum&#125;&quot; == &quot;&quot; ]]; then</span><br><span class="line">        echo &quot;No build number in $plist&quot;</span><br><span class="line">        exit 2</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    buildnum=$(expr $buildnum + 1)</span><br><span class="line"></span><br><span class="line">    /usr/libexec/Plistbuddy -c &quot;Set CFBundleVersion $buildnum&quot; &quot;$&#123;plist&#125;&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;Bumped build number to $buildnum&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;开始自增 Version 最后一位&quot;</span><br><span class="line">    versionNum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line">    # 取出第三个值</span><br><span class="line">    thirdPartVersonNum=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $3&#125;&apos;`</span><br><span class="line">    thirdPartVersonNum=$(($thirdPartVersonNum + 1))</span><br><span class="line">    newVersionStr=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $1 &quot;.&quot; $2 &quot;.&apos;$thirdPartVersonNum&apos;&quot; &#125;&apos;`</span><br><span class="line">    /usr/libexec/PlistBuddy -c &quot;Set CFBundleShortVersionString $newVersionStr&quot; &quot;$&#123;plist&#125;&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    echo $CONFIGURATION &quot; build - Not bumping build number.&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">根据bundleID不同，设置不同的jpush appkey等</span><br><span class="line">#!/bin/bash</span><br><span class="line">bundleID=$&#123;PRODUCT_BUNDLE_IDENTIFIER&#125;</span><br><span class="line">id=&quot;com.zhoumoquan.zhoumoquan&quot;</span><br><span class="line">if [&quot;$bundleID&quot;=&quot;$id&quot;]; then</span><br><span class="line">cp zmq/PushConfig_AppStore.plist zmq/PushConfig.plist</span><br><span class="line">else</span><br><span class="line">cp zmq/PushConfig_Enterprise.plist zmq/PushConfig.plist</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">打包上传时移除第三方库中无用的部分</span><br><span class="line">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line"># This script loops through the frameworks embedded in the application and</span><br><span class="line"># removes unused architectures.</span><br><span class="line">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class="line">do</span><br><span class="line">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class="line">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">for ARCH in $ARCHS</span><br><span class="line">do</span><br><span class="line">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class="line">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class="line">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class="line">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>Xcode Run Script Phase，有很多环境变量。</p><p>可以添加一个 Run Script,添加一条命令：env 编译之后就可以再编译报告里看到输出的环境变量</p>]]></content>
    
    <summary type="html">
    
      ios项目中可以添加Run Script动态加载你想要的
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃日志符号化</title>
    <link href="http://lbrjms.github.io/2019/07/19/iOS%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E7%AC%A6%E5%8F%B7%E5%8C%96/"/>
    <id>http://lbrjms.github.io/2019/07/19/iOS崩溃日志符号化/</id>
    <published>2019-07-19T04:48:57.000Z</published>
    <updated>2019-07-19T09:41:35.396Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>iOS与JS交互之WKWebView</title>
    <link href="http://lbrjms.github.io/2019/07/18/iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E4%B9%8BWKWebView/"/>
    <id>http://lbrjms.github.io/2019/07/18/iOS与JS交互之WKWebView/</id>
    <published>2019-07-18T09:53:41.000Z</published>
    <updated>2019-07-19T04:45:27.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS调js"><a href="#iOS调js" class="headerlink" title="iOS调js"></a>iOS调js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两端提前协议号方法参数</span><br><span class="line">[self.webView evaluateJavaScript:@&quot;ocToJs(&apos;loginSucceed&apos;, &apos;oc_tokenString&apos;)&quot; completionHandler:^(id response, NSError *error) &#123;&#125;];</span><br></pre></td></tr></table></figure><h3 id="js调oc"><a href="#js调oc" class="headerlink" title="js调oc"></a>js调oc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">WKScriptMessageHandler oc端实现此协议下的方法：</span><br><span class="line"></span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br><span class="line"></span><br><span class="line">、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、</span><br><span class="line">@interface WKScriptMessage : NSObject</span><br><span class="line"></span><br><span class="line">/*! @abstract The body of the message.</span><br><span class="line"> @discussion Allowed types are NSNumber, NSString, NSDate, NSArray,</span><br><span class="line"> NSDictionary, and NSNull.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, copy) id body;</span><br><span class="line"></span><br><span class="line">/*! @abstract The web view sending the message. */</span><br><span class="line">@property (nullable, nonatomic, readonly, weak) WKWebView *webView;</span><br><span class="line"></span><br><span class="line">/*! @abstract The frame sending the message. */</span><br><span class="line">@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;</span><br><span class="line"></span><br><span class="line">/*! @abstract The name of the message handler to which the message is sent.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>name判断是否是提前定义好的方法 body里面是想要的参数</p><p>我会对body做进一步的处理 这主要看自己和后台的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSData * data = [body dataUsingEncoding:NSUTF8StringEncoding];  </span><br><span class="line">NSError * err;</span><br><span class="line">id jsonData = (NSDictionary *)[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;err];</span><br><span class="line">if (err) &#123;</span><br><span class="line">    jsonData = body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载网页过程的高度进度等控制"><a href="#加载网页过程的高度进度等控制" class="headerlink" title="加载网页过程的高度进度等控制"></a>加载网页过程的高度进度等控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line"></span><br><span class="line">    if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123;</span><br><span class="line">        CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">        !self.getWebEswebEtimatedProgress?:self.getWebEswebEtimatedProgress(newprogress);</span><br><span class="line">    &#125;else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123;</span><br><span class="line">        NSString * webTitle = [change objectForKey:NSKeyValueChangeNewKey];</span><br><span class="line">        !self.getWebTitle?:self.getWebTitle(webTitle);</span><br><span class="line">    &#125;else if ([keyPath isEqualToString:NSStringFromSelector(@selector(contentSize))]) &#123;</span><br><span class="line">        //sizeThatFits: 返回一个合适的大小以布局，默认实现是返回当前视图的已知大小</span><br><span class="line">        CGSize webViewSize = self.wkWebView.scrollView.contentSize;</span><br><span class="line">        if (_observeScrollHeight) &#123;</span><br><span class="line">            _observeScrollHeight(webViewSize.height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网页加载成功后的高度回调"><a href="#网页加载成功后的高度回调" class="headerlink" title="网页加载成功后的高度回调"></a>网页加载成功后的高度回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">///网页加载成功</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123;</span><br><span class="line">    !self.didFinishNavigation?:self.didFinishNavigation();</span><br><span class="line">    /* 获取webView的高度 @&quot;document.body.scrollHeight&quot; @&quot;document.body.offsetHeight&quot; @&quot;document.body.clientHeight&quot;*/</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    [webView evaluateJavaScript:@&quot;document.body.scrollHeight&quot; completionHandler:^(id h, NSError * _Nullable error) &#123;</span><br><span class="line">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            !strongSelf.getWebDocumentBodyScrollHeight?:strongSelf.getWebDocumentBodyScrollHeight([h floatValue]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA</a>?</p>]]></content>
    
    <summary type="html">
    
      为了方便快捷的开发app，开发过程中经常有WKWebView 实现iOS与js的交互
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 重签名</title>
    <link href="http://lbrjms.github.io/2019/07/05/iOS-%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    <id>http://lbrjms.github.io/2019/07/05/iOS-重签名/</id>
    <published>2019-07-05T02:07:28.000Z</published>
    <updated>2019-07-15T03:14:32.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="xcode-Profiles地址"><a href="#xcode-Profiles地址" class="headerlink" title="xcode Profiles地址"></a>xcode Profiles地址</h3><p> ~/Library/MobileDevice/Provisioning Profiles</p><h3 id="签名的基本流程"><a href="#签名的基本流程" class="headerlink" title="签名的基本流程"></a>签名的基本流程</h3><p>1、在Mac上生成一对公私钥，这里称公钥M，私钥M。</p><p>2、苹果自己有固定的一对公私钥，跟上面AppStore例子一样，私钥在苹果后台，公钥内置在每个iOS设备上，这里称为公钥A，私钥A。</p><p>3、把公钥M上传到苹果后台，用苹果后台里的私钥A去签名公钥M。得到一份数据包含了公钥M以及其签名（也就是公钥的HASH值），把这份数据称为证书。</p><p>4、在开发时，编译完一个App后，用本地的私钥M对这个App进行签名，同时把第三步得到的证书一起打包进App里，安装到手机。</p><p>5、在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证证书的数字签名是否正确。</p><p>验证证书确保公钥M是苹果认证过的，再用公钥M去验证App的签名，这里就间接验证了这个App的安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证App是否被改动，因为开发阶段App内容总是不断变化的，苹果不需要管）。</p><p><a href="https://www.jianshu.com/p/fc56a70ee4fb" target="_blank" rel="noopener">https://www.jianshu.com/p/fc56a70ee4fb</a></p><h3 id="plis文件的生成"><a href="#plis文件的生成" class="headerlink" title="plis文件的生成"></a>plis文件的生成</h3><ul><li><p>根据mobileprovision生成相关的plist<br><code>security cms -D -i 123.mobileprovision &gt; embedded.plist</code></p></li><li><p>根据plist 截取其中的Entitlements部分<br><code>/usr/libexec/PlistBuddy -x -c &#39;Print:Entitlements&#39;  embedded.plist &gt; entitlements.plist</code></p></li></ul><h3 id="签名脚本"><a href="#签名脚本" class="headerlink" title="签名脚本"></a>签名脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">if ! ([ -f &quot;$1&quot; ]); then</span><br><span class="line">echo ----- \&quot;$&#123;1&#125;\&quot;文件不存在</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">ipaName=$&#123;1%.ipa&#125;</span><br><span class="line">if [ &quot;$ipaName&quot; = &quot;$1&quot; ]; then</span><br><span class="line">echo ----- \&quot;$&#123;1&#125;\&quot;error 不是ipa文件</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">## step 1 解压ipa</span><br><span class="line">unzip $&#123;ipaName&#125;.ipa</span><br><span class="line"></span><br><span class="line">## step 2 删除旧签名文件</span><br><span class="line">rm -rf Payload/*.app/_CodeSignature/</span><br><span class="line"></span><br><span class="line">## step 3 拷贝证书配置和权限文件</span><br><span class="line">cp embedded.mobileprovision Payload/*.app/embedded.mobileprovision</span><br><span class="line">cp entitlements.plist Payload/*.app/</span><br><span class="line"></span><br><span class="line">## step 4 重签名</span><br><span class="line">(</span><br><span class="line">/usr/bin/codesign -f -s &quot;Iris Info-Tech(Shanghai) Co.,Ltd&quot; --entitlements Payload/*.app/entitlements.plist Payload/*.app/</span><br><span class="line">) || &#123;</span><br><span class="line">rm -rf Payload/</span><br><span class="line">rm -rf __MACOSX/</span><br><span class="line">exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## step 5 打包</span><br><span class="line">zip -r $&#123;ipaName&#125;_resign.ipa Payload/</span><br><span class="line">rm -rf Payload/</span><br><span class="line">rm -rf __MACOSX/</span><br></pre></td></tr></table></figure><h3 id="签名工具"><a href="#签名工具" class="headerlink" title="签名工具"></a>签名工具</h3><p>iReSign</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;xcode-Profiles地址&quot;&gt;&lt;a href=&quot;#xcode-Profiles地址&quot; class=&quot;headerlink&quot; title=&quot;xcode Profiles地址&quot;&gt;&lt;/a&gt;xcode Profiles地址&lt;/h3&gt;&lt;p&gt; ~/Library/Mob
      
    
    </summary>
    
    
      <category term="重签名" scheme="http://lbrjms.github.io/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods制作自己的Pod库</title>
    <link href="http://lbrjms.github.io/2019/06/12/Cocoapods%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84Pod%E5%BA%93/"/>
    <id>http://lbrjms.github.io/2019/06/12/Cocoapods制作自己的Pod库/</id>
    <published>2019-06-12T07:53:56.000Z</published>
    <updated>2019-06-12T08:53:11.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ul><li><p>GitHub上创建仓库 test</p></li><li><p>克隆仓库到本地</p></li><li><p>在仓库下面建项目（即你要开放的代码）</p></li><li><p>创建.podspec文件</p><p><code>pod spec create test</code></p></li><li><p>编辑.podspec文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         = &quot;WJDetailHeaderView&quot;</span><br><span class="line">  s.version      = &quot;1.0.1&quot;</span><br><span class="line">  s.summary      = &quot;标详情页的头部&quot;</span><br><span class="line">  # 这个必须得写否则会报错 并且要比summary长</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">  这是新建的标信息仓库</span><br><span class="line">                   DESC</span><br><span class="line">  s.homepage     = &quot;https://github.com/lbrjms/WJDetailHeaderView&quot;</span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line">  s.author             = &#123; &quot;lwj_code&quot; =&gt; &quot;wallien@163.com&quot; &#125;</span><br><span class="line">  s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/lbrjms/WJDetailHeaderView.git&quot;, :tag =&gt; s.version &#125;</span><br><span class="line">  s.source_files  = &quot;Classes&quot;, &quot;WJDetailHeaderView/WJDetailHeaderView/DetailHeaderView.swift&quot;</span><br><span class="line">  # 指定swift的版本 否则有警告</span><br><span class="line">  s.swift_version = &apos;3.2&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>项目打源码tag并上传git</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line">git commit -m &quot;this is 1.0.0&quot;</span><br><span class="line">git tag &apos;1.0.0&apos;</span><br><span class="line">git push --tags</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>验证podspec</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure><ul><li>注册pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register wallien@163.com &quot;lwj_code&quot;</span><br><span class="line"></span><br><span class="line">注册之后记得邮箱认证</span><br></pre></td></tr></table></figure><ul><li>发布pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push test.podspec</span><br></pre></td></tr></table></figure><p>到这里没问题就是成功了</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>xcrun: error: unable to find utility “simctl”, not a developer tool or in PATH ) during validation</p><p>到xcode的偏好设置里面设置command line tools： Xcode&gt;preferences&gt;Locations里面，设置之后再运行终端即可</p>]]></content>
    
    <summary type="html">
    
      做iOS开发 很多都会用cocoapods管理第三方开源库 有时候会会想自己也写一个 另外组件化开发更需我们制作自己的开源库
    
    </summary>
    
    
      <category term="Pod" scheme="http://lbrjms.github.io/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅打开都是xml的问题</title>
    <link href="http://lbrjms.github.io/2019/06/06/RSS%E8%AE%A2%E9%98%85%E6%89%93%E5%BC%80%E9%83%BD%E6%98%AFxml%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lbrjms.github.io/2019/06/06/RSS订阅打开都是xml的问题/</id>
    <published>2019-06-06T07:20:22.000Z</published>
    <updated>2019-06-12T07:59:46.283Z</updated>
    
    <content type="html"><![CDATA[<p>安装rss插件</p><p><code>npm install hexo-generator-feed</code></p><p>在这个各种信息混杂的时代，rss真的感觉是一股清流，我们可以通过这个功能订阅自己先看的文章，节目….</p><p>刚接触rss遇到最多的问题就是点击网站的rss订阅 显示的都是xml代码，这是由于没有安装RSS客户端 或是没有支持RSS的插件</p><p>如果是google浏览器可以安装feeder插件挺好用</p><p><a href="https://juejin.im/post/5c382a326fb9a049f15469eb" target="_blank" rel="noopener">https://juejin.im/post/5c382a326fb9a049f15469eb</a></p><p><a href="https://www.inoreader.com/" target="_blank" rel="noopener">https://www.inoreader.com/</a></p>]]></content>
    
    <summary type="html">
    
      看到好多网站都有RSS订阅的东西，最早不知道什么作用，后来发现确实很好 这里记录一下自己看到的关于rss的文章
    
    </summary>
    
    
      <category term="Hexo" scheme="http://lbrjms.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MD常用语法</title>
    <link href="http://lbrjms.github.io/2019/06/05/md%E8%AF%AD%E6%B3%95/"/>
    <id>http://lbrjms.github.io/2019/06/05/md语法/</id>
    <published>2019-06-05T08:26:20.000Z</published>
    <updated>2019-06-12T08:01:22.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md简单语法"><a href="#md简单语法" class="headerlink" title="md简单语法"></a>md简单语法</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><p>//形式一</p><ul><li>a</li><li>b</li><li>c</li></ul><p>//形式二</p><ul><li>d</li><li>e</li><li>f</li></ul><p>//形式三</p><ul><li>g</li><li>h</li><li>i</li></ul><h1 id="无序列表嵌套"><a href="#无序列表嵌套" class="headerlink" title="无序列表嵌套"></a>无序列表嵌套</h1><ul><li>123<ul><li>abc</li><li>bcd</li><li>cde</li></ul></li><li>465</li><li>789</li></ul><h1 id="有序列表嵌套"><a href="#有序列表嵌套" class="headerlink" title="有序列表嵌套"></a>有序列表嵌套</h1><ol><li>abcd<ol><li>abcde</li><li>abcde</li><li>abcde</li></ol></li><li>bcde</li><li>cdef</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p><blockquote><p>五级引用</p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p><code>NSOpenPanel* openDlg = [NSOpenPanel openPanel]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSOpenPanel* openDlg = [NSOpenPanel openPanel];</span><br><span class="line"></span><br><span class="line">[openDlg setCanChooseFiles:TRUE];</span><br><span class="line">[openDlg setCanChooseDirectories:FALSE];</span><br><span class="line">[openDlg setAllowsMultipleSelection:FALSE];</span><br><span class="line">[openDlg setAllowsOtherFileTypes:FALSE];</span><br><span class="line">[openDlg setAllowedFileTypes:@[@&quot;ipa&quot;, @&quot;IPA&quot;, @&quot;xcarchive&quot;]];</span><br><span class="line"></span><br><span class="line">if ([openDlg runModal] == NSOKButton)</span><br><span class="line">&#123;</span><br><span class="line">    NSString* fileNameOpened = [[[openDlg URLs] objectAtIndex:0] path];</span><br><span class="line">    [pathField setStringValue:fileNameOpened];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li>行内式<br>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来</li></ul><p><a href="https://www.jianshu.com" title="创作你的创作" target="_blank" rel="noopener">简书</a>,是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流</p><ul><li>参数式<br>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来</li></ul><p><a href="https://www.jianshu.com" title="创作你的创作" target="_blank" rel="noopener">简书</a>是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</p><p>//参数定义的其他写法</p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><h3 id="至少三个字符"><a href="#至少三个字符" class="headerlink" title="至少三个字符"></a>至少三个字符</h3><hr><hr><hr><hr><hr><hr><hr><hr><hr><h1 id="斜体-加粗-删除线"><a href="#斜体-加粗-删除线" class="headerlink" title="斜体 加粗 删除线"></a>斜体 加粗 删除线</h1><p><em>md</em><br><strong>md</strong></p><p><em>md</em><br><strong>md</strong></p><p><del>删除</del></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>//例子一</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>//例子二</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>//例子三</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      记录常用的md命令
    
    </summary>
    
      <category term="文章" scheme="http://lbrjms.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo + GitHubPages搭建个人博客</title>
    <link href="http://lbrjms.github.io/2019/06/05/GitHub-Pages-Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lbrjms.github.io/2019/06/05/GitHub-Pages-Hexo写博客/</id>
    <published>2019-06-05T07:11:20.000Z</published>
    <updated>2019-06-12T08:00:46.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><ul><li>创建一个github仓库 仓库名必须与用户名相同 之后的博客地址就是：<a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></li></ul><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p><em>Git可以通过https和ssh两种方式连接服务器上的仓库。ssh的方式会在传输前压缩数据，<br>这样传输的效率很高。而且不需要每次都输入账号和密码。</em></p><ul><li>git的用户名和邮箱设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name”</span><br><span class="line">$ git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><ul><li>查看本地是否有ssh密钥（有这些文件说明已经有了id_rsa，id_rsa.pubknown_hosts），<br>如果没有就自己生成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成ssh命令 根据提示一步步操作即可</span><br><span class="line">ssh-keygen -t rsa -C “your email”</span><br></pre></td></tr></table></figure><ul><li>vim打开公钥文件 复制共钥到github的设置里面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><h3 id="安装Hexo环境"><a href="#安装Hexo环境" class="headerlink" title="安装Hexo环境"></a>安装Hexo环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 安装hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 初始化一个blog文件夹</span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line">// 到blog文件夹下启动服务 之后就可以在http://localhost:4000 看的你的博客</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><ul><li>修改blog文件夹下的_config.yml文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">### :号后面都要有空格 否则hexo d的时候会没反应</span><br><span class="line">deploy:</span><br><span class="line">type:git</span><br><span class="line">repo:git@github.com:你的github账号/你的github账号.github.io.git</span><br><span class="line">branch:master</span><br></pre></td></tr></table></figure><ul><li>生成新的public文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   //删除旧的public文件</span><br><span class="line">hexo generate / hexo g   //生成新的public文件</span><br></pre></td></tr></table></figure><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploye / hexo d</span><br></pre></td></tr></table></figure><p><em>到此就初步完成了 在打开<a href="https://lbrjms.github.io就可以看到你的博客了" target="_blank" rel="noopener">https://lbrjms.github.io就可以看到你的博客了</a></em></p><h3 id="更换主题A"><a href="#更换主题A" class="headerlink" title="更换主题Â"></a>更换主题Â</h3><p><em>成功之后的第一件事就是更换主题 选择自己喜欢的主题 下载到themes文件夹下面<br>更改_config.yml 的themes 对应的名字就可以了</em></p><ul><li>下面是我clone的主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">$ npm install hexo-renderer-pug --save</span><br><span class="line">$ npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><ul><li>开启分类 tags</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p><code>$ hexo new &quot;title&quot;</code></p><h3 id="关于界面"><a href="#关于界面" class="headerlink" title="关于界面"></a>关于界面</h3><blockquote><p>maupassant主题里有个关于导航菜单，默认点进去是不行的，需要自己新建个。<br>在Hexo的 source 目录新建个 about 文件夹，文件夹里按模板新建个 index.md</p></blockquote><h3 id="更改主题语言"><a href="#更改主题语言" class="headerlink" title="更改主题语言"></a>更改主题语言</h3><p>支持多种语言 去config文件里面改就可以（我找了半天才找到）其实关于一些设置的东西 大多数都在config里面改</p>]]></content>
    
    <summary type="html">
    
      自己之前搭建过blog，当时是公司的电脑，另外当时也是稀里糊涂搞出来了，后来换了公司把原文件都搞丢了，后来就忘记怎么弄了，这次又重新来了一遍，并做了笔记，记性再好不如写下来 实在。
    
    </summary>
    
      <category term="文章" scheme="http://lbrjms.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hexo" scheme="http://lbrjms.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lbrjms.github.io/2019/06/05/hello-world/"/>
    <id>http://lbrjms.github.io/2019/06/05/hello-world/</id>
    <published>2019-06-05T01:40:28.316Z</published>
    <updated>2019-06-05T01:40:28.317Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unity gameobject 的 生命周期</title>
    <link href="http://lbrjms.github.io/2018/08/08/Unity%20gameobject%20%E7%9A%84%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://lbrjms.github.io/2018/08/08/Unity gameobject 的 生命周期/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-06-12T09:03:40.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Unity3d-基础学习"><a href="#Unity3d-基础学习" class="headerlink" title="Unity3d 基础学习"></a>Unity3d 基础学习</h3><a id="more"></a><h4 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h4><ul><li><p>Awake</p><p>脚本被载入是调用</p></li><li><p>OnEnable</p><p>对象变为可用或激活状态时调用</p></li><li><p>Start</p><p>只调用一次</p></li><li><p>FixedUpdate</p><p>固定的时间间隔被调用 不受设备的帧率等的影响</p></li><li><p>Update</p><p>更新</p></li><li><p>LateUpdate</p><p>Update之后更新</p></li><li><p>OnGUI</p><p>渲染和处理GUI事件</p></li><li><p>OnDisable</p><p>当前对象不可用或处于非激活状态 脚本或对象被销毁的时候调用</p></li><li><p>OnDestroy</p><p>当物体 或是 脚本 被销毁</p></li></ul><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li><p>gameObt.GetComponent&lt; compomentName &gt; ();</p><p>获取到对应的compoment</p></li><li><p>GetComponent<rigidbody> ().AddForce (vec3);</rigidbody></p><p>给刚体添加力</p></li></ul><!--more-->]]></content>
    
    <summary type="html">
    
      Unity3d 基础学习
    
    </summary>
    
    
      <category term="iOS" scheme="http://lbrjms.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>全局Pop 隐藏TabBar NavigationBar</title>
    <link href="http://lbrjms.github.io/2018/08/08/%E5%85%A8%E5%B1%80Pop%20%E9%9A%90%E8%97%8FTabBar%20NavigationBar/"/>
    <id>http://lbrjms.github.io/2018/08/08/全局Pop 隐藏TabBar NavigationBar/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-06-12T09:03:21.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局Pop-侧边缘滑动的拓展"><a href="#全局Pop-侧边缘滑动的拓展" class="headerlink" title="全局Pop(侧边缘滑动的拓展)"></a>全局Pop(侧边缘滑动的拓展)</h3><a id="more"></a><h4 id="思路-给系统的侧边缘滑动runtime添加target-action"><a href="#思路-给系统的侧边缘滑动runtime添加target-action" class="headerlink" title="思路:给系统的侧边缘滑动runtime添加target action"></a>思路:给系统的侧边缘滑动runtime添加target action</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取系统的Pop手势</span></span><br><span class="line">    <span class="keyword">let</span> systemGes = interactivePopGestureRecognizer</span><br><span class="line">    <span class="comment">// 2. 获取手势的view用于添加新的手势</span></span><br><span class="line">    <span class="keyword">let</span> gesView = systemGes?.view</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取target/action</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 利用运行时机制获取所有的属性名称</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> : <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ivars = class_copyIvarList(<span class="type">UIGestureRecognizer</span>.<span class="keyword">self</span>, &amp;<span class="built_in">count</span>)!</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ivar = ivars[<span class="type">Int</span>(i)]</span><br><span class="line">        <span class="keyword">let</span> name = ivar_getName(ivar)!</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(cString : name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> targets = systemGes?.value(forKey: <span class="string">"_targets"</span>) <span class="keyword">as</span>? [<span class="type">NSObject</span>]</span><br><span class="line">    <span class="keyword">let</span> targetObjc = targets?.first</span><br><span class="line">    <span class="comment">// 3.2 取出target</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> target = targetObjc?.value(forKey: <span class="string">"target"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">// 3.3 取出action</span></span><br><span class="line">    <span class="keyword">let</span> action = <span class="type">Selector</span>((<span class="string">"handleNavigationTransition:"</span>))</span><br><span class="line">    <span class="comment">// 4. 创建自己的Pan手势</span></span><br><span class="line">    <span class="keyword">let</span> panGes = <span class="type">UIPanGestureRecognizer</span>()</span><br><span class="line">    gesView?.addGestureRecognizer(panGes)</span><br><span class="line">    panGes.addTarget(target, action: action)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐藏tabBar"><a href="#隐藏tabBar" class="headerlink" title="隐藏tabBar"></a>隐藏tabBar</h4><pre><code>import UIKitclass CustomNavigationController: UINavigationController { override func viewDidLoad() {    super.viewDidLoad() } override func pushViewController(_ viewController: UIViewController, animated: Bool) {     viewController.hidesBottomBarWhenPushed = true     super.pushViewController(viewController, animated: animated) }}</code></pre><h4 id="隐藏NavigationBar"><a href="#隐藏NavigationBar" class="headerlink" title="隐藏NavigationBar"></a>隐藏NavigationBar</h4><pre><code>class ViewController: UIViewController,UIGestureRecognizerDelegate {override func viewWillAppear(_ animated: Bool) {super.viewWillAppear(animated)navigationController?.setNavigationBarHidden(true, animated: true)navigationController?.interactivePopGestureRecognizer?.delegate = selfnavigationController?.interactivePopGestureRecognizer?.isEnabled = true}override func viewWillDisappear(_ animated: Bool) {super.viewWillDisappear(animated)navigationController?.setNavigationBarHidden(false, animated: true)}override func viewDidLoad() {super.viewDidLoad()}}</code></pre>]]></content>
    
    <summary type="html">
    
      全局Pop(侧边缘滑动的拓展)
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift基础之可选型</title>
    <link href="http://lbrjms.github.io/2018/07/30/swift%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%AF%E9%80%89%E5%9E%8B/"/>
    <id>http://lbrjms.github.io/2018/07/30/swift基础之可选型/</id>
    <published>2018-07-30T10:01:19.000Z</published>
    <updated>2019-07-30T11:05:18.224Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 可选型</span><br><span class="line"> * 主要用来表示 没有 这个概念</span><br><span class="line"> * 必须显示表达</span><br><span class="line"> * 正常会作为var 变量来存在</span><br><span class="line"> * 不能被直接使用 因为它有可能是空 会报错</span><br><span class="line"> * 被解包才能用</span><br><span class="line"> * ! 强制解包</span><br><span class="line"> * if let 解包</span><br><span class="line"> * ??</span><br><span class="line"> * 三目运算符 ? :</span><br><span class="line"> * 隐式可选型</span><br><span class="line"> * var errorCode3: Int!</span><br><span class="line"> * errorCode3 = nil</span><br><span class="line"> */</span><br><span class="line">// 这不仅仅是整形 还是一个可选性</span><br><span class="line">var errorCode: Int? = 404</span><br><span class="line">errorCode = 0</span><br><span class="line">// 只有可选性才能被赋值为nil</span><br><span class="line">errorCode = nil</span><br><span class="line">print(errorCode)</span><br><span class="line">var errorCode2: String? = &quot;404&quot;</span><br><span class="line">errorCode2 = &quot;400&quot;</span><br><span class="line">&quot;The errorCode is &quot; + (errorCode2 ?? &quot;ss&quot;)</span><br><span class="line">errorCode2?.localizedUppercase</span><br><span class="line">if let safeCode = errorCode2 &#123;</span><br><span class="line">    // if let 的作用就是解包 判断空 解包成功 也就是不为空才会进来</span><br><span class="line">    &quot;safe&quot; + safeCode</span><br><span class="line">&#125;</span><br><span class="line">let ageIntput: String = &quot;23&quot;</span><br><span class="line">let age = Int(ageIntput) ?? 0</span><br><span class="line">print(age)</span><br><span class="line">let greetString = &quot;Hello&quot;</span><br><span class="line">greetString.range(of: &quot;o&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
