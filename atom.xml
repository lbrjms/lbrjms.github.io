<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>青萍水袖</title>
  
  <subtitle>做一些简单的事情 把有用的东西写下来 总有一天你能用的到</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lbrjms.github.io/"/>
  <updated>2019-08-10T15:20:03.053Z</updated>
  <id>http://lbrjms.github.io/</id>
  
  <author>
    <name>WJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS开发的内存|循环引用问题</title>
    <link href="http://lbrjms.github.io/2019/08/08/iOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://lbrjms.github.io/2019/08/08/iOS开发的内存-循环引用问题/</id>
    <published>2019-08-08T13:19:23.000Z</published>
    <updated>2019-08-10T15:20:03.053Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>我们知道oc存储主要分成数据区、堆区和栈区，</em></strong></p><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>B控制器中有block属性 A跳转B 并且在A中实现B的block 并调用了self属性</p><p>如果A持有了B那么此时就造成循环引用</p><p>因为A持有了B 并且B的block中持有了self（A）这样就无法执行dealloc 方法造成循环引用（self是一个指向实例对象的指针，它的生命周期至少是伴随着当前的实例对象的）</p><p>有时候B中的block会在B之后销毁 那么就需要用__strong修饰weakSelf 虽然此时也是强引用 但是strongSelf只是局部变量 他的作用域仅限于局部代码，而程序一旦跳出作用域，strongSelf就会被释放，这个临时产生的“循环引用”就会被自动打破 接下来self就会被销毁</p><h3 id="weak关键字"><a href="#weak关键字" class="headerlink" title="weak关键字"></a>weak关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">case OPERATION_retain:</span><br><span class="line">    CFBasicHashAddValue( table, obj );</span><br><span class="line">    return obj;</span><br><span class="line">case OPERATION_retainCount:</span><br><span class="line">    count = CFBasicHashGetCountOfKey( table, obj );</span><br><span class="line">    return count;</span><br><span class="line">case OPERATION_release:</span><br><span class="line">    count = CFBasicHashRemoveValue( table, obj );</span><br><span class="line">    return 0 == count;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wzzvictory/article/details/17694129" target="_blank" rel="noopener">Objective-C高级编程：iOS与OS X多线程和内存管理</a></p><h3 id="局部变量的销毁时机"><a href="#局部变量的销毁时机" class="headerlink" title="局部变量的销毁时机"></a>局部变量的销毁时机</h3><p>在 ARC下，方法会自动调用 -autorelease 方法。<br>调用后，该变量会被添加到自动释放池。<br>在主线程中，临时变量会在 runloop 运行结束时释放。<br>在非主线程中，临时变量会在 线程退出时释放。<br>所以，当有大量的临时对象时，官方建议我们使用 @autoreleasepool 进行内存管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">for (NSInteger i = 0;i &lt; 50000; i++) &#123;</span><br><span class="line"></span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        NSString *fileContents = @&quot;test&quot;;</span><br><span class="line">        NSLog(@&quot;%@&quot;,fileContents);</span><br><span class="line">        /* Process the string, creating and autoreleasing more objects. */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">__NSCFString, 0x600002b690b0</span><br><span class="line">2019-08-09 12:00:58.910312+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695efbf4===1</span><br><span class="line">2019-08-09 12:00:58.910380+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695debf7===11</span><br><span class="line">2019-08-09 12:00:58.910443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb86a4debf6===111</span><br><span class="line">2019-08-09 12:00:58.910529+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebbb7a4debf1===1111</span><br><span class="line">2019-08-09 12:00:58.910611+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1e8ab7a4debf0===11111</span><br><span class="line">2019-08-09 12:00:58.910698+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b2f8ab7a4debf3===111111</span><br><span class="line">2019-08-09 12:00:58.910832+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbaa2f8ab7a4debf2===1111111</span><br><span class="line">2019-08-09 12:00:58.914443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b675c18ec0810d===11111111</span><br><span class="line">2019-08-09 12:00:58.914550+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb85675c18ec0810c===111111111</span><br><span class="line">2019-08-09 12:00:58.914625+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb98c04c3b7a9450f===1111111111</span><br><span class="line">2019-08-09 12:00:58.914713+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbe0c04c3b7a9450e===11111111111</span><br><span class="line">2019-08-09 12:00:58.914783+0800 TTTTTT[15263:1321694] __NSCFString, 0x600002525220===111111111111</span><br></pre></td></tr></table></figure><h3 id="栈对象和堆对象"><a href="#栈对象和堆对象" class="headerlink" title="栈对象和堆对象"></a>栈对象和堆对象</h3><p>在栈上创建对象是非常快的，因为很多东西在编译时就确定了，运行时分配空间几乎不耗时；相对而言在堆上创建对象就非常耗时。栈对象的生命周期是确定的，对象出栈以后就会被释放，不会存在内存泄漏，但这同时也是栈对象的最大缺点。Objective-C 变量有效范围是由 “{}” 包含的块来决定的，也就是说栈对象的生命周期仅限于其所在的块里，出了块立马会被释放。一个对象被创建以后有可能会通过方法调用传递到别的方法，当栈对象的创建方法返回时，栈对象会被一起 pop 出栈而释放，导致其没法在别处被继续持有。此时 retain 操作会失效，除非用 copy 方法在想持有该栈对象的地方重新拷贝一份属于自己的栈对象(block).</p><h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><ul><li>我们也可以在WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate</li><li>Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。</li><li>在内存读取上有着3倍的效率，创建时比以前快106倍。由此可见，苹果引入Tagged Pointer<br>，不但减少了64位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。</li></ul><ul><li><p>浪费内存<br>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。<br>所以一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍</p></li><li><p>效率问题<br>为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。</p></li><li><p>问题<br>Tagged Pointer的引入也带来了问题，即Tagged Pointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。所有对象都有 isa指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以不能访问isa</p></li></ul><p><em>为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。</em><br><a href="https://www.jianshu.com/p/c9089494fb6c" target="_blank" rel="noopener">参考</a><br><a href="http://www.cocoachina.com/articles/13449" target="_blank" rel="noopener">Tagged Pointer字符串</a><br><a href="http://www.nscookies.com/tagged-pointer/" target="_blank" rel="noopener">Tagged Pointer</a><br><a href="http://www.nscookies.com/literal/" target="_blank" rel="noopener">字面量(Literal)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;我们知道oc存储主要分成数据区、堆区和栈区，&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;循环引用&quot;&gt;&lt;a href=&quot;#循环引用&quot; class=&quot;headerlink&quot; title=&quot;循环引用&quot;&gt;&lt;/a&gt;循环引用&lt;/h3&gt;&lt;p&gt;B控制器中有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift开发之算法</title>
    <link href="http://lbrjms.github.io/2019/08/05/swift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://lbrjms.github.io/2019/08/05/swift开发之算法/</id>
    <published>2019-08-05T10:58:49.000Z</published>
    <updated>2019-08-06T11:35:27.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sort(_ list: inout [Int],_ n: Int) &#123;</span><br><span class="line"></span><br><span class="line">   if n&lt;=1 &#123;return&#125;</span><br><span class="line">   for i in 0..&lt;n &#123;</span><br><span class="line">       for j in 0..&lt;n-i-1 &#123;</span><br><span class="line">           if list[i] &gt; list[j+1] &#123;</span><br><span class="line">               list.swapAt(j, j+1)</span><br><span class="line">               print(j)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">///</span><br><span class="line">class InsertSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line"></span><br><span class="line">        var j = 0</span><br><span class="line">        // 每次取出后面未排序的数组的第一个值 与前面有序数组的进行比较 插入到相应的位置</span><br><span class="line">        for i in 1 ..&lt; list.count &#123;</span><br><span class="line">            j = i</span><br><span class="line">            while j &gt; 0 &#123;</span><br><span class="line">                if list[j] &lt; list[j-1] &#123;</span><br><span class="line">                    list.swapAt(j-1, i)</span><br><span class="line">                    j = j - 1</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 选择排序</span><br><span class="line">    // 时间复杂度永远是n*n</span><br><span class="line">    func chooseSort(_ list: inout [Int], _ n: Int)  &#123;</span><br><span class="line">        // 数组长度大于一才排序</span><br><span class="line">        if n &lt;= 1 &#123; return &#125;</span><br><span class="line">        var min = 0</span><br><span class="line">        var index = 0</span><br><span class="line">//        为false，断言被触发，终止应用。</span><br><span class="line">//        当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：</span><br><span class="line">//</span><br><span class="line">//        整数类型的下标索引被传入一个自定义小标实现，但是下标索引值可能太小或者太大</span><br><span class="line">//        需要给函数传入一个值，但是非法的值可能导致函数不能正常执行</span><br><span class="line">//        一个可选值现在是nil，但是后面的代码运行需要一个非nil值</span><br><span class="line"></span><br><span class="line">        assert(index != -1, &quot;A person&apos;s age cannot be less than zero&quot;)</span><br><span class="line"></span><br><span class="line">        for i in  0 ..&lt; n &#123;</span><br><span class="line">            min = list[i]</span><br><span class="line">            index = i</span><br><span class="line">            for j in i ..&lt; n &#123;</span><br><span class="line">                // 每次找到未排序数字的最小值</span><br><span class="line">                if list[j] &lt; min &#123;</span><br><span class="line">                    // 如果找到一个比min小的值 就赋值给min 并且记录这个值的索引 直到这层循环结束 找到的就是最小的</span><br><span class="line">                    min = list[j]</span><br><span class="line">                    index = j</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 找到最小值之后放在前面（已经排序数组的最后面）</span><br><span class="line">            list.swapAt(i, index)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>希尔排序（把数组通过步长（step）分成 n/step个小数组数组，再分别对这些小数组进行插入排序，直到步长等于0结束）</li><li>[2,35,56,767,989,0,45,345]</li><li>[0,4][1,5],[2,6],[3,7]</li><li>[0,2,4,6][1,3,5,7]</li><li>[0,1,2,3,4,5,6,7]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class ShellSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var step = list.count / 2</span><br><span class="line">        var j = 0</span><br><span class="line"></span><br><span class="line">        // 步长等于0结束</span><br><span class="line">        while step &gt; 0 &#123;</span><br><span class="line">            for i in step ..&lt; list.count &#123;</span><br><span class="line">                j = i</span><br><span class="line">                while j &gt;= step &#123;</span><br><span class="line">                    if list[j] &lt; list[j-step] &#123;</span><br><span class="line">                        list.swapAt(j-step, j)</span><br><span class="line">                        j = j - step</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环</span><br><span class="line">                        break</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step = step / 2 //缩小步长</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><ul><li>分而治之的思想 先把整体分割成n个只有一个数据数组 这时候是有序的</li><li>将这些有序的数组两两结合成有序数组</li><li>重复上面的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class MergeSort: SortType &#123;</span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line"></span><br><span class="line">        // 拆分一个数组 为n个有序数组 放在一个大数组里面</span><br><span class="line">        var totalArr: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">        for item in list &#123;</span><br><span class="line">            var subArray: Array&lt;Int&gt; = []</span><br><span class="line">            subArray.append(item)</span><br><span class="line">            totalArr.append(subArray)</span><br><span class="line">        &#125;</span><br><span class="line">        // 重复拆分工作 直到就剩一个数组</span><br><span class="line">        while totalArr.count != 1 &#123;</span><br><span class="line">            // 每次走完一遍 重新从0开始</span><br><span class="line">            var i = 0</span><br><span class="line">            while i &lt; totalArr.count - 1 &#123;</span><br><span class="line">                // 两两合并</span><br><span class="line">                totalArr[i] = mergeArray(firstList: totalArr[i], secondList: totalArr[i+1])</span><br><span class="line">                totalArr.remove(at: i + 1)</span><br><span class="line">                i = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return totalArr[0]</span><br><span class="line">    &#125;</span><br><span class="line">    // 合并两个有序数组</span><br><span class="line">    func mergeArray(firstList: Array&lt;Int&gt;, secondList: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var resultList: Array&lt;Int&gt; = []</span><br><span class="line">        var firstIndex = 0</span><br><span class="line">        var secondIndex = 0</span><br><span class="line"></span><br><span class="line">        while firstIndex &lt; firstList.count &amp;&amp; secondIndex &lt; secondList.count &#123;</span><br><span class="line">            if firstList[firstIndex] &lt; secondList[secondIndex] &#123;</span><br><span class="line">                resultList.append(firstList[firstIndex])</span><br><span class="line">                firstIndex = firstIndex + 1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                resultList.append(secondList[secondIndex])</span><br><span class="line">                secondIndex = secondIndex + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果其中一个数组还有数据没有放进结果数组里面 就把剩下的放进去</span><br><span class="line">        while firstIndex &lt; firstList.count &#123;</span><br><span class="line">            resultList.append(firstList[firstIndex])</span><br><span class="line">            firstIndex = firstIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line">        while secondIndex &lt; secondList.count &#123;</span><br><span class="line">            resultList.append(secondList[secondIndex])</span><br><span class="line">            secondIndex = secondIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line">        return resultList</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//  分而治之的思想</span><br><span class="line"> func quickSort(_ array: [Int]) -&gt; [Int] &#123;</span><br><span class="line">     guard array.count &gt; 1 else &#123;</span><br><span class="line">         return array</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     let pivot = array[array.count/2]</span><br><span class="line">     let left = array.filter&#123; $0 &lt; pivot &#125;</span><br><span class="line">     let middle = array.filter&#123; $0 == pivot &#125;</span><br><span class="line">     let right = array.filter&#123; $0 &gt; pivot &#125;</span><br><span class="line"></span><br><span class="line">     return quickSort(left) + middle + quickSort(right)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">// 降低空间复杂度的快排</span><br><span class="line"> func quickSortPro(_ array: inout [Int], _ n: Int) &#123;</span><br><span class="line">        quickSortC(&amp;array, 0, n-1)</span><br><span class="line">    &#125;</span><br><span class="line">    func quickSortC(_ array: inout [Int], _ left: Int, _ right: Int) &#123;</span><br><span class="line">        if left &gt; right &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        let pivot = partition(&amp;array, left, right)</span><br><span class="line">        quickSortC(&amp;array, left, pivot - 1)</span><br><span class="line">        quickSortC(&amp;array, pivot + 1, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func partition(_ array: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123;</span><br><span class="line">        let pivot = array[right]</span><br><span class="line">        var i = left</span><br><span class="line">        for j in left ..&lt; right &#123;</span><br><span class="line">            if array[j] &lt; pivot &#123;</span><br><span class="line">                array.swapAt(j, i)</span><br><span class="line">                i = i + 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        array.swapAt(i, right)</span><br><span class="line">        return i</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class BucketSort: SortType &#123;</span><br><span class="line">//    inout修饰的参数是不能有默认值的，有范围的参数集合也不能被修饰；</span><br><span class="line">//    一个参数一旦被inout修饰，就不能再被var和let修饰了。</span><br><span class="line">//    1.监测属性,其实是给存储属性上添加的一种监测功能,willSet 监测新值,didSet 监测旧值</span><br><span class="line">//    2.如果函数的参数是inout 修饰的,你如果将监测的属性传入这个函数的时候,此时会将属性的值拷贝一份,在函数结束的时候,将值重新付给属性,所以函数执行完毕后,会触发监测函数</span><br><span class="line"></span><br><span class="line">    func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123;</span><br><span class="line">        var bucket = createBucket()</span><br><span class="line">        let maxNumber = listMaxItem(arr: list)</span><br><span class="line">        let maxLeagth = numberLength(number: maxNumber)</span><br><span class="line"></span><br><span class="line">        for digit in 1 ... maxLeagth &#123;</span><br><span class="line">            // 入桶操作</span><br><span class="line">            for item in list &#123;</span><br><span class="line">                let baseNum = fetchBaseNumber(number: item, digit: digit)</span><br><span class="line">                // 根据基数放入对应的桶中</span><br><span class="line">                bucket[baseNum].append(item)</span><br><span class="line">            &#125;</span><br><span class="line">            var index = 0</span><br><span class="line">            // 出桶</span><br><span class="line">            for i in 0..&lt;bucket.count &#123;</span><br><span class="line">                while !bucket[i].isEmpty &#123;</span><br><span class="line">                    list[index] = bucket[i].remove(at: 0)</span><br><span class="line">                    index = index + 1</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 创建十个桶</span><br><span class="line">    ///</span><br><span class="line">    /// - Returns: 放着十个桶的数组</span><br><span class="line">    func createBucket() -&gt; Array&lt;Array&lt;Int&gt;&gt;&#123;</span><br><span class="line"></span><br><span class="line">        var buckets: Array&lt;Array&lt;Int&gt;&gt; = []</span><br><span class="line">        for _ in 0 ..&lt; 10 &#123;</span><br><span class="line">            buckets.append([])</span><br><span class="line">        &#125;</span><br><span class="line">        return buckets</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 取到最大值</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter arr: 数组</span><br><span class="line">    /// - Returns: 最大值</span><br><span class="line">    func listMaxItem(arr : Array&lt;Int&gt;) -&gt; Int &#123;</span><br><span class="line">        var max = arr[0]</span><br><span class="line">        for item in arr &#123;</span><br><span class="line">            if max &lt; item &#123;</span><br><span class="line">                max = item</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 返回最大数字的长度</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameter number: 最大值</span><br><span class="line">    /// - Returns: 长度</span><br><span class="line">    func numberLength(number: Int) -&gt; Int &#123;</span><br><span class="line">        return &quot;\(number)&quot;.count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 获取相应位上的数字</span><br><span class="line">    ///</span><br><span class="line">    /// - Parameters:</span><br><span class="line">    ///   - number: 操作的数字</span><br><span class="line">    ///   - digit: 位数</span><br><span class="line">    /// - Returns: 返回该位上的数字</span><br><span class="line">    func fetchBaseNumber(number: Int, digit: Int) -&gt; Int &#123;</span><br><span class="line"></span><br><span class="line">        if digit &gt; 0 &amp;&amp; digit &lt;= numberLength(number: number)&#123;</span><br><span class="line">            var numArr: Array&lt;Int&gt; = []</span><br><span class="line">            for char in &quot;\(number)&quot; &#123;</span><br><span class="line">                numArr.append(Int(&quot;\(char)&quot;)!)</span><br><span class="line">            &#125;</span><br><span class="line">            return numArr[numArr.count - digit]</span><br><span class="line">        &#125;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典之作-二分法"><a href="#经典之作-二分法" class="headerlink" title="经典之作 二分法"></a>经典之作 二分法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">/// while循环实现</span><br><span class="line">// Comparable协议继承于Equatable，实现Comparable协议可以在Equatable的基础上使类型支持&gt;，&gt;=，&lt;，&lt;=四种运算符</span><br><span class="line">extension Array where Element: Comparable &#123;</span><br><span class="line"></span><br><span class="line">    public var isSorted: Bool&#123;</span><br><span class="line">        var previousIndex = startIndex</span><br><span class="line">        var currentIndex = previousIndex + 1</span><br><span class="line"></span><br><span class="line">        while currentIndex != endIndex &#123;</span><br><span class="line">            if self[previousIndex] &gt; self[currentIndex]&#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            previousIndex = currentIndex</span><br><span class="line">            currentIndex = currentIndex + 1</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func binarySearch&lt;T: Comparable&gt;(sortedElements: [T], for element: T) -&gt; Bool &#123;</span><br><span class="line"></span><br><span class="line">        assert(sortedElements.isSorted)</span><br><span class="line"></span><br><span class="line">        var m = 0, n = sortedElements.count - 1</span><br><span class="line">        // 二分法</span><br><span class="line">        while m &lt; n &#123;</span><br><span class="line">            let mid = (n-m)/2 + m</span><br><span class="line"></span><br><span class="line">            if sortedElements[mid] == element &#123;</span><br><span class="line">                return true</span><br><span class="line">            &#125; else if sortedElements[mid] &lt; element &#123;</span><br><span class="line">                m = mid + 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                n = mid - 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归实现 二分法</span><br><span class="line">    var sortedElements2 = [1,2,3,4,23,24,56,78]</span><br><span class="line">    var element = 56</span><br><span class="line">    func digui(_ m: Int, _ n: Int) -&gt;Int &#123;</span><br><span class="line"></span><br><span class="line">        let mid = (n-m)/2 + m</span><br><span class="line">        var mm = m</span><br><span class="line">        var nn = n</span><br><span class="line"></span><br><span class="line">        if mm&gt;nn &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if sortedElements2[mid] == element &#123;</span><br><span class="line"></span><br><span class="line">            return mid;</span><br><span class="line">        &#125; else if sortedElements2[mid] &lt; element &#123;</span><br><span class="line">            mm = mid + 1</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            nn = mid - 1</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return digui(mm, nn)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="递归实现1到n的和"><a href="#递归实现1到n的和" class="headerlink" title="递归实现1到n的和"></a>递归实现1到n的和</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func sum(n: Int) -&gt; Int &#123;</span><br><span class="line">     if n == 0 &#123;</span><br><span class="line">         print(&quot;000000&quot;)</span><br><span class="line">         return 0</span><br><span class="line">     &#125;else if n == 1 &#123;</span><br><span class="line">         print(&quot;111111111&quot;)</span><br><span class="line">         return 1</span><br><span class="line">     &#125;else &#123;</span><br><span class="line">         print(&quot;\(n)&quot;)</span><br><span class="line">         return (sum(n:(n-1)) + n)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="不借用第三方变量实现交换两个变量"><a href="#不借用第三方变量实现交换两个变量" class="headerlink" title="不借用第三方变量实现交换两个变量"></a>不借用第三方变量实现交换两个变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br><span class="line"></span><br><span class="line">///////////// 按位异或</span><br><span class="line"></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure><h3 id="找出数组中的两个数据值和等于-一个确定的值"><a href="#找出数组中的两个数据值和等于-一个确定的值" class="headerlink" title="找出数组中的两个数据值和等于 一个确定的值"></a>找出数组中的两个数据值和等于 一个确定的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">func choseTwo(numsArr: [Int], targetValue: Int) -&gt; [Int] &#123;</span><br><span class="line">   var dic = [Int: Int]()</span><br><span class="line">   for (i,num) in numsArr.enumerated() &#123;</span><br><span class="line">       if let index = dic[targetValue - num] &#123;</span><br><span class="line">           return [index, i]</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           // 值为键 索引为值 储存数据</span><br><span class="line">           dic[num] = i</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 ：<a href="https://www.cnblogs.com/ludashi/p/6065086.html" target="_blank" rel="noopener">https://www.cnblogs.com/ludashi/p/6065086.html</a><br>      <a href="http://developer.51cto.com/art/201403/430986.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201403/430986.htm</a><br>      <a href="https://www.cnblogs.com/jingmoxukong/p/4303826.html" target="_blank" rel="noopener">https://www.cnblogs.com/jingmoxukong/p/4303826.html</a><br>      <a href="https://www.jianshu.com/p/77ba54a46ad7" target="_blank" rel="noopener">https://www.jianshu.com/p/77ba54a46ad7</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift开发之可POP</title>
    <link href="http://lbrjms.github.io/2019/08/03/swift%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8F%AFPOP/"/>
    <id>http://lbrjms.github.io/2019/08/03/swift开发之可POP/</id>
    <published>2019-08-03T02:55:52.000Z</published>
    <updated>2019-08-03T03:21:21.735Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OOP的优点"><a href="#OOP的优点" class="headerlink" title="OOP的优点"></a><font color="red">OOP的优点</font></h3><ul><li><font color="blue">封装与权限控制  </font></li></ul><p><em>.h声明公用的变量方法，.m声明私有变量和方法 public/internal/fileprivate/private</em></p><ul><li><font color="blue">命名空间</font></li></ul><p><em>OC没有命名空间，swift有命名空间</em></p><ul><li><font color="blue">扩展性</font></li></ul><p><em>extension category 另外通过代理实现更加灵活的扩展</em></p><ul><li><font color="blue">继承多态</font></li></ul><p><em>公用的方法变量写在父类中，继承的子类根据需求实现对应的功能</em>  </p><h3 id="OOP的缺点"><a href="#OOP的缺点" class="headerlink" title="OOP的缺点"></a><font color="red">OOP的缺点</font></h3><ul><li>隐式共享</li></ul><p>class是引用类型，当在代码中的改变了实例变量的时候，另一处调用此变量收到修改的影响</p><ul><li>冗杂的父类</li></ul><p>代码的迭代，父类越来越冗杂，职权不明确、依赖严重</p><ul><li>多继承</li></ul><h3 id="POP的优点"><a href="#POP的优点" class="headerlink" title="POP的优点"></a><font color="red">POP的优点</font></h3><ul><li>更加灵活</li></ul><p>不再有冗杂的父类，通过不同的协议实现</p>]]></content>
    
    <summary type="html">
    
      2015年WWDC苹果第一次提出了POP，POP成为的swift的灵魂，更加抽象、灵活
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift for循环</title>
    <link href="http://lbrjms.github.io/2019/07/25/swift-for%E5%BE%AA%E7%8E%AF/"/>
    <id>http://lbrjms.github.io/2019/07/25/swift-for循环/</id>
    <published>2019-07-25T13:29:43.000Z</published>
    <updated>2019-07-28T13:24:17.015Z</updated>
    
    <content type="html"><![CDATA[<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// &lt;font color=&quot;red&quot;&gt;闭区间&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">       let arr = [1, 32, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">       for i in 1...3 &#123;</span><br><span class="line">           i</span><br><span class="line">       &#125;</span><br><span class="line">       // 前闭后开</span><br><span class="line">       for j in 1..&lt;3 &#123;</span><br><span class="line">           j</span><br><span class="line">       &#125;</span><br><span class="line">       // 返回元组</span><br><span class="line">       for (i, value) in arr.enumerated() &#123;</span><br><span class="line">           i</span><br><span class="line">           value</span><br><span class="line">       &#125;</span><br><span class="line">       // 跳步循环</span><br><span class="line">       for i in stride(from: -5, to: 5, by: 0.1) &#123;</span><br><span class="line">           sin(i)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 反向循环</span><br><span class="line">       for p in arr.reversed() &#123;</span><br><span class="line">           p</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><font color="red">闭区间</font></p>]]></content>
    
    <summary type="html">
    
      swift3.0之后废弃了传统的for循环
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS更换项目名</title>
    <link href="http://lbrjms.github.io/2019/07/19/iOS%E6%9B%B4%E6%8D%A2%E9%A1%B9%E7%9B%AE%E5%90%8D/"/>
    <id>http://lbrjms.github.io/2019/07/19/iOS更换项目名/</id>
    <published>2019-07-19T09:42:14.000Z</published>
    <updated>2019-07-19T10:22:46.806Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># encoding: UTF-8</span><br><span class="line">#!/usr/bin/ruby</span><br><span class="line">require &apos;fileutils&apos;</span><br><span class="line">require &apos;active_support/all&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OLD_PREFIX = &quot;SetNickNameVC&quot;</span><br><span class="line">NEW_PREFIX = &quot;LHGJResetPswVC&quot;</span><br><span class="line"></span><br><span class="line">FOLDER_EXCLUDE = [&quot;Pods&quot;, &quot;.framework&quot;]</span><br><span class="line">CONTENT_EXCLUDE = [&quot;.xcuserstate&quot;, &quot;.a&quot;, &quot;.mp3&quot;, &quot;.avi&quot;, &quot;.mp4&quot;, &quot;.wmv&quot;, &quot;.webp&quot;, &quot;.png&quot;, &quot;.jpg&quot;, &quot;.rb&quot;]</span><br><span class="line"></span><br><span class="line"># REGEXP = &quot;([^a-zA-Z_0-9]|^)#&#123;OLD_PREFIX&#125;([A-Z].*?)&quot;</span><br><span class="line">REGEXP = &quot;#&#123;OLD_PREFIX&#125;(.*?)&quot;</span><br><span class="line">NEW_STRING = &apos;\1&apos;+NEW_PREFIX+&apos;\2&apos;</span><br><span class="line"></span><br><span class="line">def search(dir)</span><br><span class="line">    Dir[File.join(dir, &apos;*&apos;)].each do |file|</span><br><span class="line">        unless FOLDER_EXCLUDE.include?(File.extname(file).empty? ? File.basename(file) : File.extname(file))</span><br><span class="line">            # 非排除的文件夹，才进入搜索</span><br><span class="line">            if File.directory?(file)</span><br><span class="line">                search(file)</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        if File.file?(file)</span><br><span class="line">            search_content(file)</span><br><span class="line">        end</span><br><span class="line">        filename = File.basename(file)</span><br><span class="line">        new_filename = filename.gsub(Regexp.new(REGEXP), NEW_STRING)</span><br><span class="line">        if filename != new_filename</span><br><span class="line">            dirname = File.dirname(file)</span><br><span class="line">            new_file = File.join(dirname, new_filename)</span><br><span class="line">            puts &quot;重命名文件: #&#123;file&#125; -&gt; #&#123;new_file&#125;&quot;</span><br><span class="line">            File.rename(file, new_file)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def search_content(file)</span><br><span class="line">    # 不对排查的文件进行内容替换</span><br><span class="line">    return if CONTENT_EXCLUDE.include?(File.extname(file))</span><br><span class="line">    encoding = `file -I &quot;#&#123;file&#125;&quot;`.strip.split(&apos;charset=&apos;).last</span><br><span class="line">    encoding = &quot;utf-8&quot; if encoding.empty?</span><br><span class="line">    puts &quot;分析: #&#123;file&#125; (#&#123;encoding&#125;)&quot;</span><br><span class="line">    content = File.open(file, &quot;rb:#&#123;encoding&#125;&quot;, &amp;:read)</span><br><span class="line">    reg = Regexp.new(REGEXP.encode(encoding))</span><br><span class="line">    new_content = content.gsub(reg, NEW_STRING.encode(encoding))</span><br><span class="line">    if content != new_content</span><br><span class="line">        File.open(file, &quot;w:UTF-8&quot;) do |f|</span><br><span class="line">            f.write(new_content)</span><br><span class="line">        end</span><br><span class="line">        puts &quot;更新文件内容: #&#123;file&#125;&quot;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">search(Dir.pwd)</span><br></pre></td></tr></table></figure><p><em>将以上脚本copy到rename.rb文件放在项目目录下 OLD_PREFIX、 NEW_PREFIX 分别填写你想要改的名字 执行 ruby rename.rb 即可 如果项目集成了cocoapod这时候会报错 只需要重新pod install即可</em></p>]]></content>
    
    <summary type="html">
    
      iOS开发经常会复制另一个项目进行开发更改 这时候要做的第一件事就是更改项目名，下面有一段更改项目名以及文件名的脚本
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Run Script</title>
    <link href="http://lbrjms.github.io/2019/07/19/Run-Script/"/>
    <id>http://lbrjms.github.io/2019/07/19/Run-Script/</id>
    <published>2019-07-19T05:26:33.000Z</published>
    <updated>2019-07-19T09:41:43.243Z</updated>
    
    <content type="html"><![CDATA[<h3 id="譬如启动页动态加载版本号"><a href="#譬如启动页动态加载版本号" class="headerlink" title="譬如启动页动态加载版本号"></a>譬如启动页动态加载版本号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 获取当前版本号</span><br><span class="line"># PlistBuddy plist操作工具 可用来对plist文件增删改查</span><br><span class="line">versionNumber=$(/usr/libexec/PlistBuddy -c &quot;Print :CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)</span><br><span class="line"># sed是一个非交互性文本流编辑器，可以与vi一样对文本进行编辑，但其可以在命令行或shell脚本中执行，从而避免了繁重的人机交互式的文件编辑操作</span><br><span class="line">sed -i bak -e &quot;/userLabel=\&quot;AppVersion\&quot;/s/text=\&quot;[^\&quot;]*\&quot;/text=\&quot;版本号：$versionNumber\&quot;/&quot; $PROJECT_DIR/LHGJiOS/Base.lproj/LaunchScreen.storyboard</span><br></pre></td></tr></table></figure><h3 id="常用的脚本"><a href="#常用的脚本" class="headerlink" title="常用的脚本"></a>常用的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">每次构建的时候build号自增</span><br><span class="line">if [ $CONFIGURATION == Release ]; then</span><br><span class="line">    echo &quot;Bumping build number...&quot;</span><br><span class="line">    plist=$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;</span><br><span class="line"></span><br><span class="line">    #increment the build number (ie 115 to 116)</span><br><span class="line">    buildnum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line"></span><br><span class="line">    if [[ &quot;$&#123;buildnum&#125;&quot; == &quot;&quot; ]]; then</span><br><span class="line">        echo &quot;No build number in $plist&quot;</span><br><span class="line">        exit 2</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    buildnum=$(expr $buildnum + 1)</span><br><span class="line"></span><br><span class="line">    /usr/libexec/Plistbuddy -c &quot;Set CFBundleVersion $buildnum&quot; &quot;$&#123;plist&#125;&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;Bumped build number to $buildnum&quot;</span><br><span class="line"></span><br><span class="line">    echo &quot;开始自增 Version 最后一位&quot;</span><br><span class="line">    versionNum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;)</span><br><span class="line">    # 取出第三个值</span><br><span class="line">    thirdPartVersonNum=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $3&#125;&apos;`</span><br><span class="line">    thirdPartVersonNum=$(($thirdPartVersonNum + 1))</span><br><span class="line">    newVersionStr=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $1 &quot;.&quot; $2 &quot;.&apos;$thirdPartVersonNum&apos;&quot; &#125;&apos;`</span><br><span class="line">    /usr/libexec/PlistBuddy -c &quot;Set CFBundleShortVersionString $newVersionStr&quot; &quot;$&#123;plist&#125;&quot;</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">    echo $CONFIGURATION &quot; build - Not bumping build number.&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">根据bundleID不同，设置不同的jpush appkey等</span><br><span class="line">#!/bin/bash</span><br><span class="line">bundleID=$&#123;PRODUCT_BUNDLE_IDENTIFIER&#125;</span><br><span class="line">id=&quot;com.zhoumoquan.zhoumoquan&quot;</span><br><span class="line">if [&quot;$bundleID&quot;=&quot;$id&quot;]; then</span><br><span class="line">cp zmq/PushConfig_AppStore.plist zmq/PushConfig.plist</span><br><span class="line">else</span><br><span class="line">cp zmq/PushConfig_Enterprise.plist zmq/PushConfig.plist</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">打包上传时移除第三方库中无用的部分</span><br><span class="line">APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line"># This script loops through the frameworks embedded in the application and</span><br><span class="line"># removes unused architectures.</span><br><span class="line">find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORK</span><br><span class="line">do</span><br><span class="line">FRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)</span><br><span class="line">FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">EXTRACTED_ARCHS=()</span><br><span class="line"></span><br><span class="line">for ARCH in $ARCHS</span><br><span class="line">do</span><br><span class="line">echo &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;</span><br><span class="line">lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;</span><br><span class="line">EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;</span><br><span class="line">lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line">rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;Replacing original executable with thinned version&quot;</span><br><span class="line">rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line">mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>Xcode Run Script Phase，有很多环境变量。</p><p>可以添加一个 Run Script,添加一条命令：env 编译之后就可以再编译报告里看到输出的环境变量</p>]]></content>
    
    <summary type="html">
    
      ios项目中可以添加Run Script动态加载你想要的
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>iOS崩溃日志符号化</title>
    <link href="http://lbrjms.github.io/2019/07/19/iOS%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E7%AC%A6%E5%8F%B7%E5%8C%96/"/>
    <id>http://lbrjms.github.io/2019/07/19/iOS崩溃日志符号化/</id>
    <published>2019-07-19T04:48:57.000Z</published>
    <updated>2019-07-19T09:41:35.396Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="shell" scheme="http://lbrjms.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>iOS与JS交互之WKWebView</title>
    <link href="http://lbrjms.github.io/2019/07/18/iOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E4%B9%8BWKWebView/"/>
    <id>http://lbrjms.github.io/2019/07/18/iOS与JS交互之WKWebView/</id>
    <published>2019-07-18T09:53:41.000Z</published>
    <updated>2019-07-19T04:45:27.557Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iOS调js"><a href="#iOS调js" class="headerlink" title="iOS调js"></a>iOS调js</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">两端提前协议号方法参数</span><br><span class="line">[self.webView evaluateJavaScript:@&quot;ocToJs(&apos;loginSucceed&apos;, &apos;oc_tokenString&apos;)&quot; completionHandler:^(id response, NSError *error) &#123;&#125;];</span><br></pre></td></tr></table></figure><h3 id="js调oc"><a href="#js调oc" class="headerlink" title="js调oc"></a>js调oc</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">WKScriptMessageHandler oc端实现此协议下的方法：</span><br><span class="line"></span><br><span class="line">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;</span><br><span class="line"></span><br><span class="line">、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、</span><br><span class="line">@interface WKScriptMessage : NSObject</span><br><span class="line"></span><br><span class="line">/*! @abstract The body of the message.</span><br><span class="line"> @discussion Allowed types are NSNumber, NSString, NSDate, NSArray,</span><br><span class="line"> NSDictionary, and NSNull.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, copy) id body;</span><br><span class="line"></span><br><span class="line">/*! @abstract The web view sending the message. */</span><br><span class="line">@property (nullable, nonatomic, readonly, weak) WKWebView *webView;</span><br><span class="line"></span><br><span class="line">/*! @abstract The frame sending the message. */</span><br><span class="line">@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;</span><br><span class="line"></span><br><span class="line">/*! @abstract The name of the message handler to which the message is sent.</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, readonly, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>name判断是否是提前定义好的方法 body里面是想要的参数</p><p>我会对body做进一步的处理 这主要看自己和后台的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NSData * data = [body dataUsingEncoding:NSUTF8StringEncoding];  </span><br><span class="line">NSError * err;</span><br><span class="line">id jsonData = (NSDictionary *)[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;err];</span><br><span class="line">if (err) &#123;</span><br><span class="line">    jsonData = body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="加载网页过程的高度进度等控制"><a href="#加载网页过程的高度进度等控制" class="headerlink" title="加载网页过程的高度进度等控制"></a>加载网页过程的高度进度等控制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line"></span><br><span class="line">    if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123;</span><br><span class="line">        CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue];</span><br><span class="line">        !self.getWebEswebEtimatedProgress?:self.getWebEswebEtimatedProgress(newprogress);</span><br><span class="line">    &#125;else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123;</span><br><span class="line">        NSString * webTitle = [change objectForKey:NSKeyValueChangeNewKey];</span><br><span class="line">        !self.getWebTitle?:self.getWebTitle(webTitle);</span><br><span class="line">    &#125;else if ([keyPath isEqualToString:NSStringFromSelector(@selector(contentSize))]) &#123;</span><br><span class="line">        //sizeThatFits: 返回一个合适的大小以布局，默认实现是返回当前视图的已知大小</span><br><span class="line">        CGSize webViewSize = self.wkWebView.scrollView.contentSize;</span><br><span class="line">        if (_observeScrollHeight) &#123;</span><br><span class="line">            _observeScrollHeight(webViewSize.height);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="网页加载成功后的高度回调"><a href="#网页加载成功后的高度回调" class="headerlink" title="网页加载成功后的高度回调"></a>网页加载成功后的高度回调</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">///网页加载成功</span><br><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123;</span><br><span class="line">    !self.didFinishNavigation?:self.didFinishNavigation();</span><br><span class="line">    /* 获取webView的高度 @&quot;document.body.scrollHeight&quot; @&quot;document.body.offsetHeight&quot; @&quot;document.body.clientHeight&quot;*/</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    [webView evaluateJavaScript:@&quot;document.body.scrollHeight&quot; completionHandler:^(id h, NSError * _Nullable error) &#123;</span><br><span class="line">        __strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">        if (!error) &#123;</span><br><span class="line">            !strongSelf.getWebDocumentBodyScrollHeight?:strongSelf.getWebDocumentBodyScrollHeight([h floatValue]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考 <a href="https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA</a>?</p>]]></content>
    
    <summary type="html">
    
      为了方便快捷的开发app，开发过程中经常有WKWebView 实现iOS与js的交互
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 重签名</title>
    <link href="http://lbrjms.github.io/2019/07/05/iOS-%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    <id>http://lbrjms.github.io/2019/07/05/iOS-重签名/</id>
    <published>2019-07-05T02:07:28.000Z</published>
    <updated>2019-07-15T03:14:32.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="xcode-Profiles地址"><a href="#xcode-Profiles地址" class="headerlink" title="xcode Profiles地址"></a>xcode Profiles地址</h3><p> ~/Library/MobileDevice/Provisioning Profiles</p><h3 id="签名的基本流程"><a href="#签名的基本流程" class="headerlink" title="签名的基本流程"></a>签名的基本流程</h3><p>1、在Mac上生成一对公私钥，这里称公钥M，私钥M。</p><p>2、苹果自己有固定的一对公私钥，跟上面AppStore例子一样，私钥在苹果后台，公钥内置在每个iOS设备上，这里称为公钥A，私钥A。</p><p>3、把公钥M上传到苹果后台，用苹果后台里的私钥A去签名公钥M。得到一份数据包含了公钥M以及其签名（也就是公钥的HASH值），把这份数据称为证书。</p><p>4、在开发时，编译完一个App后，用本地的私钥M对这个App进行签名，同时把第三步得到的证书一起打包进App里，安装到手机。</p><p>5、在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证证书的数字签名是否正确。</p><p>验证证书确保公钥M是苹果认证过的，再用公钥M去验证App的签名，这里就间接验证了这个App的安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证App是否被改动，因为开发阶段App内容总是不断变化的，苹果不需要管）。</p><p><a href="https://www.jianshu.com/p/fc56a70ee4fb" target="_blank" rel="noopener">https://www.jianshu.com/p/fc56a70ee4fb</a></p><h3 id="plis文件的生成"><a href="#plis文件的生成" class="headerlink" title="plis文件的生成"></a>plis文件的生成</h3><ul><li><p>根据mobileprovision生成相关的plist<br><code>security cms -D -i 123.mobileprovision &gt; embedded.plist</code></p></li><li><p>根据plist 截取其中的Entitlements部分<br><code>/usr/libexec/PlistBuddy -x -c &#39;Print:Entitlements&#39;  embedded.plist &gt; entitlements.plist</code></p></li></ul><h3 id="签名脚本"><a href="#签名脚本" class="headerlink" title="签名脚本"></a>签名脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">if ! ([ -f &quot;$1&quot; ]); then</span><br><span class="line">echo ----- \&quot;$&#123;1&#125;\&quot;文件不存在</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line">ipaName=$&#123;1%.ipa&#125;</span><br><span class="line">if [ &quot;$ipaName&quot; = &quot;$1&quot; ]; then</span><br><span class="line">echo ----- \&quot;$&#123;1&#125;\&quot;error 不是ipa文件</span><br><span class="line">exit</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">## step 1 解压ipa</span><br><span class="line">unzip $&#123;ipaName&#125;.ipa</span><br><span class="line"></span><br><span class="line">## step 2 删除旧签名文件</span><br><span class="line">rm -rf Payload/*.app/_CodeSignature/</span><br><span class="line"></span><br><span class="line">## step 3 拷贝证书配置和权限文件</span><br><span class="line">cp embedded.mobileprovision Payload/*.app/embedded.mobileprovision</span><br><span class="line">cp entitlements.plist Payload/*.app/</span><br><span class="line"></span><br><span class="line">## step 4 重签名</span><br><span class="line">(</span><br><span class="line">/usr/bin/codesign -f -s &quot;Iris Info-Tech(Shanghai) Co.,Ltd&quot; --entitlements Payload/*.app/entitlements.plist Payload/*.app/</span><br><span class="line">) || &#123;</span><br><span class="line">rm -rf Payload/</span><br><span class="line">rm -rf __MACOSX/</span><br><span class="line">exit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## step 5 打包</span><br><span class="line">zip -r $&#123;ipaName&#125;_resign.ipa Payload/</span><br><span class="line">rm -rf Payload/</span><br><span class="line">rm -rf __MACOSX/</span><br></pre></td></tr></table></figure><h3 id="签名工具"><a href="#签名工具" class="headerlink" title="签名工具"></a>签名工具</h3><p>iReSign</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;xcode-Profiles地址&quot;&gt;&lt;a href=&quot;#xcode-Profiles地址&quot; class=&quot;headerlink&quot; title=&quot;xcode Profiles地址&quot;&gt;&lt;/a&gt;xcode Profiles地址&lt;/h3&gt;&lt;p&gt; ~/Library/Mob
      
    
    </summary>
    
    
      <category term="重签名" scheme="http://lbrjms.github.io/tags/%E9%87%8D%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Cocoapods制作自己的Pod库</title>
    <link href="http://lbrjms.github.io/2019/06/12/Cocoapods%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84Pod%E5%BA%93/"/>
    <id>http://lbrjms.github.io/2019/06/12/Cocoapods制作自己的Pod库/</id>
    <published>2019-06-12T07:53:56.000Z</published>
    <updated>2019-06-12T08:53:11.645Z</updated>
    
    <content type="html"><![CDATA[<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><ul><li><p>GitHub上创建仓库 test</p></li><li><p>克隆仓库到本地</p></li><li><p>在仓库下面建项目（即你要开放的代码）</p></li><li><p>创建.podspec文件</p><p><code>pod spec create test</code></p></li><li><p>编辑.podspec文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Pod::Spec.new do |s|</span><br><span class="line"></span><br><span class="line">  s.name         = &quot;WJDetailHeaderView&quot;</span><br><span class="line">  s.version      = &quot;1.0.1&quot;</span><br><span class="line">  s.summary      = &quot;标详情页的头部&quot;</span><br><span class="line">  # 这个必须得写否则会报错 并且要比summary长</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line">  这是新建的标信息仓库</span><br><span class="line">                   DESC</span><br><span class="line">  s.homepage     = &quot;https://github.com/lbrjms/WJDetailHeaderView&quot;</span><br><span class="line">  s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125;</span><br><span class="line">  s.author             = &#123; &quot;lwj_code&quot; =&gt; &quot;wallien@163.com&quot; &#125;</span><br><span class="line">  s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line">  s.source       = &#123; :git =&gt; &quot;https://github.com/lbrjms/WJDetailHeaderView.git&quot;, :tag =&gt; s.version &#125;</span><br><span class="line">  s.source_files  = &quot;Classes&quot;, &quot;WJDetailHeaderView/WJDetailHeaderView/DetailHeaderView.swift&quot;</span><br><span class="line">  # 指定swift的版本 否则有警告</span><br><span class="line">  s.swift_version = &apos;3.2&apos;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>项目打源码tag并上传git</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git status</span><br><span class="line">git commit -m &quot;this is 1.0.0&quot;</span><br><span class="line">git tag &apos;1.0.0&apos;</span><br><span class="line">git push --tags</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><ul><li>验证podspec</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure><ul><li>注册pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pod trunk register wallien@163.com &quot;lwj_code&quot;</span><br><span class="line"></span><br><span class="line">注册之后记得邮箱认证</span><br></pre></td></tr></table></figure><ul><li>发布pod</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk push test.podspec</span><br></pre></td></tr></table></figure><p>到这里没问题就是成功了</p><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p>xcrun: error: unable to find utility “simctl”, not a developer tool or in PATH ) during validation</p><p>到xcode的偏好设置里面设置command line tools： Xcode&gt;preferences&gt;Locations里面，设置之后再运行终端即可</p>]]></content>
    
    <summary type="html">
    
      做iOS开发 很多都会用cocoapods管理第三方开源库 有时候会会想自己也写一个 另外组件化开发更需我们制作自己的开源库
    
    </summary>
    
    
      <category term="Pod" scheme="http://lbrjms.github.io/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>RSS订阅打开都是xml的问题</title>
    <link href="http://lbrjms.github.io/2019/06/06/RSS%E8%AE%A2%E9%98%85%E6%89%93%E5%BC%80%E9%83%BD%E6%98%AFxml%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://lbrjms.github.io/2019/06/06/RSS订阅打开都是xml的问题/</id>
    <published>2019-06-06T07:20:22.000Z</published>
    <updated>2019-06-12T07:59:46.283Z</updated>
    
    <content type="html"><![CDATA[<p>安装rss插件</p><p><code>npm install hexo-generator-feed</code></p><p>在这个各种信息混杂的时代，rss真的感觉是一股清流，我们可以通过这个功能订阅自己先看的文章，节目….</p><p>刚接触rss遇到最多的问题就是点击网站的rss订阅 显示的都是xml代码，这是由于没有安装RSS客户端 或是没有支持RSS的插件</p><p>如果是google浏览器可以安装feeder插件挺好用</p><p><a href="https://juejin.im/post/5c382a326fb9a049f15469eb" target="_blank" rel="noopener">https://juejin.im/post/5c382a326fb9a049f15469eb</a></p><p><a href="https://www.inoreader.com/" target="_blank" rel="noopener">https://www.inoreader.com/</a></p>]]></content>
    
    <summary type="html">
    
      看到好多网站都有RSS订阅的东西，最早不知道什么作用，后来发现确实很好 这里记录一下自己看到的关于rss的文章
    
    </summary>
    
    
      <category term="Hexo" scheme="http://lbrjms.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>MD常用语法</title>
    <link href="http://lbrjms.github.io/2019/06/05/md%E8%AF%AD%E6%B3%95/"/>
    <id>http://lbrjms.github.io/2019/06/05/md语法/</id>
    <published>2019-06-05T08:26:20.000Z</published>
    <updated>2019-06-12T08:01:22.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="md简单语法"><a href="#md简单语法" class="headerlink" title="md简单语法"></a>md简单语法</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><p>//形式一</p><ul><li>a</li><li>b</li><li>c</li></ul><p>//形式二</p><ul><li>d</li><li>e</li><li>f</li></ul><p>//形式三</p><ul><li>g</li><li>h</li><li>i</li></ul><h1 id="无序列表嵌套"><a href="#无序列表嵌套" class="headerlink" title="无序列表嵌套"></a>无序列表嵌套</h1><ul><li>123<ul><li>abc</li><li>bcd</li><li>cde</li></ul></li><li>465</li><li>789</li></ul><h1 id="有序列表嵌套"><a href="#有序列表嵌套" class="headerlink" title="有序列表嵌套"></a>有序列表嵌套</h1><ol><li>abcd<ol><li>abcde</li><li>abcde</li><li>abcde</li></ol></li><li>bcde</li><li>cdef</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><blockquote><p>引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。</p></blockquote><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p><blockquote><p>四级引用</p><blockquote><p>五级引用</p><blockquote><p>六级引用</p></blockquote></blockquote></blockquote></blockquote></blockquote></blockquote><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><p><code>NSOpenPanel* openDlg = [NSOpenPanel openPanel]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSOpenPanel* openDlg = [NSOpenPanel openPanel];</span><br><span class="line"></span><br><span class="line">[openDlg setCanChooseFiles:TRUE];</span><br><span class="line">[openDlg setCanChooseDirectories:FALSE];</span><br><span class="line">[openDlg setAllowsMultipleSelection:FALSE];</span><br><span class="line">[openDlg setAllowsOtherFileTypes:FALSE];</span><br><span class="line">[openDlg setAllowedFileTypes:@[@&quot;ipa&quot;, @&quot;IPA&quot;, @&quot;xcarchive&quot;]];</span><br><span class="line"></span><br><span class="line">if ([openDlg runModal] == NSOKButton)</span><br><span class="line">&#123;</span><br><span class="line">    NSString* fileNameOpened = [[[openDlg URLs] objectAtIndex:0] path];</span><br><span class="line">    [pathField setStringValue:fileNameOpened];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><ul><li>行内式<br>链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来</li></ul><p><a href="https://www.jianshu.com" title="创作你的创作" target="_blank" rel="noopener">简书</a>,是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流</p><ul><li>参数式<br>链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来</li></ul><p><a href="https://www.jianshu.com" title="创作你的创作" target="_blank" rel="noopener">简书</a>是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。</p><p>//参数定义的其他写法</p><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><h3 id="至少三个字符"><a href="#至少三个字符" class="headerlink" title="至少三个字符"></a>至少三个字符</h3><hr><hr><hr><hr><hr><hr><hr><hr><hr><h1 id="斜体-加粗-删除线"><a href="#斜体-加粗-删除线" class="headerlink" title="斜体 加粗 删除线"></a>斜体 加粗 删除线</h1><p><em>md</em><br><strong>md</strong></p><p><em>md</em><br><strong>md</strong></p><p><del>删除</del></p><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><p>//例子一</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>//例子二</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table><p>//例子三</p><table><thead><tr><th align="left">123</th><th align="center">234</th><th align="right">345</th></tr></thead><tbody><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr><tr><td align="left">abc</td><td align="center">bcd</td><td align="right">cde</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      记录常用的md命令
    
    </summary>
    
      <category term="文章" scheme="http://lbrjms.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo + GitHubPages搭建个人博客</title>
    <link href="http://lbrjms.github.io/2019/06/05/GitHub-Pages-Hexo%E5%86%99%E5%8D%9A%E5%AE%A2/"/>
    <id>http://lbrjms.github.io/2019/06/05/GitHub-Pages-Hexo写博客/</id>
    <published>2019-06-05T07:11:20.000Z</published>
    <updated>2019-06-12T08:00:46.641Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建github仓库"><a href="#创建github仓库" class="headerlink" title="创建github仓库"></a>创建github仓库</h3><ul><li>创建一个github仓库 仓库名必须与用户名相同 之后的博客地址就是：<a href="http://username.github.io" target="_blank" rel="noopener">http://username.github.io</a></li></ul><h3 id="配置ssh"><a href="#配置ssh" class="headerlink" title="配置ssh"></a>配置ssh</h3><p><em>Git可以通过https和ssh两种方式连接服务器上的仓库。ssh的方式会在传输前压缩数据，<br>这样传输的效率很高。而且不需要每次都输入账号和密码。</em></p><ul><li>git的用户名和邮箱设置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name &quot;your name”</span><br><span class="line">$ git config --global user.email &quot;your email&quot;</span><br></pre></td></tr></table></figure><ul><li>查看本地是否有ssh密钥（有这些文件说明已经有了id_rsa，id_rsa.pubknown_hosts），<br>如果没有就自己生成</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成ssh命令 根据提示一步步操作即可</span><br><span class="line">ssh-keygen -t rsa -C “your email”</span><br></pre></td></tr></table></figure><ul><li>vim打开公钥文件 复制共钥到github的设置里面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim id_rsa.pub</span><br></pre></td></tr></table></figure><h3 id="安装Hexo环境"><a href="#安装Hexo环境" class="headerlink" title="安装Hexo环境"></a>安装Hexo环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 安装hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">// 初始化一个blog文件夹</span><br><span class="line">hexo init blog</span><br><span class="line"></span><br><span class="line">// 到blog文件夹下启动服务 之后就可以在http://localhost:4000 看的你的博客</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="配置Deployment"><a href="#配置Deployment" class="headerlink" title="配置Deployment"></a>配置Deployment</h3><ul><li>修改blog文件夹下的_config.yml文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">### :号后面都要有空格 否则hexo d的时候会没反应</span><br><span class="line">deploy:</span><br><span class="line">type:git</span><br><span class="line">repo:git@github.com:你的github账号/你的github账号.github.io.git</span><br><span class="line">branch:master</span><br></pre></td></tr></table></figure><ul><li>生成新的public文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean   //删除旧的public文件</span><br><span class="line">hexo generate / hexo g   //生成新的public文件</span><br></pre></td></tr></table></figure><h3 id="部署到github上"><a href="#部署到github上" class="headerlink" title="部署到github上"></a>部署到github上</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploye / hexo d</span><br></pre></td></tr></table></figure><p><em>到此就初步完成了 在打开<a href="https://lbrjms.github.io就可以看到你的博客了" target="_blank" rel="noopener">https://lbrjms.github.io就可以看到你的博客了</a></em></p><h3 id="更换主题A"><a href="#更换主题A" class="headerlink" title="更换主题Â"></a>更换主题Â</h3><p><em>成功之后的第一件事就是更换主题 选择自己喜欢的主题 下载到themes文件夹下面<br>更改_config.yml 的themes 对应的名字就可以了</em></p><ul><li>下面是我clone的主题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">$ npm install hexo-renderer-pug --save</span><br><span class="line">$ npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><ul><li>开启分类 tags</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><h3 id="创建文章"><a href="#创建文章" class="headerlink" title="创建文章"></a>创建文章</h3><p><code>$ hexo new &quot;title&quot;</code></p><h3 id="关于界面"><a href="#关于界面" class="headerlink" title="关于界面"></a>关于界面</h3><blockquote><p>maupassant主题里有个关于导航菜单，默认点进去是不行的，需要自己新建个。<br>在Hexo的 source 目录新建个 about 文件夹，文件夹里按模板新建个 index.md</p></blockquote><h3 id="更改主题语言"><a href="#更改主题语言" class="headerlink" title="更改主题语言"></a>更改主题语言</h3><p>支持多种语言 去config文件里面改就可以（我找了半天才找到）其实关于一些设置的东西 大多数都在config里面改</p>]]></content>
    
    <summary type="html">
    
      自己之前搭建过blog，当时是公司的电脑，另外当时也是稀里糊涂搞出来了，后来换了公司把原文件都搞丢了，后来就忘记怎么弄了，这次又重新来了一遍，并做了笔记，记性再好不如写下来 实在。
    
    </summary>
    
      <category term="文章" scheme="http://lbrjms.github.io/categories/%E6%96%87%E7%AB%A0/"/>
    
    
      <category term="Hexo" scheme="http://lbrjms.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lbrjms.github.io/2019/06/05/hello-world/"/>
    <id>http://lbrjms.github.io/2019/06/05/hello-world/</id>
    <published>2019-06-05T01:40:28.316Z</published>
    <updated>2019-06-05T01:40:28.317Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Unity gameobject 的 生命周期</title>
    <link href="http://lbrjms.github.io/2018/08/08/Unity%20gameobject%20%E7%9A%84%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://lbrjms.github.io/2018/08/08/Unity gameobject 的 生命周期/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-06-12T09:03:40.739Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Unity3d-基础学习"><a href="#Unity3d-基础学习" class="headerlink" title="Unity3d 基础学习"></a>Unity3d 基础学习</h3><a id="more"></a><h4 id="脚本生命周期"><a href="#脚本生命周期" class="headerlink" title="脚本生命周期"></a>脚本生命周期</h4><ul><li><p>Awake</p><p>脚本被载入是调用</p></li><li><p>OnEnable</p><p>对象变为可用或激活状态时调用</p></li><li><p>Start</p><p>只调用一次</p></li><li><p>FixedUpdate</p><p>固定的时间间隔被调用 不受设备的帧率等的影响</p></li><li><p>Update</p><p>更新</p></li><li><p>LateUpdate</p><p>Update之后更新</p></li><li><p>OnGUI</p><p>渲染和处理GUI事件</p></li><li><p>OnDisable</p><p>当前对象不可用或处于非激活状态 脚本或对象被销毁的时候调用</p></li><li><p>OnDestroy</p><p>当物体 或是 脚本 被销毁</p></li></ul><h3 id="常用的方法"><a href="#常用的方法" class="headerlink" title="常用的方法"></a>常用的方法</h3><ul><li><p>gameObt.GetComponent&lt; compomentName &gt; ();</p><p>获取到对应的compoment</p></li><li><p>GetComponent<rigidbody> ().AddForce (vec3);</rigidbody></p><p>给刚体添加力</p></li></ul><!--more-->]]></content>
    
    <summary type="html">
    
      Unity3d 基础学习
    
    </summary>
    
    
      <category term="iOS" scheme="http://lbrjms.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>全局Pop 隐藏TabBar NavigationBar</title>
    <link href="http://lbrjms.github.io/2018/08/08/%E5%85%A8%E5%B1%80Pop%20%E9%9A%90%E8%97%8FTabBar%20NavigationBar/"/>
    <id>http://lbrjms.github.io/2018/08/08/全局Pop 隐藏TabBar NavigationBar/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-06-12T09:03:21.817Z</updated>
    
    <content type="html"><![CDATA[<h3 id="全局Pop-侧边缘滑动的拓展"><a href="#全局Pop-侧边缘滑动的拓展" class="headerlink" title="全局Pop(侧边缘滑动的拓展)"></a>全局Pop(侧边缘滑动的拓展)</h3><a id="more"></a><h4 id="思路-给系统的侧边缘滑动runtime添加target-action"><a href="#思路-给系统的侧边缘滑动runtime添加target-action" class="headerlink" title="思路:给系统的侧边缘滑动runtime添加target action"></a>思路:给系统的侧边缘滑动runtime添加target action</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomNavigationController</span>: <span class="title">UINavigationController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 获取系统的Pop手势</span></span><br><span class="line">    <span class="keyword">let</span> systemGes = interactivePopGestureRecognizer</span><br><span class="line">    <span class="comment">// 2. 获取手势的view用于添加新的手势</span></span><br><span class="line">    <span class="keyword">let</span> gesView = systemGes?.view</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取target/action</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 利用运行时机制获取所有的属性名称</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> : <span class="type">UInt32</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> ivars = class_copyIvarList(<span class="type">UIGestureRecognizer</span>.<span class="keyword">self</span>, &amp;<span class="built_in">count</span>)!</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ivar = ivars[<span class="type">Int</span>(i)]</span><br><span class="line">        <span class="keyword">let</span> name = ivar_getName(ivar)!</span><br><span class="line">        <span class="built_in">print</span>(<span class="type">String</span>(cString : name))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> targets = systemGes?.value(forKey: <span class="string">"_targets"</span>) <span class="keyword">as</span>? [<span class="type">NSObject</span>]</span><br><span class="line">    <span class="keyword">let</span> targetObjc = targets?.first</span><br><span class="line">    <span class="comment">// 3.2 取出target</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> target = targetObjc?.value(forKey: <span class="string">"target"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">// 3.3 取出action</span></span><br><span class="line">    <span class="keyword">let</span> action = <span class="type">Selector</span>((<span class="string">"handleNavigationTransition:"</span>))</span><br><span class="line">    <span class="comment">// 4. 创建自己的Pan手势</span></span><br><span class="line">    <span class="keyword">let</span> panGes = <span class="type">UIPanGestureRecognizer</span>()</span><br><span class="line">    gesView?.addGestureRecognizer(panGes)</span><br><span class="line">    panGes.addTarget(target, action: action)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐藏tabBar"><a href="#隐藏tabBar" class="headerlink" title="隐藏tabBar"></a>隐藏tabBar</h4><pre><code>import UIKitclass CustomNavigationController: UINavigationController { override func viewDidLoad() {    super.viewDidLoad() } override func pushViewController(_ viewController: UIViewController, animated: Bool) {     viewController.hidesBottomBarWhenPushed = true     super.pushViewController(viewController, animated: animated) }}</code></pre><h4 id="隐藏NavigationBar"><a href="#隐藏NavigationBar" class="headerlink" title="隐藏NavigationBar"></a>隐藏NavigationBar</h4><pre><code>class ViewController: UIViewController,UIGestureRecognizerDelegate {override func viewWillAppear(_ animated: Bool) {super.viewWillAppear(animated)navigationController?.setNavigationBarHidden(true, animated: true)navigationController?.interactivePopGestureRecognizer?.delegate = selfnavigationController?.interactivePopGestureRecognizer?.isEnabled = true}override func viewWillDisappear(_ animated: Bool) {super.viewWillDisappear(animated)navigationController?.setNavigationBarHidden(false, animated: true)}override func viewDidLoad() {super.viewDidLoad()}}</code></pre>]]></content>
    
    <summary type="html">
    
      全局Pop(侧边缘滑动的拓展)
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>swift基础之可选型</title>
    <link href="http://lbrjms.github.io/2018/07/30/swift%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%AF%E9%80%89%E5%9E%8B/"/>
    <id>http://lbrjms.github.io/2018/07/30/swift基础之可选型/</id>
    <published>2018-07-30T10:01:19.000Z</published>
    <updated>2019-07-30T11:05:18.224Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 可选型</span><br><span class="line"> * 主要用来表示 没有 这个概念</span><br><span class="line"> * 必须显示表达</span><br><span class="line"> * 正常会作为var 变量来存在</span><br><span class="line"> * 不能被直接使用 因为它有可能是空 会报错</span><br><span class="line"> * 被解包才能用</span><br><span class="line"> * ! 强制解包</span><br><span class="line"> * if let 解包</span><br><span class="line"> * ??</span><br><span class="line"> * 三目运算符 ? :</span><br><span class="line"> * 隐式可选型</span><br><span class="line"> * var errorCode3: Int!</span><br><span class="line"> * errorCode3 = nil</span><br><span class="line"> */</span><br><span class="line">// 这不仅仅是整形 还是一个可选性</span><br><span class="line">var errorCode: Int? = 404</span><br><span class="line">errorCode = 0</span><br><span class="line">// 只有可选性才能被赋值为nil</span><br><span class="line">errorCode = nil</span><br><span class="line">print(errorCode)</span><br><span class="line">var errorCode2: String? = &quot;404&quot;</span><br><span class="line">errorCode2 = &quot;400&quot;</span><br><span class="line">&quot;The errorCode is &quot; + (errorCode2 ?? &quot;ss&quot;)</span><br><span class="line">errorCode2?.localizedUppercase</span><br><span class="line">if let safeCode = errorCode2 &#123;</span><br><span class="line">    // if let 的作用就是解包 判断空 解包成功 也就是不为空才会进来</span><br><span class="line">    &quot;safe&quot; + safeCode</span><br><span class="line">&#125;</span><br><span class="line">let ageIntput: String = &quot;23&quot;</span><br><span class="line">let age = Int(ageIntput) ?? 0</span><br><span class="line">print(age)</span><br><span class="line">let greetString = &quot;Hello&quot;</span><br><span class="line">greetString.range(of: &quot;o&quot;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="swift" scheme="http://lbrjms.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>各种地图的坐标转换</title>
    <link href="http://lbrjms.github.io/2017/07/26/%E5%90%84%E7%A7%8D%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2/"/>
    <id>http://lbrjms.github.io/2017/07/26/各种地图的坐标转换/</id>
    <published>2017-07-26T09:06:09.000Z</published>
    <updated>2019-06-12T08:05:21.805Z</updated>
    
    <content type="html"><![CDATA[<p>各种地图的坐标转换</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@interface LWJLocation : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) double latitude;</span><br><span class="line">@property (nonatomic, assign) double longitude;</span><br><span class="line"></span><br><span class="line">- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 坐标系：</span><br><span class="line"> WGS-84：是国际标准，GPS坐标（Google Earth使用、或者GPS模块）</span><br><span class="line"> GCJ-02：中国坐标偏移标准，Google Map、高德、腾讯使用</span><br><span class="line"> BD-09 ：百度坐标偏移标准，Baidu Map使用</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#pragma mark - 从GPS坐标转化到高德坐标</span><br><span class="line">- (id)transformFromGPSToGD;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从高德坐标转化到百度坐标</span><br><span class="line">- (id)transformFromGDToBD;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从百度坐标到高德坐标</span><br><span class="line">- (id)transformFromBDToGD;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从高德坐标到GPS坐标</span><br><span class="line">- (id)transformFromGDToGPS;</span><br><span class="line"></span><br><span class="line">#pragma mark - 从百度坐标到GPS坐标</span><br><span class="line">- (id)transformFromBDToGPS;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;CoreLocation/CoreLocation.h&gt;</span><br><span class="line"></span><br><span class="line">static const double a = 6378245.0;</span><br><span class="line">static const double ee = 0.00669342162296594323;</span><br><span class="line">static const double pi = M_PI;</span><br><span class="line">static const double xPi = M_PI  * 3000.0 / 180.0;</span><br><span class="line"></span><br><span class="line">@implementation LWJLocation</span><br><span class="line"></span><br><span class="line">- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude &#123;</span><br><span class="line">    if (self = [super init]) &#123;</span><br><span class="line">        self.latitude = latitude;</span><br><span class="line">        self.longitude = longitude;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)transformFromGPSToGD &#123;</span><br><span class="line">    CLLocationCoordinate2D coor = [LWJLocation transformFromWGSToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)];</span><br><span class="line">    return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)transformFromGDToBD &#123;</span><br><span class="line">    CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToBaidu:CLLocationCoordinate2DMake(self.latitude, self.longitude)];</span><br><span class="line">    return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)transformFromBDToGD &#123;</span><br><span class="line">    CLLocationCoordinate2D coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)];</span><br><span class="line">    return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)transformFromGDToGPS &#123;</span><br><span class="line">    CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(self.latitude, self.longitude)];</span><br><span class="line">    return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)transformFromBDToGPS &#123;</span><br><span class="line">    //先把百度转化为高德</span><br><span class="line">    CLLocationCoordinate2D start_coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)];</span><br><span class="line">    CLLocationCoordinate2D end_coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(start_coor.latitude, start_coor.longitude)];</span><br><span class="line">    return [[LWJLocation alloc] initWithLatitude:end_coor.latitude andLongitude:end_coor.longitude];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CLLocationCoordinate2D)transformFromWGSToGCJ:(CLLocationCoordinate2D)wgsLoc &#123;</span><br><span class="line">    CLLocationCoordinate2D adjustLoc;</span><br><span class="line">    if([self isLocationOutOfChina:wgsLoc]) &#123;</span><br><span class="line">        adjustLoc = wgsLoc;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        double adjustLat = [self transformLatWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];</span><br><span class="line">        double adjustLon = [self transformLonWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0];</span><br><span class="line">        long double radLat = wgsLoc.latitude / 180.0 * pi;</span><br><span class="line">        long double magic = sin(radLat);</span><br><span class="line">        magic = 1 - ee * magic * magic;</span><br><span class="line">        long double sqrtMagic = sqrt(magic);</span><br><span class="line">        adjustLat = (adjustLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi);</span><br><span class="line">        adjustLon = (adjustLon * 180.0) / (a / sqrtMagic * cos(radLat) * pi);</span><br><span class="line">        adjustLoc.latitude = wgsLoc.latitude + adjustLat;</span><br><span class="line">        adjustLoc.longitude = wgsLoc.longitude + adjustLon;</span><br><span class="line">    &#125;</span><br><span class="line">    return adjustLoc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (double)transformLatWithX:(double)x withY:(double)y &#123;</span><br><span class="line">    double lat = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x));</span><br><span class="line"></span><br><span class="line">    lat += (20.0 * sin(6.0 * x * pi) + 20.0 *sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">    lat += (20.0 * sin(y * pi) + 40.0 * sin(y / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">    lat += (160.0 * sin(y / 12.0 * pi) + 320 * sin(y * pi / 30.0)) * 2.0 / 3.0;</span><br><span class="line">    return lat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (double)transformLonWithX:(double)x withY:(double)y &#123;</span><br><span class="line">    double lon = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x));</span><br><span class="line">    lon += (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 / 3.0;</span><br><span class="line">    lon += (20.0 * sin(x * pi) + 40.0 * sin(x / 3.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">    lon += (150.0 * sin(x / 12.0 * pi) + 300.0 * sin(x / 30.0 * pi)) * 2.0 / 3.0;</span><br><span class="line">    return lon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CLLocationCoordinate2D)transformFromGCJToBaidu:(CLLocationCoordinate2D)p &#123;</span><br><span class="line">    long double z = sqrt(p.longitude * p.longitude + p.latitude * p.latitude) + 0.00002 * sqrt(p.latitude * pi);</span><br><span class="line">    long double theta = atan2(p.latitude, p.longitude) + 0.000003 * cos(p.longitude * pi);</span><br><span class="line">    CLLocationCoordinate2D geoPoint;</span><br><span class="line">    geoPoint.latitude  = (z * sin(theta) + 0.006);</span><br><span class="line">    geoPoint.longitude = (z * cos(theta) + 0.0065);</span><br><span class="line">    return geoPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CLLocationCoordinate2D)transformFromBaiduToGCJ:(CLLocationCoordinate2D)p &#123;</span><br><span class="line">    double x = p.longitude - 0.0065, y = p.latitude - 0.006;</span><br><span class="line">    double z = sqrt(x * x + y * y) - 0.00002 * sin(y * xPi);</span><br><span class="line">    double theta = atan2(y, x) - 0.000003 * cos(x * xPi);</span><br><span class="line">    CLLocationCoordinate2D geoPoint;</span><br><span class="line">    geoPoint.latitude  = z * sin(theta);</span><br><span class="line">    geoPoint.longitude = z * cos(theta);</span><br><span class="line">    return geoPoint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (CLLocationCoordinate2D)transformFromGCJToWGS:(CLLocationCoordinate2D)p &#123;</span><br><span class="line">    double threshold = 0.00001;</span><br><span class="line"></span><br><span class="line">    // The boundary</span><br><span class="line">    double minLat = p.latitude - 0.5;</span><br><span class="line">    double maxLat = p.latitude + 0.5;</span><br><span class="line">    double minLng = p.longitude - 0.5;</span><br><span class="line">    double maxLng = p.longitude + 0.5;</span><br><span class="line"></span><br><span class="line">    double delta = 1;</span><br><span class="line">    int maxIteration = 30;</span><br><span class="line">    // Binary search</span><br><span class="line">    while(true) &#123;</span><br><span class="line">        CLLocationCoordinate2D leftBottom  = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = minLng&#125;];</span><br><span class="line">        CLLocationCoordinate2D rightBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = maxLng&#125;];</span><br><span class="line">        CLLocationCoordinate2D leftUp      = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = maxLat,.longitude = minLng&#125;];</span><br><span class="line">        CLLocationCoordinate2D midPoint    = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;];</span><br><span class="line">        delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude);</span><br><span class="line"></span><br><span class="line">        if(maxIteration-- &lt;= 0 || delta &lt;= threshold) &#123;</span><br><span class="line">            return (CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(isContains(p, leftBottom, midPoint)) &#123;</span><br><span class="line">            maxLat = (minLat + maxLat) / 2;</span><br><span class="line">            maxLng = (minLng + maxLng) / 2;</span><br><span class="line">        &#125; else if(isContains(p, rightBottom, midPoint)) &#123;</span><br><span class="line">            maxLat = (minLat + maxLat) / 2;</span><br><span class="line">            minLng = (minLng + maxLng) / 2;</span><br><span class="line">        &#125; else if(isContains(p, leftUp, midPoint)) &#123;</span><br><span class="line">            minLat = (minLat + maxLat) / 2;</span><br><span class="line">            maxLng = (minLng + maxLng) / 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            minLat = (minLat + maxLat) / 2;</span><br><span class="line">            minLng = (minLng + maxLng) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 判断某个点point是否在p1和p2之间</span><br><span class="line">static bool isContains(CLLocationCoordinate2D point, CLLocationCoordinate2D p1, CLLocationCoordinate2D p2) &#123;</span><br><span class="line">    return (point.latitude &gt;= MIN(p1.latitude, p2.latitude) &amp;&amp; point.latitude &lt;= MAX(p1.latitude, p2.latitude)) &amp;&amp; (point.longitude &gt;= MIN(p1.longitude,p2.longitude) &amp;&amp; point.longitude &lt;= MAX(p1.longitude, p2.longitude));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - 判断是不是在中国</span><br><span class="line">+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location &#123;</span><br><span class="line">    if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271)</span><br><span class="line">        return YES;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种地图的坐标转换&lt;/p&gt;
    
    </summary>
    
    
      <category term="ios" scheme="http://lbrjms.github.io/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Runloop</title>
    <link href="http://lbrjms.github.io/2017/07/26/Runloop/"/>
    <id>http://lbrjms.github.io/2017/07/26/Runloop/</id>
    <published>2017-07-26T08:58:24.000Z</published>
    <updated>2019-08-11T16:05:13.219Z</updated>
    
    <content type="html"><![CDATA[<p>可用runloop控制图片加载 卡顿 等问题</p><a id="more"></a><ul><li>RunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。</li></ul><p>CFRunLoopRef<br>CFRunLoopModeRef<br>CFRunLoopSourceRef<br>CFRunLoopTimerRef<br>CFRunLoopObserverRef</p><ul><li>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个</li></ul><p>enum CFRunLoopActivity {<br>    kCFRunLoopEntry              = (1 &lt;&lt; 0),    // 即将进入Loop<br>    kCFRunLoopBeforeTimers      = (1 &lt;&lt; 1),    // 即将处理 Timer<br>    kCFRunLoopBeforeSources     = (1 &lt;&lt; 2),    // 即将处理 Source<br>    kCFRunLoopBeforeWaiting     = (1 &lt;&lt; 5),    // 即将进入休眠<br>    kCFRunLoopAfterWaiting      = (1 &lt;&lt; 6),    // 刚从休眠中唤醒<br>    kCFRunLoopExit               = (1 &lt;&lt; 7),    // 即将退出Loop<br>    kCFRunLoopAllActivities     = 0x0FFFFFFFU  // 包含上面所有状态<br>};<br>typedef enum CFRunLoopActivity CFRunLoopActivity;</p><ul><li>RunLoop主要处理以下6类事件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</span><br><span class="line">static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</span><br><span class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</span><br></pre></td></tr></table></figure><ul><li>CFRunLoopMode 和 CFRunLoop的结构大致如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode</p><p>kCFDefaultRunLoopMode App的默认Mode，通常主线程是在这个Mode下运行</p><p>UITrackingRunLoopMode 界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响</p><p>UIInitializationRunLoopMode 在刚启动App时第进入的第一个Mode，启动完成后就不再使用</p><p>GSEventReceiveRunLoopMode 接受系统事件的内部Mode，通常用不到</p><p>kCFRunLoopCommonModes 这是一个占位用的Mode，不是一种真正的Mode</p><p>其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。那为何我们又可以这么用呢</p><p>[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];<br>什么是CommonModes？</p><p>一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将_commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里<br>主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为”Common”属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。<br>如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。<br>怎么将事件加入到CommonMode？<br>我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。<br>这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。<br>在项目中最常用的就是设置NSTimer的Mode，比较简单这里就不说了。<br>当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line"></span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"></span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。<br>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用_objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。<br>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用_objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为__IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。哈哈_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的_UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是_UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调<strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><p>CFSocket<br>CFNetwork       -&gt;ASIHttpRequest<br>NSURLConnection -&gt;AFNetworking<br>NSURLSession    -&gt;AFNetworking2, Alamofire<br>• CFSocket 是最底层的接口，只负责 socket 通信。<br>• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。<br>• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。<br>• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。<br>下面主要介绍下 NSURLConnection 的工作过程。<br>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。<br>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><h3 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h3><ul><li>AFNetworking<br>AFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>AsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p><p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p><p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。<br>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。<br>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p><p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p><p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p><p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line">typedef BOOL(^RunloopBlock)(void);</span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 存放任务的数组</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, retain)NSMutableArray *tasks;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> 最大任务数</span><br><span class="line"> */</span><br><span class="line">@property (nonatomic, assign)NSUInteger max;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    _max = 18;</span><br><span class="line">    _tasks = [NSMutableArray array];</span><br><span class="line">    [self addRunloopObserver];</span><br><span class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerMothod) userInfo:nil repeats:YES];</span><br><span class="line"></span><br><span class="line">    [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line"></span><br><span class="line">//    dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, &lt;#dispatchQueue#&gt;);</span><br><span class="line">//    dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, &lt;#intervalInSeconds#&gt; * NSEC_PER_SEC, &lt;#leewayInSeconds#&gt; * NSEC_PER_SEC);</span><br><span class="line">//    dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">//        &lt;#code to be executed when timer fires#&gt;</span><br><span class="line">//    &#125;);</span><br><span class="line">//    dispatch_resume(timer);</span><br><span class="line">&#125;</span><br><span class="line">- (void)timerMothod</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;timer-----&quot;);</span><br><span class="line">&#125;</span><br><span class="line">-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">- (void)addRunloopObserver</span><br><span class="line">&#123;</span><br><span class="line">//    typedef struct &#123;</span><br><span class="line">//        CFIndex    version;</span><br><span class="line">//        void *    info;</span><br><span class="line">//        const void *(*retain)(const void *info);</span><br><span class="line">//        void    (*release)(const void *info);</span><br><span class="line">//        CFStringRef    (*copyDescription)(const void *info);</span><br><span class="line">//    &#125; CFRunLoopObserverContext;</span><br><span class="line">    // 上下文结构体</span><br><span class="line">    CFRunLoopObserverContext context = &#123;</span><br><span class="line">        0,</span><br><span class="line">        (__bridge void *)(self),</span><br><span class="line">        &amp;CFRetain,</span><br><span class="line">        &amp;CFRelease,</span><br><span class="line">        NULL</span><br><span class="line">    &#125;;</span><br><span class="line">    // 1.拿到当前的runloop</span><br><span class="line">    CFRunLoopRef runloop = CFRunLoopGetCurrent();</span><br><span class="line"></span><br><span class="line">    static CFRunLoopObserverRef defaultModeObserver;</span><br><span class="line">    // 创建观察者</span><br><span class="line">    defaultModeObserver = CFRunLoopObserverCreate(NULL, kCFRunLoopAfterWaiting, YES, 0, &amp;callBack, &amp;context);</span><br><span class="line">    // 添加当前观察者</span><br><span class="line">    CFRunLoopAddObserver(runloop, defaultModeObserver, kCFRunLoopDefaultMode);</span><br><span class="line">    // c语言与create就要有release</span><br><span class="line">    CFRelease(defaultModeObserver);</span><br><span class="line">&#125;</span><br><span class="line">static void callBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123;</span><br><span class="line">    ViewController *vc = (__bridge ViewController *)(info);</span><br><span class="line">    if (vc.tasks.count==0) return;</span><br><span class="line">    while (vc.tasks.count) &#123;</span><br><span class="line">        RunloopBlock unit = vc.tasks.firstObject;</span><br><span class="line">        [vc.tasks removeObjectAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可用runloop控制图片加载 卡顿 等问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="Runloop" scheme="http://lbrjms.github.io/tags/Runloop/"/>
    
  </entry>
  
  <entry>
    <title>CoreMLtest</title>
    <link href="http://lbrjms.github.io/2017/07/26/CoreMLtest/"/>
    <id>http://lbrjms.github.io/2017/07/26/CoreMLtest/</id>
    <published>2017-07-26T08:53:25.000Z</published>
    <updated>2019-06-12T08:13:26.514Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 11 机器学习练习</p><a id="more"></a><h2 id="iOS-11-机器学习练习"><a href="#iOS-11-机器学习练习" class="headerlink" title="iOS 11 机器学习练习"></a>iOS 11 机器学习练习</h2><!----><!----><h3 id="图片数据"><a href="#图片数据" class="headerlink" title="图片数据"></a>图片数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let imageData = pickImageView.image?.cgImage</span><br></pre></td></tr></table></figure><h3 id="用到的模型"><a href="#用到的模型" class="headerlink" title="用到的模型"></a>用到的模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let model = try! VNCoreMLModel(for: Resnet50().model)</span><br></pre></td></tr></table></figure><h3 id="配置请求"><a href="#配置请求" class="headerlink" title="配置请求"></a>配置请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let hander = VNImageRequestHandler(cgImage: imageData!)</span><br><span class="line">let request = VNCoreMLRequest(model: model, completionHandler: myResultsMethod)</span><br></pre></td></tr></table></figure><h3 id="执行请求"><a href="#执行请求" class="headerlink" title="执行请求"></a>执行请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">try! hander.perform([request])</span><br></pre></td></tr></table></figure><h3 id="请求的方法-用于model的输入输出"><a href="#请求的方法-用于model的输入输出" class="headerlink" title="请求的方法 用于model的输入输出"></a>请求的方法 用于model的输入输出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func myResultsMethod(request: VNRequest, <span class="attr">error</span>: <span class="built_in">Error</span>?) &#123;</span><br><span class="line">guard <span class="keyword">let</span> results = request.results <span class="keyword">as</span>? [VNClassificationObservation]</span><br><span class="line"><span class="keyword">else</span> &#123; fatalError(<span class="string">"huh"</span>) &#125;</span><br><span class="line">lable.text = results[<span class="number">0</span>].identifier</span><br><span class="line"><span class="keyword">for</span> classification <span class="keyword">in</span> results &#123;</span><br><span class="line">print(<span class="string">"=====++==="</span> + classification.identifier + <span class="string">"----++----"</span> )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">platform :ios, &quot;8.0&quot;</span><br><span class="line">inhibit_all_warnings!</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">target &apos;RAC_ObjcTest&apos; do</span><br><span class="line"></span><br><span class="line">pod &apos;ReactiveObjC&apos;</span><br><span class="line">pod &apos;XRCarouselView&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 11 机器学习练习&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://lbrjms.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
