<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS显示性能优化]]></title>
    <url>%2F2019%2F08%2F15%2FiOS%E6%98%BE%E7%A4%BA%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[视图混合(Blending)app中显示的效果往往是多个视图重合叠加的效果，而在计算视图重合显示颜色的时候就需要考虑透明的影响，当顶部视图出现透明的情况时，颜色的计算就需要考虑其透明度，这样无疑增加了计算成本，消耗GPU资源，所以应尽量避免过多的透明视图数量。对于UIImageView而言，如果图片本身是带有透明通道的同样会导致Blending，所以应该尽量避免使用带有透明度的图片。对于文本UILable, 如果不设置背景颜色，同样会出现Blending，所以需要设置UILabel的背景颜色，对于显示中文的UILabel, 除了设置背景颜色外还需要设置masksToBounds属性，因为中文时UILable会多了一个sublayer。 链接 1234接设置的layer的cornerRadius(IOS9以下会导致离屏渲染)，我们可以直接用无透明通道的圆角图片来替换解决，需要UI适配更多背景图片titleLabel.backgroundColor = UIColor.whitetitleLabel.layer.masksToBounds = true 光栅化开启光栅化是通过设置属性shouldRasterize，开启光栅化后CALayer会被保存为bitmap放到缓存中，这样在下次需要时可以直接中缓存中取出来显示，这样节省了渲染时间，例如对于设置有阴影效果的复杂视图会对性能有一定的提升。 1nameLabel.layer.shouldRasterize = true//开启光栅化 同时注意缓存是有大小限制的，所以不要过度是使用光栅化，因为超过缓存大小会导致大量的离屏渲染 离屏渲染Color Offscreen-Rendered Yellow会用黄色标识哪些图层出现了离屏渲染，什么是离屏渲染？离屏渲染表示渲染不是发生在当前屏幕的缓冲区中，而是发生在其他缓冲区的渲染，这就需要开辟更多的缓冲区，等到要用的时候再从其他的缓冲区读取来显示，所以这样会消耗更多的GPU资源，所以避免离屏渲染可以有效的提升显示性能。 设置了以下属性时，都会触发离屏渲染： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 复杂形状设置圆角等（ios8） 渐变 出现离屏渲染的case都应该要注意，所以针对shadow可以通过设置shadowPath来避免，光栅化也应该尽量避免：优化后代码如下： 1234567891011mainImageView.layer.shadowColor = UIColor.black.cgColormainImageView.layer.shadowOpacity = 1mainImageView.layer.shadowRadius = 2// mainImageView.layer.shadowOffset = CGSize(width: 2, height: 2)mainImageView.layer.shadowPath = UIBezierPath.init(roundedRect: mainImageView.bounds, cornerRadius: 2).cgPathsmallImageView.layer.cornerRadius = smallImageView.frame.size.width / 2smallImageView.clipsToBounds = truenameLabel.backgroundColor = UIColor.whitetitleLabel.backgroundColor = UIColor.whitetitleLabel.layer.masksToBounds = truenameLabel.layer.masksToBounds = true]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS响应者链]]></title>
    <url>%2F2019%2F08%2F15%2FiOS%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE%2F</url>
    <content type="text"><![CDATA[事件的响应有两个过程：响应的过程 处理的过程 一起组成了响应者链 响应者(Responder)当我们触控手机屏幕时系统便会将这一操作封装成一个UIEvent放到事件队列里面，然后Application从事件队列取出这个事件，接着需要找到去响应这个事件的最佳视图也就是Responder, 所以开始的第一步应该是找到Responder 1234-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event返回视图层级中能响应触控点的最深视图-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event返回视图是否包含指定的某个点 首先会调用hitTest，然后hitTest会调用pointInside，最终hitTest返回的那个view就是最终的响应者Responder 首先是从UIWindow开始调用hitTest, 然后经过一段导航控制器的视图，因为我们的控制器是在导航控制的，所以可以先忽略这一段，然后来到RootView,调用RootView的hitTest和pointInside,因为点击发生在RootView中所以继续遍历它的子视图，可以看到是从View2开始的，调用View2的hitTest和pointInside，pointInside返回YES，然后继续遍历View2的子视图，从View4开始，因为点击不发生在View4所以pointInside返回NO,而View4没有子视图了，所以返回了nil也就是打印出来的null,然后继续在View2的另外一个子视图View3（目标视图）中调用hitTest和pointInside，因为我们点击的就是View3所以pointInside返回YES,且View3没有子视图所以hitTest返回了自己View3,接着View2的hitTest也返回View3直到UIWindow返回View3, 自此我们找到了响应视图：View3！另外我们看到对其他的Window也有调用，只不过返回了nil。 寻找事件的最佳响应视图是通过对视图调用hitTest和pointInside完成的 hitTest的调用顺序是从UIWindow开始，对视图的每个子视图依次调用，子视图的调用顺序是从后面往前面，也可以说是从显示最上面到最下面 遍历直到找到响应视图，然后逐级返回最终到UIWindow返回此视图 关于最后一个能响应的子视图是因为没有子视图而确定的，这不是唯一确定的条件,因为有些情况下视图可能会被忽略，不会调用hitTest，这与userInteractionEnabled, alpha, frame等有关(不会调用pointinside hittest返回nil)，如果有这种情况响应的是同样位置的最上层可以响应的视图。 与加速度器、陀螺仪、磁力仪相关的运动事件不遵循此响应链，他们是由Core Motion 直接派发的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191203] --UIWindow hitTest2019-08-15 10:48:48.296913+0800 ----UIWindow pointInside2019-08-15 10:48:48.297042+0800 -----UIWindow pointInside return: YES2019-08-15 10:48:48.297139+0800 --UIView hitTest2019-08-15 10:48:48.297264+0800 ----UIView pointInside2019-08-15 10:48:48.297374+0800 -----UIView pointInside return: YES2019-08-15 10:48:48.297485+0800 --UIView hitTest2019-08-15 10:48:48.297595+0800 ----UIView pointInside2019-08-15 10:48:48.297699+0800 -----UIView pointInside return: YES2019-08-15 10:48:48.297810+0800 --View1 hitTest2019-08-15 10:48:48.297927+0800 ----View1 pointInside2019-08-15 10:48:48.298034+0800 -----View1 pointInside return: NO2019-08-15 10:48:48.298143+0800 ---View1 hitTest return: (null)2019-08-15 10:48:48.298266+0800 --View2 hitTest2019-08-15 10:48:48.298481+0800 ----View2 pointInside2019-08-15 10:48:48.298699+0800 -----View2 pointInside return: YES2019-08-15 10:48:48.298898+0800 --View4 hitTest2019-08-15 10:48:48.299120+0800 ---View4 hitTest return: (null)2019-08-15 10:48:48.367997+0800 --View3 hitTest2019-08-15 10:48:48.368138+0800 ----View3 pointInside2019-08-15 10:48:48.368222+0800 -----View3 pointInside return: YES2019-08-15 10:48:48.368317+0800 ---View3 hitTest return: View32019-08-15 10:48:48.368395+0800 ---View2 hitTest return: View32019-08-15 10:48:48.368483+0800 ---UIView hitTest return: View32019-08-15 10:48:48.368559+0800 ---UIView hitTest return: View32019-08-15 10:48:48.368637+0800 ---UIWindow hitTest return: View32019-08-15 10:48:48.368758+0800 --UIStatusBarWindow hitTest2019-08-15 10:48:48.368859+0800 ----UIStatusBarWindow pointInside2019-08-15 10:48:48.368952+0800 -----UIStatusBarWindow pointInside return: YES2019-08-15 10:48:48.369043+0800 --UIStatusBar_Modern hitTest2019-08-15 10:48:48.369159+0800 ----UIStatusBar_Modern pointInside2019-08-15 10:48:48.369238+0800 -----UIStatusBar_Modern pointInside return: NO2019-08-15 10:48:48.369351+0800 ---UIStatusBar_Modern hitTest return: (null)2019-08-15 10:48:48.369549+0800 ---UIStatusBarWindow hitTest return: UIStatusBarWindow2019-08-15 10:48:48.369872+0800 --UIWindow hitTest2019-08-15 10:48:48.369978+0800 ----UIWindow pointInside2019-08-15 10:48:48.370064+0800 -----UIWindow pointInside return: YES2019-08-15 10:48:48.370183+0800 --UIView hitTest2019-08-15 10:48:48.370337+0800 ----UIView pointInside2019-08-15 10:48:48.370467+0800 -----UIView pointInside return: YES2019-08-15 10:48:48.370594+0800 --UIView hitTest2019-08-15 10:48:48.370787+0800 ----UIView pointInside2019-08-15 10:48:48.370941+0800 -----UIView pointInside return: YES2019-08-15 10:48:48.371095+0800 --View1 hitTest2019-08-15 10:48:48.371247+0800 ----View1 pointInside2019-08-15 10:48:48.371364+0800 -----View1 pointInside return: NO2019-08-15 10:48:48.371542+0800 ---View1 hitTest return: (null)2019-08-15 10:48:48.371626+0800 --View2 hitTest2019-08-15 10:48:48.371807+0800 ----View2 pointInside2019-08-15 10:48:48.371909+0800 -----View2 pointInside return: YES2019-08-15 10:48:48.372087+0800 --View4 hitTest2019-08-15 10:48:48.372279+0800 ---View4 hitTest return: (null)2019-08-15 10:48:48.372473+0800 --View3 hitTest2019-08-15 10:48:48.372709+0800 ----View3 pointInside2019-08-15 10:48:48.372927+0800 -----View3 pointInside return: YES2019-08-15 10:48:48.373173+0800 ---View3 hitTest return: View32019-08-15 10:48:48.373349+0800 ---View2 hitTest return: View32019-08-15 10:48:48.373510+0800 ---UIView hitTest return: View32019-08-15 10:48:48.373684+0800 ---UIView hitTest return: View32019-08-15 10:48:48.373864+0800 ---UIWindow hitTest return: View3.279208+0800 --UIWindow hitTest.279372+0800 ----UIWindow pointInside.279468+0800 -----UIWindow pointInside return: YES.279544+0800 --UIView hitTest.279611+0800 ----UIView pointInside.279711+0800 -----UIView pointInside return: YES.279790+0800 --UIView hitTest.279899+0800 ----UIView pointInside.279995+0800 -----UIView pointInside return: YES.280106+0800 --View1 hitTest.280191+0800 ----View1 pointInside.280309+0800 -----View1 pointInside return: NO.280418+0800 ---View1 hitTest return: (null).280706+0800 --View2 hitTest.280835+0800 ----View2 pointInside.280975+0800 -----View2 pointInside return: YES.281151+0800 --View4 hitTest.281276+0800 ---View4 hitTest return: (null).281380+0800 --View3 hitTest.281502+0800 ----View3 pointInside.281659+0800 -----View3 pointInside return: NO.281831+0800 ---View3 hitTest return: (null).281987+0800 ---View2 hitTest return: View2.282147+0800 ---UIView hitTest return: View2.300007+0800 ---UIView hitTest return: View2.300279+0800 ---UIWindow hitTest return: View2.300569+0800 --UIStatusBarWindow hitTest.300688+0800 ----UIStatusBarWindow pointInside.300797+0800 -----UIStatusBarWindow pointInside return: YES.300942+0800 --UIStatusBar_Modern hitTest.301047+0800 ----UIStatusBar_Modern pointInside.301128+0800 -----UIStatusBar_Modern pointInside return: NO.301256+0800 ---UIStatusBar_Modern hitTest return: (null).301369+0800 ---UIStatusBarWindow hitTest return: UIStatusBarWindow.301705+0800 --UIWindow hitTest.301893+0800 ----UIWindow pointInside.302068+0800 -----UIWindow pointInside return: YES.302274+0800 --UIView hitTest.302391+0800 ----UIView pointInside.302514+0800 -----UIView pointInside return: YES.302625+0800 --UIView hitTest.302742+0800 ----UIView pointInside.302870+0800 -----UIView pointInside return: YES.302983+0800 --View1 hitTest.303096+0800 ----View1 pointInside.303199+0800 -----View1 pointInside return: NO.303298+0800 ---View1 hitTest return: (null).303458+0800 --View2 hitTest.303684+0800 ----View2 pointInside.303832+0800 -----View2 pointInside return: YES.304037+0800 --View4 hitTest.304190+0800 ---View4 hitTest return: (null).304341+0800 --View3 hitTest.304530+0800 ----View3 pointInside.304667+0800 -----View3 pointInside return: NO.304810+0800 ---View3 hitTest return: (null).304980+0800 ---View2 hitTest return: View2.305165+0800 ---UIView hitTest return: View2.305295+0800 ---UIView hitTest return: View2.305528+0800 ---UIWindow hitTest return: View2 处理者如果某个Responder没处理事件，事件会被传递，UIResponder都有一个nextResponder属性，此属性会返回在Responder Chain中的下一个事件处理者，如果每个Responder都不处理事件，那么事件将会被丢弃。所以继承自UIResponder的子类便会构成一条响应者链，所以我们可以打印下以View4为开始的响应者链是什么样的： 12345678UIResponder *nextResponder = self.view4.nextResponder;NSMutableString *pre = [NSMutableString stringWithString:@&quot;--&quot;];NSLog(@&quot;View3&quot;);while (nextResponder) &#123; NSLog(@&quot;%@%@&quot;, pre, NSStringFromClass([nextResponder class])); [pre appendString:@&quot;--&quot;]; nextResponder = nextResponder.nextResponder;&#125; 找到最适合的响应视图后事件会从此视图开始沿着响应链nextResponder传递，直到找到处理事件的视图,如果没有处理的事件会被丢弃。 如果视图有父视图则nextResponder指向父视图，如果是根视图则指向控制器，最终指向AppDelegate, 他们都是通过重写nextResponder来实现。 拓展从上面的演示可以推理出 如果姿势图超出了父视图的点击区域 那么父视图的pointInside return: NO hitTest return: (null) 就不会继续往下面找返回的就是父视图的父视图 不规则图形的点击实现重写pointInside 12345678- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&#123; const CGFloat halfWidth = 100; CGFloat xOffset = point.x - 100; CGFloat yOffset = point.y - 100; CGFloat radius = sqrt(xOffset * xOffset + yOffset * yOffset); return radius &lt;= halfWidth;&#125; 结论UIApplication对象维护着自己的一个响应者栈，当pointInSide: withEvent:返回yes的时候，响应者入栈。hitTest方法判断当前视图是否还有子视图 如果有就继续往下查找 没有的话 说明当前视图就是要找的响应视图 Runloop层经理了什么当一个触摸事件发生后首先是由IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收，然后SpringBoard会通过match port将事件转发给我们是App进程，然后触发App注册在RunLoop中的Source1来处理事件，Source1会触发__IOHIDEventSystemClientQueueCallback回调，回调后又会触发Source0，再后面就是UIApplication从事件队列取出事件派发 iOS开发 - 事件传递响应链]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS生成二维码]]></title>
    <url>%2F2019%2F08%2F15%2FiOS%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132/** 根据字符串生成指定颜色大小的黑白二维码 */+ (UIImage *)wl_createQRImageWithString:(NSString *)string bgColor:(UIColor *)bgColor contentColor:(UIColor *)ctColor size:(CGSize)size&#123; NSData *stringData = [string dataUsingEncoding:NSUTF8StringEncoding]; CIFilter *qrFilter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;]; [qrFilter setValue:stringData forKey:@&quot;inputMessage&quot;]; /** inputCorrectionLevel 等级 容错率 L 7% M 15% 默认值 Q 25% H 30% */ [qrFilter setValue:@&quot;M&quot; forKey:@&quot;inputCorrectionLevel&quot;]; // 颜色滤镜 CIFilter *colorFilter = [CIFilter filterWithName:@&quot;CIFalseColor&quot; keysAndValues:@&quot;inputImage&quot;, qrFilter.outputImage,@&quot;inputColor0&quot;,ctColor?[CIColor colorWithCGColor:ctColor.CGColor]:[CIColor colorWithCGColor:[UIColor blackColor].CGColor],@&quot;inputColor1&quot;,bgColor?[CIColor colorWithCGColor:bgColor.CGColor]:[CIColor colorWithCGColor:[UIColor whiteColor].CGColor],nil]; CIImage *qrImage = colorFilter.outputImage; //放大并绘制二维码 (上面生成的二维码很小，需要放大) CGImageRef cgImage = [[CIContext contextWithOptions:nil] createCGImage:qrImage fromRect:qrImage.extent]; UIGraphicsBeginImageContext(size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetInterpolationQuality(context, kCGInterpolationNone); //翻转一下图片 不然生成的QRCode就是上下颠倒的 CGContextScaleCTM(context, 1.0, -1.0); CGContextDrawImage(context, CGContextGetClipBoundingBox(context), cgImage); UIImage *codeImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); CGImageRelease(cgImage); return codeImage;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[KVO的内部实现]]></title>
    <url>%2F2019%2F08%2F13%2FKVO%E7%9A%84%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[KVO的使用 添加观察 1- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; 属性变化回调 1- (void)observeValueForKeyPath:(nullable NSString *)keyPath ofObject:(nullable id)object change:(nullable NSDictionary&lt;NSKeyValueChangeKey, id&gt; *)change context:(nullable void *)context; 移除观察者 12- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context API_AVAILABLE(macos(10.7), ios(5.0), watchos(2.0), tvos(9.0));- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; KVO的内部实现原理 通过控制台输出可以看出kvo内部是动态创建了监听对象的子类出来 NSKVONotifying_+类名 1234567A * a = [[A alloc] init];[a setName:@&quot;qwe&quot;];[a addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];(lldb) po object_getClassName(a)&quot;A&quot;(lldb) po object_getClassName(a)&quot;NSKVONotifying_A&quot; 内部还做了什么 1234567(lldb) po [a methodForSelector:@selector(setName:)](TTTTTT`-[A setName:] at A.h:14)(lldb) po [a methodForSelector:@selector(setName:)](Foundation`_NSSetObjectValueAndNotify)(lldb) 发现方法实现变了，内部调用了系统Foundation框架下的_NSSetObjectValueAndNotify方法。那么这个框架内部又是怎么实现的呢，我们可以下断点，查看下函数调用栈： 123456#0 0x0000000103a1f21c in -[ViewController observeValueForKeyPath:ofObject:change:context:] at /Users/lwj/Desktop/TTTTTT/TTTTTT/ViewController.m:159#1 0x0000000103d7afeb in NSKeyValueNotifyObserver ()#2 0x0000000103d7e696 in NSKeyValueDidChange ()#3 0x0000000103d7df85 in -[NSObject(NSKeyValueObservingPrivate) _changeValueForKeys:count:maybeOldValuesDict:maybeNewValuesDict:usingBlock:] ()#4 0x0000000103d7e8ad in -[NSObject(NSKeyValueObservingPrivate) _changeValueForKey:key:key:usingBlock:] ()#5 0x0000000103d78739 in _NSSetObjectValueAndNotify () 简化成OC的伪代码大致如下： 12345678910111213- (void)setName:(NSString *)name&#123; _NSSetObjectValueAndNotify();&#125;void _NSSetObjectValueAndNotify &#123; [self willChangeValueForKey:@&quot;name&quot;]; [super setName:name]; [self didChangeValueForKey:@&quot;name&quot;];&#125;- (void)didChangeValueForKey:(NSString *)key&#123; [observe observeValueForKeyPath:key ofObject:self change:nil context:nil];&#125; runtime打印NSKVONotifying_A重写了那些方法 1234567891011unsigned int count;Method *methods = class_copyMethodList(object_getClass(a), &amp;count);for (NSInteger i=0;i&lt; count; i++) &#123; Method *met = methods[i]; NSLog(@&quot;===%@&quot;,NSStringFromSelector(method_getName(met)));&#125;2019-08-13 13:01:08.595571+0800 TTTTTT[60128:4304199] ===setName:2019-08-13 13:01:08.596093+0800 TTTTTT[60128:4304199] ===class2019-08-13 13:01:08.596315+0800 TTTTTT[60128:4304199] ===dealloc2019-08-13 13:01:08.596409+0800 TTTTTT[60128:4304199] ===_isKVOA 简单分析下重写这些方法的作用：class：重写这个方法，是为了伪装苹果自动为我们生成的中间类。dealloc：应该是处理对象销毁之前的一些收尾工作哈_isKVOA：告诉系统使用了kvo 动态注册类 12345678// 创建类Class customClass = objc_allocateClassPair([NSObject class], &quot;AClass&quot;, 0);// 添加实例变量class_addIvar(customClass, &quot;name&quot;, sizeof(int), 0, &quot;i&quot;);// 添加方法class_addMethod(customClass, @selector(text), (IMP)test, &quot;V@:&quot;);// 注册到运行时环境objc_registerClassPair(customClass); 自己实现一个KVO 123456789101112131415161718192021222324252627282930313233343536373839///NSObject的类别#import &quot;NSObject+KVO.h&quot;#import &lt;objc/message.h&gt;#import &lt;objc/runtime.h&gt;@implementation NSObject (KVO)- (void)wj_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context&#123; NSString *originClassName = NSStringFromClass([self class]); NSString *newClassName = [@&quot;WJKVO_&quot; stringByAppendingString:originClassName]; const char *newName = [newClassName UTF8String]; // 继承自当前类，创建一个子类 此时的self是调用当前方法的类 Class kvoClass = objc_allocateClassPair([self class], newName, 0); // 添加setter方法 class_addMethod(kvoClass, @selector(setName:), (IMP)setName, &quot;v@:@&quot;); //注册新添加的这个类 objc_registerClassPair(kvoClass); // 修改isa指针，由A指向WJKVO_A 这样之后用a对象调方法 实际上走的是 我们新建的子类的方法 object_setClass(self, kvoClass); // 保存观察者属性到当前类中 objc_setAssociatedObject(self, (__bridge const void *)@&quot;observer&quot;, observer, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;#pragma mark - 重写父类方法void setName(id self, SEL _cmd, NSString *name) &#123; // 保存当前KVO的类 Class kvoClass = [self class]; // 将self的isa指针指向父类A，调用父类setter方法 object_setClass(self, class_getSuperclass([self class])); // 调用父类setter方法，重新复制 objc_msgSend(self, @selector(setName:), name); // 取出WJKVO_A观察者 id objc = objc_getAssociatedObject(self, (__bridge const void *)@&quot;observer&quot;); // 通知观察者，执行通知方法 并且传对应的参数 objc_msgSend(objc, @selector(observeValueForKeyPath:ofObject:change:context:),name,self,@&#123;@&quot;aa&quot;:@&quot;ss&quot;&#125;,nil); // 重新修改为WJKVO_A类 object_setClass(self, kvoClass);&#125;@end 浅谈FBKVOController 可以看到他是做了一层嫁接 把需要释放的东西都放在了FBKVOController的dealloc里面 pthread_mutex：这是一种超级易用的互斥锁，使用的时候，只需要初始化一个 pthread_mutex_t，用 pthread_mutex_lock 来锁定， pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。 1234567891011121314151617181920212223242526272829//1、+ (instancetype)controllerWithObserver:(nullable id)observer&#123; return [[self alloc] initWithObserver:observer];&#125;//2、初始化observer，并依据retainObserved值决定内存策略- (instancetype)initWithObserver:(nullable id)observer retainObserved:(BOOL)retainObserved&#123; self = [super init]; if (nil != self) &#123; _observer = observer; NSPointerFunctionsOptions keyOptions = retainObserved ? NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPointerPersonality : NSPointerFunctionsWeakMemory|NSPointerFunctionsObjectPointerPersonality; _objectInfosMap = [[NSMapTable alloc] initWithKeyOptions:keyOptions valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0]; //初始化互斥锁 pthread_mutex_init(&amp;_lock, NULL); &#125; return self;&#125;//3、- (instancetype)initWithObserver:(nullable id)observer&#123; return [self initWithObserver:observer retainObserved:YES];&#125;//4、在dealloc注销所有监听并且销毁上面的互斥锁- (void)dealloc&#123; [self unobserveAll]; pthread_mutex_destroy(&amp;_lock);&#125; 可以看到把监听对象作为key 存的info信息作为值存在了_objectInfosMap里面 相应的block回调等信息都从info里面取 如果需要销毁也通过_objectInfosMap销毁对应的信息 个人感觉 这应该是一种投机取巧的思想 我自己害怕出问题 然后我自己就不去干这个而是让另一个人（主业的 不容易出问题）去做 NSHashTable和NSMapTable对于NSSet，object是强引用的，和NSDictionary中的value是一样的。而NSDictionary中的key则是copy的，因此当开发者想要使NSSet的objects或者NSDictionary的values为weak，或者NSDictionary使用没有实现协议的对象作为key时，比较麻烦（需要使用NSValue的方法valueWithNonretainedObject） NSDictionary 的局限性 NSDictionary 提供了 key -&gt; object 的映射。从本质上讲，NSDictionary 中存储的 object 位置是由 key 来索引的。 由于对象存储在特定位置，NSDictionary 中要求 key 的值不能改变（否则 object 的位置会错误）。为了保证这一点，NSDictionary 会始终复制 key 到自己私有空间。 这个 key 的复制行为也是 NSDictionary 如何工作的基础，但这也有一个限制：你只能使用 OC 对象作为 NSDictionary 的 key，并且必须支持 NSCopying 协议。此外，key 应该是小且高效的，以至于复制的时候不会对 CPU 和内存造成负担。 这意味着，NSDictionary 中真的只适合将值类型的对象作为 key（如简短字符串和数字）。并不适合自己的模型类来做对象到对象的映射。 对象到对象的映射 NSMapTable（顾名思义）更适合于一般来说的映射概念。这取决于它的设计方式，NSMapTable 可以处理的 key -&gt; obj 式映射如 NSDictionary，但它也可以处理 obj -&gt; obj 的映射 - 也被称为 “关联数组” 或简称为 “map”。 比如一个 NSMapTable 的构造如下： 1NSMapTable *mapTable = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory]; 这将会和 NSMutableDictionary 用起来一样一样的，复制 key，并对它的 object 引用计数 +1。一个真正的对象到对象(object-to-object)的映射可以构造如下： 1NSMapTable *mapTable = [NSMapTable strongToStrongObjectsMapTable]; 如果想要将teacher对象作为key，则需要让Teacher类遵循NSCopying协议，而且NSDictionary/NSMutable使用hash表来实现key和value之间的映射和存储，所以作为key值的类型必须重写++- (NSUInteger)hash++和 ++- (BOOL)isEqual:(id)object++两个方法，其中hash方法计算该对象的hash值，hash值决定该对象在hash表中存储的位置，isEqual方法通过hash值来定位对象在hash表中的位置。具体代码如下: 12345678910111213141516171819202122// Teacher.m@implementation Teacher- (id)copyWithZone:(NSZone *)zone&#123; Teacher *teacher = [[Teacher allocWithZone:zone] init]; teacher.name = self.name; teacher.age = self.age; return teacher;&#125;- (BOOL)isEqual:(id)object&#123; // 比较hash值是否相等 return [self hash] == [object hash];&#125;- (NSUInteger)hash&#123; // 调用父类的hash方法，也可以自定义 return [super hash];&#125;]]></content>
      <tags>
        <tag>KVO,iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发的之RunTime]]></title>
    <url>%2F2019%2F08%2F12%2FiOS%E5%BC%80%E5%8F%91%E7%9A%84%E4%B9%8BRunTime%2F</url>
    <content type="text"><![CDATA[创建NSObject分类 重写 +(void)load 12345678#pragma mark -- 数组越界protect exchangeMethod(objc_getClass(&quot;__NSArrayI&quot;), NSSelectorFromString(@&quot;objectAtIndex:&quot;), NSSelectorFromString(@&quot;iris_objectAtIndex:&quot;)); exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), NSSelectorFromString(@&quot;objectAtIndex:&quot;), NSSelectorFromString(@&quot;irisM_objectAtIndex:&quot;));#pragma mark -- 容器 nil protect exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(addObject:), NSSelectorFromString(@&quot;iris_addObject:&quot;)); exchangeMethod(objc_getClass(&quot;__NSArrayM&quot;), @selector(insertObject:atIndex:), NSSelectorFromString(@&quot;iris_insertObject:atIndex:&quot;)); 方法替换 12345678910void exchangeMethod(Class class ,SEL originalSelector, SEL swizzlingSelector) &#123; Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzlingMethod = class_getInstanceMethod(class, swizzlingSelector); BOOL isAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzlingMethod), method_getTypeEncoding(swizzlingMethod)); if (isAddMethod) &#123; class_replaceMethod(class, swizzlingSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125;else &#123; method_exchangeImplementations(originalMethod, swizzlingMethod); &#125;&#125; NSMutableArray、NSArray的分类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667@interface NSArray (IRISExtension)@end@implementation NSArray (IRISExtension)- (id)iris_objectAtIndex:(NSInteger) index &#123; if (self.count - 1 &lt; index) &#123; @try &#123; return [self iris_objectAtIndex:index]; &#125; @catch(NSException *exception) &#123; NSLog(@&quot;%s Crash Because Method %s&quot;,class_getName([self class]), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; &#125; @finally &#123; &#125; &#125;else &#123; return [self iris_objectAtIndex:index]; &#125;&#125;;@end@interface NSMutableArray (IRISExtension)@end@implementation NSMutableArray (IRISExtension)- (id)irisM_objectAtIndex:(NSInteger) index &#123; if (self.count - 1 &lt; index || self.count == nil) &#123; @try &#123; return [self irisM_objectAtIndex:index]; &#125; @catch(NSException *exception) &#123; NSLog(@&quot;%s Crash Because Method %s&quot;,class_getName([self class]), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; &#125; @finally &#123; &#125; &#125;else &#123; return [self irisM_objectAtIndex:index]; &#125;&#125;;- (void)iris_addObject:(id)anObject&#123; if (!anObject) &#123; return; &#125; [self iris_addObject:anObject];&#125;- (void)iris_insertObject:(id)anObject atIndex:(NSUInteger) index &#123; if (!anObject) &#123; return; &#125; [self iris_insertObject:anObject atIndex:index];&#125;@end 未识别消息的转发也在NSObject的分类中实现12345678910111213141516171819202122232425262728293031323334353637383940414243- (id)forwardingTargetForSelector:(SEL)aSelector &#123;#pragma mark ----- 未识别方法 unRecognizedSelector Protect NSString *methodName = NSStringFromSelector(aSelector); NSString *oriClassName = NSStringFromClass([self class]); if ([self isKindOfClass:NSClassFromString(@&quot;UITextInputController&quot;)] || [NSStringFromClass([self class]) hasPrefix:@&quot;UIKeyboard&quot;] || [methodName isEqualToString:@&quot;dealloc&quot;]) &#123; return nil; &#125; if ([oriClassName hasPrefix:@&quot;_&quot;] &amp;&amp; ![oriClassName containsString:@&quot;__NSArray&quot;])&#123; // 过滤可变数组和不可变数组 return nil; &#125; NSLog(@&quot;**********************************************************************&quot;); NSLog(@&quot;** [%@ class] :unRecognizedSelector: %@ **&quot;,NSStringFromClass([self class]), NSStringFromSelector(aSelector)); NSLog(@&quot;**********************************************************************&quot;); NSString *className = [NSString stringWithFormat:@&quot;IRISBase%@&quot;,oriClassName]; className = [className stringByReplacingOccurrencesOfString:@&quot;_&quot; withString:@&quot;&quot;]; Class originalClass = object_getClass([IRISObject class]); Method classMethod = class_getInstanceMethod(originalClass, @selector(baseMethod:)); const char *types = method_getTypeEncoding(classMethod); IMP baseImp = method_getImplementation(classMethod); class_addMethod([IRISObject class], aSelector, baseImp, types); u_int count = 0; Method *methodList = class_copyMethodList([IRISObject class], &amp;count); for (int i = 0; i &lt; count; i ++) &#123; Method method = methodList[i]; SEL aSel = method_getName(method); DLog(@&quot;类名:%@ 方法器:%@&quot;,NSStringFromClass([IRISObject class]) ,NSStringFromSelector(aSel)); &#125; return [IRISObject new];&#125; 注意点要对键盘相关和textfiled相关的做不处理判断 三步消息转发12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * 第一步 实例方法专用 方法解析 **/+ (BOOL)resolveInstanceMethod:(SEL)sel&#123; NSLog(@&quot;%@&quot;,NSStringFromSelector(sel)); if(sel == @selector(DoThings:Num:))&#123; class_addMethod([self class], sel, (IMP)MyMethodIMP, &quot;v@:&quot;); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;/* * 第二步 如果第一步未处理，那么让别的对象去处理这个方法 **/-(id)forwardingTargetForSelector:(SEL)aSelector&#123; if([NSStringFromSelector(aSelector) isEqualToString:@&quot;DoThings:Num:&quot;])&#123; return [[Tools alloc]init]; &#125; return [super forwardingTargetForSelector:aSelector];&#125;/* * 第三步 如果前两步未处理，这是最后处理的机会将目标函数以其他形式执行 **/-(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; NSString *SelStr = NSStringFromSelector(aSelector); if([SelStr isEqualToString:@&quot;DoThings:Num:&quot;])&#123; [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;]; &#125; return [super methodSignatureForSelector:aSelector];&#125;-(void)forwardInvocation:(NSInvocation *)anInvocation&#123; //改变消息接受者对象 [anInvocation invokeWithTarget:[[Tools alloc]init]]; //改变消息的SEL anInvocation.selector = @selector(flyGame); [anInvocation invokeWithTarget:self];&#125;- (void)flyGame&#123; NSLog(@&quot;我要飞翔追逐梦想！&quot;);&#125; 字典转模型123456789101112131415161718192021222324+ (instancetype)GG_initWithDictionaryForModel:(NSDictionary *)dic&#123; id myObj = [[self alloc] init]; unsigned int outCount; //获取类中的所有成员属性 objc_property_t *arrPropertys = class_copyPropertyList([self class], &amp;outCount); for (NSInteger i = 0; i &lt; outCount; i ++) &#123; //获取属性名字符串 objc_property_t property = arrPropertys[i]; //model中的属性名 NSString *propertyName = [NSString stringWithUTF8String:property_getName(property)]; id propertyValue = dic[propertyName]; if (propertyValue != nil) &#123; [myObj setValue:propertyValue forKey:propertyName]; &#125; &#125; //注意在runtime获取属性的时候，并不是ARC Objective-C的对象所有需要释放 free(arrPropertys); return myObj;&#125; 参考]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发的内存|循环引用问题]]></title>
    <url>%2F2019%2F08%2F08%2FiOS%E5%BC%80%E5%8F%91%E7%9A%84%E5%86%85%E5%AD%98-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[我们知道oc存储主要分成数据区、堆区和栈区， 循环引用B控制器中有block属性 A跳转B 并且在A中实现B的block 并调用了self属性 如果A持有了B那么此时就造成循环引用 因为A持有了B 并且B的block中持有了self（A）这样就无法执行dealloc 方法造成循环引用（self是一个指向实例对象的指针，它的生命周期至少是伴随着当前的实例对象的） 有时候B中的block会在B之后销毁 那么就需要用__strong修饰weakSelf 虽然此时也是强引用 但是strongSelf只是局部变量 他的作用域仅限于局部代码，而程序一旦跳出作用域，strongSelf就会被释放，这个临时产生的“循环引用”就会被自动打破 接下来self就会被销毁 weak关键字123456789case OPERATION_retain: CFBasicHashAddValue( table, obj ); return obj;case OPERATION_retainCount: count = CFBasicHashGetCountOfKey( table, obj ); return count;case OPERATION_release: count = CFBasicHashRemoveValue( table, obj ); return 0 == count; Objective-C高级编程：iOS与OS X多线程和内存管理 局部变量的销毁时机在 ARC下，方法会自动调用 -autorelease 方法。调用后，该变量会被添加到自动释放池。在主线程中，临时变量会在 runloop 运行结束时释放。在非主线程中，临时变量会在 线程退出时释放。所以，当有大量的临时对象时，官方建议我们使用 @autoreleasepool 进行内存管理 123456789101112131415161718192021for (NSInteger i = 0;i &lt; 50000; i++) &#123; @autoreleasepool &#123; NSString *fileContents = @&quot;test&quot;; NSLog(@&quot;%@&quot;,fileContents); /* Process the string, creating and autoreleasing more objects. */ &#125;&#125;__NSCFString, 0x600002b690b02019-08-09 12:00:58.910312+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695efbf4===12019-08-09 12:00:58.910380+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb8695debf7===112019-08-09 12:00:58.910443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebb86a4debf6===1112019-08-09 12:00:58.910529+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1ebbb7a4debf1===11112019-08-09 12:00:58.910611+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b1e8ab7a4debf0===111112019-08-09 12:00:58.910698+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b2f8ab7a4debf3===1111112019-08-09 12:00:58.910832+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbaa2f8ab7a4debf2===11111112019-08-09 12:00:58.914443+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb9b675c18ec0810d===111111112019-08-09 12:00:58.914550+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb85675c18ec0810c===1111111112019-08-09 12:00:58.914625+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xb98c04c3b7a9450f===11111111112019-08-09 12:00:58.914713+0800 TTTTTT[15263:1321694] NSTaggedPointerString, 0xbe0c04c3b7a9450e===111111111112019-08-09 12:00:58.914783+0800 TTTTTT[15263:1321694] __NSCFString, 0x600002525220===111111111111 栈对象和堆对象在栈上创建对象是非常快的，因为很多东西在编译时就确定了，运行时分配空间几乎不耗时；相对而言在堆上创建对象就非常耗时。栈对象的生命周期是确定的，对象出栈以后就会被释放，不会存在内存泄漏，但这同时也是栈对象的最大缺点。Objective-C 变量有效范围是由 “{}” 包含的块来决定的，也就是说栈对象的生命周期仅限于其所在的块里，出了块立马会被释放。一个对象被创建以后有可能会通过方法调用传递到别的方法，当栈对象的创建方法返回时，栈对象会被一起 pop 出栈而释放，导致其没法在别处被继续持有。此时 retain 操作会失效，除非用 copy 方法在想持有该栈对象的地方重新拷贝一份属于自己的栈对象(block). Tagged Pointer 我们也可以在WWDC2013的《Session 404 Advanced in Objective-C》视频中，看到苹果对于Tagged Pointer特点的介绍：Tagged Pointer专门用来存储小的对象，例如NSNumber和NSDate Tagged Pointer指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。所以，它的内存并不存储在堆中，也不需要malloc和free。 在内存读取上有着3倍的效率，创建时比以前快106倍。由此可见，苹果引入Tagged Pointer，不但减少了64位机器下程序的内存占用，还提高了运行效率。完美地解决了小内存对象在存储和访问效率上的问题。 浪费内存假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。所以一个普通的iOS程序，如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍 效率问题为了存储和访问一个NSNumber对象，我们需要在堆上为其分配内存，另外还要维护它的引用计数，管理它的生命期。这些都给程序增加了额外的逻辑，造成运行效率上的损失。 问题Tagged Pointer的引入也带来了问题，即Tagged Pointer因为并不是真正的对象，而是一个伪对象，所以你如果完全把它当成对象来使，可能会让它露马脚。所有对象都有 isa指针，而Tagged Pointer其实是没有的，因为它不是真正的对象。 因为不是真正的对象，所以不能访问isa 为了改进上面提到的内存占用和效率问题，苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以我们可以将一个对象的指针拆成两部分，一部分直接保存数据，另一部分作为特殊标记，表示这是一个特别的指针，不指向任何一个地址。参考Tagged Pointer字符串Tagged Pointer字面量(Literal)]]></content>
  </entry>
  <entry>
    <title><![CDATA[swift开发之算法]]></title>
    <url>%2F2019%2F08%2F05%2Fswift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序123456789101112func sort(_ list: inout [Int],_ n: Int) &#123; if n&lt;=1 &#123;return&#125; for i in 0..&lt;n &#123; for j in 0..&lt;n-i-1 &#123; if list[i] &gt; list[j+1] &#123; list.swapAt(j, j+1) print(j) &#125; &#125; &#125;&#125; 插入排序123456789101112131415161718192021222324*///class InsertSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var j = 0 // 每次取出后面未排序的数组的第一个值 与前面有序数组的进行比较 插入到相应的位置 for i in 1 ..&lt; list.count &#123; j = i while j &gt; 0 &#123; if list[j] &lt; list[j-1] &#123; list.swapAt(j-1, i) j = j - 1 &#125;else&#123; // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环 break &#125; &#125; &#125; return list &#125;&#125; 选择排序12345678910111213141516171819202122232425262728293031// 选择排序 // 时间复杂度永远是n*n func chooseSort(_ list: inout [Int], _ n: Int) &#123; // 数组长度大于一才排序 if n &lt;= 1 &#123; return &#125; var min = 0 var index = 0// 为false，断言被触发，终止应用。// 当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：//// 整数类型的下标索引被传入一个自定义小标实现，但是下标索引值可能太小或者太大// 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行// 一个可选值现在是nil，但是后面的代码运行需要一个非nil值 assert(index != -1, &quot;A person&apos;s age cannot be less than zero&quot;) for i in 0 ..&lt; n &#123; min = list[i] index = i for j in i ..&lt; n &#123; // 每次找到未排序数字的最小值 if list[j] &lt; min &#123; // 如果找到一个比min小的值 就赋值给min 并且记录这个值的索引 直到这层循环结束 找到的就是最小的 min = list[j] index = j &#125; &#125; // 找到最小值之后放在前面（已经排序数组的最后面） list.swapAt(i, index) &#125; &#125; 希尔排序 希尔排序（把数组通过步长（step）分成 n/step个小数组数组，再分别对这些小数组进行插入排序，直到步长等于0结束） [2,35,56,767,989,0,45,345] [0,4][1,5],[2,6],[3,7] [0,2,4,6][1,3,5,7] [0,1,2,3,4,5,6,7] 123456789101112131415161718192021222324class ShellSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var step = list.count / 2 var j = 0 // 步长等于0结束 while step &gt; 0 &#123; for i in step ..&lt; list.count &#123; j = i while j &gt;= step &#123; if list[j] &lt; list[j-step] &#123; list.swapAt(j-step, j) j = j - step &#125;else&#123; // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环 break &#125; &#125; &#125; step = step / 2 //缩小步长 &#125; return list &#125;&#125; 归并排序 分而治之的思想 先把整体分割成n个只有一个数据数组 这时候是有序的 将这些有序的数组两两结合成有序数组 重复上面的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MergeSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; // 拆分一个数组 为n个有序数组 放在一个大数组里面 var totalArr: Array&lt;Array&lt;Int&gt;&gt; = [] for item in list &#123; var subArray: Array&lt;Int&gt; = [] subArray.append(item) totalArr.append(subArray) &#125; // 重复拆分工作 直到就剩一个数组 while totalArr.count != 1 &#123; // 每次走完一遍 重新从0开始 var i = 0 while i &lt; totalArr.count - 1 &#123; // 两两合并 totalArr[i] = mergeArray(firstList: totalArr[i], secondList: totalArr[i+1]) totalArr.remove(at: i + 1) i = i + 1 &#125; &#125; return totalArr[0] &#125; // 合并两个有序数组 func mergeArray(firstList: Array&lt;Int&gt;, secondList: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var resultList: Array&lt;Int&gt; = [] var firstIndex = 0 var secondIndex = 0 while firstIndex &lt; firstList.count &amp;&amp; secondIndex &lt; secondList.count &#123; if firstList[firstIndex] &lt; secondList[secondIndex] &#123; resultList.append(firstList[firstIndex]) firstIndex = firstIndex + 1 &#125;else&#123; resultList.append(secondList[secondIndex]) secondIndex = secondIndex + 1 &#125; &#125; // 如果其中一个数组还有数据没有放进结果数组里面 就把剩下的放进去 while firstIndex &lt; firstList.count &#123; resultList.append(firstList[firstIndex]) firstIndex = firstIndex + 1 &#125; while secondIndex &lt; secondList.count &#123; resultList.append(secondList[secondIndex]) secondIndex = secondIndex + 1 &#125; return resultList &#125;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839// 分而治之的思想 func quickSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let left = array.filter&#123; $0 &lt; pivot &#125; let middle = array.filter&#123; $0 == pivot &#125; let right = array.filter&#123; $0 &gt; pivot &#125; return quickSort(left) + middle + quickSort(right) &#125;// 降低空间复杂度的快排 func quickSortPro(_ array: inout [Int], _ n: Int) &#123; quickSortC(&amp;array, 0, n-1) &#125; func quickSortC(_ array: inout [Int], _ left: Int, _ right: Int) &#123; if left &gt; right &#123; return &#125; let pivot = partition(&amp;array, left, right) quickSortC(&amp;array, left, pivot - 1) quickSortC(&amp;array, pivot + 1, right) &#125; func partition(_ array: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123; let pivot = array[right] var i = left for j in left ..&lt; right &#123; if array[j] &lt; pivot &#123; array.swapAt(j, i) i = i + 1 &#125; &#125; array.swapAt(i, right) return i &#125; 桶排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class BucketSort: SortType &#123;// inout修饰的参数是不能有默认值的，有范围的参数集合也不能被修饰；// 一个参数一旦被inout修饰，就不能再被var和let修饰了。// 1.监测属性,其实是给存储属性上添加的一种监测功能,willSet 监测新值,didSet 监测旧值// 2.如果函数的参数是inout 修饰的,你如果将监测的属性传入这个函数的时候,此时会将属性的值拷贝一份,在函数结束的时候,将值重新付给属性,所以函数执行完毕后,会触发监测函数 func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var bucket = createBucket() let maxNumber = listMaxItem(arr: list) let maxLeagth = numberLength(number: maxNumber) for digit in 1 ... maxLeagth &#123; // 入桶操作 for item in list &#123; let baseNum = fetchBaseNumber(number: item, digit: digit) // 根据基数放入对应的桶中 bucket[baseNum].append(item) &#125; var index = 0 // 出桶 for i in 0..&lt;bucket.count &#123; while !bucket[i].isEmpty &#123; list[index] = bucket[i].remove(at: 0) index = index + 1 &#125; &#125; &#125; return list &#125; /// 创建十个桶 /// /// - Returns: 放着十个桶的数组 func createBucket() -&gt; Array&lt;Array&lt;Int&gt;&gt;&#123; var buckets: Array&lt;Array&lt;Int&gt;&gt; = [] for _ in 0 ..&lt; 10 &#123; buckets.append([]) &#125; return buckets &#125; /// 取到最大值 /// /// - Parameter arr: 数组 /// - Returns: 最大值 func listMaxItem(arr : Array&lt;Int&gt;) -&gt; Int &#123; var max = arr[0] for item in arr &#123; if max &lt; item &#123; max = item &#125; &#125; return max &#125; /// 返回最大数字的长度 /// /// - Parameter number: 最大值 /// - Returns: 长度 func numberLength(number: Int) -&gt; Int &#123; return &quot;\(number)&quot;.count &#125; /// 获取相应位上的数字 /// /// - Parameters: /// - number: 操作的数字 /// - digit: 位数 /// - Returns: 返回该位上的数字 func fetchBaseNumber(number: Int, digit: Int) -&gt; Int &#123; if digit &gt; 0 &amp;&amp; digit &lt;= numberLength(number: number)&#123; var numArr: Array&lt;Int&gt; = [] for char in &quot;\(number)&quot; &#123; numArr.append(Int(&quot;\(char)&quot;)!) &#125; return numArr[numArr.count - digit] &#125; return 0 &#125;&#125; 经典之作 二分法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// while循环实现// Comparable协议继承于Equatable，实现Comparable协议可以在Equatable的基础上使类型支持&gt;，&gt;=，&lt;，&lt;=四种运算符extension Array where Element: Comparable &#123; public var isSorted: Bool&#123; var previousIndex = startIndex var currentIndex = previousIndex + 1 while currentIndex != endIndex &#123; if self[previousIndex] &gt; self[currentIndex]&#123; return false &#125; previousIndex = currentIndex currentIndex = currentIndex + 1 &#125; return true &#125; func binarySearch&lt;T: Comparable&gt;(sortedElements: [T], for element: T) -&gt; Bool &#123; assert(sortedElements.isSorted) var m = 0, n = sortedElements.count - 1 // 二分法 while m &lt; n &#123; let mid = (n-m)/2 + m if sortedElements[mid] == element &#123; return true &#125; else if sortedElements[mid] &lt; element &#123; m = mid + 1 &#125; else &#123; n = mid - 1 &#125; &#125; return false &#125;&#125;// 递归实现 二分法 var sortedElements2 = [1,2,3,4,23,24,56,78] var element = 56 func digui(_ m: Int, _ n: Int) -&gt;Int &#123; let mid = (n-m)/2 + m var mm = m var nn = n if mm&gt;nn &#123; return -1; &#125; if sortedElements2[mid] == element &#123; return mid; &#125; else if sortedElements2[mid] &lt; element &#123; mm = mid + 1 &#125; else &#123; nn = mid - 1 &#125; return digui(mm, nn) &#125; 递归实现1到n的和123456789101112func sum(n: Int) -&gt; Int &#123; if n == 0 &#123; print(&quot;000000&quot;) return 0 &#125;else if n == 1 &#123; print(&quot;111111111&quot;) return 1 &#125;else &#123; print(&quot;\(n)&quot;) return (sum(n:(n-1)) + n) &#125; &#125; 不借用第三方变量实现交换两个变量123456789a = a + bb = a - ba = a - b///////////// 按位异或a = a ^ bb = b ^ aa = a ^ b 找出数组中的两个数据值和等于 一个确定的值12345678910111213//func choseTwo(numsArr: [Int], targetValue: Int) -&gt; [Int] &#123; var dic = [Int: Int]() for (i,num) in numsArr.enumerated() &#123; if let index = dic[targetValue - num] &#123; return [index, i] &#125;else &#123; // 值为键 索引为值 储存数据 dic[num] = i &#125; &#125; return []&#125; 参考 ：https://www.cnblogs.com/ludashi/p/6065086.html http://developer.51cto.com/art/201403/430986.htm https://www.cnblogs.com/jingmoxukong/p/4303826.html https://www.jianshu.com/p/77ba54a46ad7]]></content>
  </entry>
  <entry>
    <title><![CDATA[swift开发之可POP]]></title>
    <url>%2F2019%2F08%2F03%2Fswift%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8F%AFPOP%2F</url>
    <content type="text"><![CDATA[OOP的优点 封装与权限控制 .h声明公用的变量方法，.m声明私有变量和方法 public/internal/fileprivate/private 命名空间 OC没有命名空间，swift有命名空间 扩展性 extension category 另外通过代理实现更加灵活的扩展 继承多态 公用的方法变量写在父类中，继承的子类根据需求实现对应的功能 OOP的缺点 隐式共享 class是引用类型，当在代码中的改变了实例变量的时候，另一处调用此变量收到修改的影响 冗杂的父类 代码的迭代，父类越来越冗杂，职权不明确、依赖严重 多继承 POP的优点 更加灵活 不再有冗杂的父类，通过不同的协议实现]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift for循环]]></title>
    <url>%2F2019%2F07%2F25%2Fswift-for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for12345678910111213141516171819202122232425// &lt;font color=&quot;red&quot;&gt;闭区间&lt;/font&gt; let arr = [1, 32, 2, 3, 4] for i in 1...3 &#123; i &#125; // 前闭后开 for j in 1..&lt;3 &#123; j &#125; // 返回元组 for (i, value) in arr.enumerated() &#123; i value &#125; // 跳步循环 for i in stride(from: -5, to: 5, by: 0.1) &#123; sin(i) &#125; // 反向循环 for p in arr.reversed() &#123; p &#125; 闭区间]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS更换项目名]]></title>
    <url>%2F2019%2F07%2F19%2FiOS%E6%9B%B4%E6%8D%A2%E9%A1%B9%E7%9B%AE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# encoding: UTF-8#!/usr/bin/rubyrequire &apos;fileutils&apos;require &apos;active_support/all&apos;OLD_PREFIX = &quot;SetNickNameVC&quot;NEW_PREFIX = &quot;LHGJResetPswVC&quot;FOLDER_EXCLUDE = [&quot;Pods&quot;, &quot;.framework&quot;]CONTENT_EXCLUDE = [&quot;.xcuserstate&quot;, &quot;.a&quot;, &quot;.mp3&quot;, &quot;.avi&quot;, &quot;.mp4&quot;, &quot;.wmv&quot;, &quot;.webp&quot;, &quot;.png&quot;, &quot;.jpg&quot;, &quot;.rb&quot;]# REGEXP = &quot;([^a-zA-Z_0-9]|^)#&#123;OLD_PREFIX&#125;([A-Z].*?)&quot;REGEXP = &quot;#&#123;OLD_PREFIX&#125;(.*?)&quot;NEW_STRING = &apos;\1&apos;+NEW_PREFIX+&apos;\2&apos;def search(dir) Dir[File.join(dir, &apos;*&apos;)].each do |file| unless FOLDER_EXCLUDE.include?(File.extname(file).empty? ? File.basename(file) : File.extname(file)) # 非排除的文件夹，才进入搜索 if File.directory?(file) search(file) end end if File.file?(file) search_content(file) end filename = File.basename(file) new_filename = filename.gsub(Regexp.new(REGEXP), NEW_STRING) if filename != new_filename dirname = File.dirname(file) new_file = File.join(dirname, new_filename) puts &quot;重命名文件: #&#123;file&#125; -&gt; #&#123;new_file&#125;&quot; File.rename(file, new_file) end endenddef search_content(file) # 不对排查的文件进行内容替换 return if CONTENT_EXCLUDE.include?(File.extname(file)) encoding = `file -I &quot;#&#123;file&#125;&quot;`.strip.split(&apos;charset=&apos;).last encoding = &quot;utf-8&quot; if encoding.empty? puts &quot;分析: #&#123;file&#125; (#&#123;encoding&#125;)&quot; content = File.open(file, &quot;rb:#&#123;encoding&#125;&quot;, &amp;:read) reg = Regexp.new(REGEXP.encode(encoding)) new_content = content.gsub(reg, NEW_STRING.encode(encoding)) if content != new_content File.open(file, &quot;w:UTF-8&quot;) do |f| f.write(new_content) end puts &quot;更新文件内容: #&#123;file&#125;&quot; endendsearch(Dir.pwd) 将以上脚本copy到rename.rb文件放在项目目录下 OLD_PREFIX、 NEW_PREFIX 分别填写你想要改的名字 执行 ruby rename.rb 即可 如果项目集成了cocoapod这时候会报错 只需要重新pod install即可]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Run Script]]></title>
    <url>%2F2019%2F07%2F19%2FRun-Script%2F</url>
    <content type="text"><![CDATA[譬如启动页动态加载版本号12345# 获取当前版本号# PlistBuddy plist操作工具 可用来对plist文件增删改查versionNumber=$(/usr/libexec/PlistBuddy -c &quot;Print :CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)# sed是一个非交互性文本流编辑器，可以与vi一样对文本进行编辑，但其可以在命令行或shell脚本中执行，从而避免了繁重的人机交互式的文件编辑操作sed -i bak -e &quot;/userLabel=\&quot;AppVersion\&quot;/s/text=\&quot;[^\&quot;]*\&quot;/text=\&quot;版本号：$versionNumber\&quot;/&quot; $PROJECT_DIR/LHGJiOS/Base.lproj/LaunchScreen.storyboard 常用的脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970每次构建的时候build号自增if [ $CONFIGURATION == Release ]; then echo &quot;Bumping build number...&quot; plist=$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125; #increment the build number (ie 115 to 116) buildnum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;plist&#125;&quot;) if [[ &quot;$&#123;buildnum&#125;&quot; == &quot;&quot; ]]; then echo &quot;No build number in $plist&quot; exit 2 fi buildnum=$(expr $buildnum + 1) /usr/libexec/Plistbuddy -c &quot;Set CFBundleVersion $buildnum&quot; &quot;$&#123;plist&#125;&quot; echo &quot;Bumped build number to $buildnum&quot; echo &quot;开始自增 Version 最后一位&quot; versionNum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;) # 取出第三个值 thirdPartVersonNum=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $3&#125;&apos;` thirdPartVersonNum=$(($thirdPartVersonNum + 1)) newVersionStr=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $1 &quot;.&quot; $2 &quot;.&apos;$thirdPartVersonNum&apos;&quot; &#125;&apos;` /usr/libexec/PlistBuddy -c &quot;Set CFBundleShortVersionString $newVersionStr&quot; &quot;$&#123;plist&#125;&quot;else echo $CONFIGURATION &quot; build - Not bumping build number.&quot;fi根据bundleID不同，设置不同的jpush appkey等#!/bin/bashbundleID=$&#123;PRODUCT_BUNDLE_IDENTIFIER&#125;id=&quot;com.zhoumoquan.zhoumoquan&quot;if [&quot;$bundleID&quot;=&quot;$id&quot;]; thencp zmq/PushConfig_AppStore.plist zmq/PushConfig.plistelsecp zmq/PushConfig_Enterprise.plist zmq/PushConfig.plistfi打包上传时移除第三方库中无用的部分APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;# This script loops through the frameworks embedded in the application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdoecho &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done Xcode Run Script Phase，有很多环境变量。 可以添加一个 Run Script,添加一条命令：env 编译之后就可以再编译报告里看到输出的环境变量]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS崩溃日志符号化]]></title>
    <url>%2F2019%2F07%2F19%2FiOS%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E7%AC%A6%E5%8F%B7%E5%8C%96%2F</url>
    <content type="text"></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS交互之WKWebView]]></title>
    <url>%2F2019%2F07%2F18%2FiOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E4%B9%8BWKWebView%2F</url>
    <content type="text"><![CDATA[iOS调js12两端提前协议号方法参数[self.webView evaluateJavaScript:@&quot;ocToJs(&apos;loginSucceed&apos;, &apos;oc_tokenString&apos;)&quot; completionHandler:^(id response, NSError *error) &#123;&#125;]; js调oc123456789101112131415161718192021222324WKScriptMessageHandler oc端实现此协议下的方法：- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、@interface WKScriptMessage : NSObject/*! @abstract The body of the message. @discussion Allowed types are NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull. */@property (nonatomic, readonly, copy) id body;/*! @abstract The web view sending the message. */@property (nullable, nonatomic, readonly, weak) WKWebView *webView;/*! @abstract The frame sending the message. */@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;/*! @abstract The name of the message handler to which the message is sent. */@property (nonatomic, readonly, copy) NSString *name;@end name判断是否是提前定义好的方法 body里面是想要的参数 我会对body做进一步的处理 这主要看自己和后台的定义 123456NSData * data = [body dataUsingEncoding:NSUTF8StringEncoding]; NSError * err;id jsonData = (NSDictionary *)[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;err];if (err) &#123; jsonData = body;&#125; 加载网页过程的高度进度等控制12345678910111213141516- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; !self.getWebEswebEtimatedProgress?:self.getWebEswebEtimatedProgress(newprogress); &#125;else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123; NSString * webTitle = [change objectForKey:NSKeyValueChangeNewKey]; !self.getWebTitle?:self.getWebTitle(webTitle); &#125;else if ([keyPath isEqualToString:NSStringFromSelector(@selector(contentSize))]) &#123; //sizeThatFits: 返回一个合适的大小以布局，默认实现是返回当前视图的已知大小 CGSize webViewSize = self.wkWebView.scrollView.contentSize; if (_observeScrollHeight) &#123; _observeScrollHeight(webViewSize.height); &#125; &#125;&#125; 网页加载成功后的高度回调123456789101112///网页加载成功- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123; !self.didFinishNavigation?:self.didFinishNavigation(); /* 获取webView的高度 @&quot;document.body.scrollHeight&quot; @&quot;document.body.offsetHeight&quot; @&quot;document.body.clientHeight&quot;*/ __weak typeof(self) weakSelf = self; [webView evaluateJavaScript:@&quot;document.body.scrollHeight&quot; completionHandler:^(id h, NSError * _Nullable error) &#123; __strong typeof(self) strongSelf = weakSelf; if (!error) &#123; !strongSelf.getWebDocumentBodyScrollHeight?:strongSelf.getWebDocumentBodyScrollHeight([h floatValue]); &#125; &#125;];&#125; 参考 https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA?]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 重签名]]></title>
    <url>%2F2019%2F07%2F05%2FiOS-%E9%87%8D%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[xcode Profiles地址 ~/Library/MobileDevice/Provisioning Profiles 签名的基本流程1、在Mac上生成一对公私钥，这里称公钥M，私钥M。 2、苹果自己有固定的一对公私钥，跟上面AppStore例子一样，私钥在苹果后台，公钥内置在每个iOS设备上，这里称为公钥A，私钥A。 3、把公钥M上传到苹果后台，用苹果后台里的私钥A去签名公钥M。得到一份数据包含了公钥M以及其签名（也就是公钥的HASH值），把这份数据称为证书。 4、在开发时，编译完一个App后，用本地的私钥M对这个App进行签名，同时把第三步得到的证书一起打包进App里，安装到手机。 5、在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证证书的数字签名是否正确。 验证证书确保公钥M是苹果认证过的，再用公钥M去验证App的签名，这里就间接验证了这个App的安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证App是否被改动，因为开发阶段App内容总是不断变化的，苹果不需要管）。 https://www.jianshu.com/p/fc56a70ee4fb plis文件的生成 根据mobileprovision生成相关的plistsecurity cms -D -i 123.mobileprovision &gt; embedded.plist 根据plist 截取其中的Entitlements部分/usr/libexec/PlistBuddy -x -c &#39;Print:Entitlements&#39; embedded.plist &gt; entitlements.plist 签名脚本1234567891011121314151617181920212223242526272829303132333435#!/bin/shif ! ([ -f &quot;$1&quot; ]); thenecho ----- \&quot;$&#123;1&#125;\&quot;文件不存在exitfiipaName=$&#123;1%.ipa&#125;if [ &quot;$ipaName&quot; = &quot;$1&quot; ]; thenecho ----- \&quot;$&#123;1&#125;\&quot;error 不是ipa文件exitfi## step 1 解压ipaunzip $&#123;ipaName&#125;.ipa## step 2 删除旧签名文件rm -rf Payload/*.app/_CodeSignature/## step 3 拷贝证书配置和权限文件cp embedded.mobileprovision Payload/*.app/embedded.mobileprovisioncp entitlements.plist Payload/*.app/## step 4 重签名(/usr/bin/codesign -f -s &quot;Iris Info-Tech(Shanghai) Co.,Ltd&quot; --entitlements Payload/*.app/entitlements.plist Payload/*.app/) || &#123;rm -rf Payload/rm -rf __MACOSX/exit&#125;## step 5 打包zip -r $&#123;ipaName&#125;_resign.ipa Payload/rm -rf Payload/rm -rf __MACOSX/ 签名工具iReSign]]></content>
      <tags>
        <tag>重签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods制作自己的Pod库]]></title>
    <url>%2F2019%2F06%2F12%2FCocoapods%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84Pod%E5%BA%93%2F</url>
    <content type="text"><![CDATA[整体流程 GitHub上创建仓库 test 克隆仓库到本地 在仓库下面建项目（即你要开放的代码） 创建.podspec文件 pod spec create test 编辑.podspec文件 123456789101112131415161718Pod::Spec.new do |s| s.name = &quot;WJDetailHeaderView&quot; s.version = &quot;1.0.1&quot; s.summary = &quot;标详情页的头部&quot; # 这个必须得写否则会报错 并且要比summary长 s.description = &lt;&lt;-DESC 这是新建的标信息仓库 DESC s.homepage = &quot;https://github.com/lbrjms/WJDetailHeaderView&quot; s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125; s.author = &#123; &quot;lwj_code&quot; =&gt; &quot;wallien@163.com&quot; &#125; s.platform = :ios, &quot;8.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/lbrjms/WJDetailHeaderView.git&quot;, :tag =&gt; s.version &#125; s.source_files = &quot;Classes&quot;, &quot;WJDetailHeaderView/WJDetailHeaderView/DetailHeaderView.swift&quot; # 指定swift的版本 否则有警告 s.swift_version = &apos;3.2&apos;end 项目打源码tag并上传git 123456git add .git statusgit commit -m &quot;this is 1.0.0&quot;git tag &apos;1.0.0&apos;git push --tagsgit push origin master 验证podspec 1pod spec lint 注册pod 123pod trunk register wallien@163.com &quot;lwj_code&quot;注册之后记得邮箱认证 发布pod 1pod trunk push test.podspec 到这里没问题就是成功了 遇到的问题xcrun: error: unable to find utility “simctl”, not a developer tool or in PATH ) during validation 到xcode的偏好设置里面设置command line tools： Xcode&gt;preferences&gt;Locations里面，设置之后再运行终端即可]]></content>
      <tags>
        <tag>Pod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSS订阅打开都是xml的问题]]></title>
    <url>%2F2019%2F06%2F06%2FRSS%E8%AE%A2%E9%98%85%E6%89%93%E5%BC%80%E9%83%BD%E6%98%AFxml%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装rss插件 npm install hexo-generator-feed 在这个各种信息混杂的时代，rss真的感觉是一股清流，我们可以通过这个功能订阅自己先看的文章，节目…. 刚接触rss遇到最多的问题就是点击网站的rss订阅 显示的都是xml代码，这是由于没有安装RSS客户端 或是没有支持RSS的插件 如果是google浏览器可以安装feeder插件挺好用 https://juejin.im/post/5c382a326fb9a049f15469eb https://www.inoreader.com/]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD常用语法]]></title>
    <url>%2F2019%2F06%2F05%2Fmd%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[md简单语法二级标题三级标题四级标题五级标题六级标题无序列表//形式一 a b c //形式二 d e f //形式三 g h i 无序列表嵌套 123 abc bcd cde 465 789 有序列表嵌套 abcd abcde abcde abcde bcde cdef 引用 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。 一级引用 二级引用 三级引用 四级引用 五级引用 六级引用 代码块NSOpenPanel* openDlg = [NSOpenPanel openPanel] 1234567891011121314NSOpenPanel* openDlg = [NSOpenPanel openPanel];[openDlg setCanChooseFiles:TRUE];[openDlg setCanChooseDirectories:FALSE];[openDlg setAllowsMultipleSelection:FALSE];[openDlg setAllowsOtherFileTypes:FALSE];[openDlg setAllowedFileTypes:@[@&quot;ipa&quot;, @&quot;IPA&quot;, @&quot;xcarchive&quot;]];if ([openDlg runModal] == NSOKButton)&#123; NSString* fileNameOpened = [[[openDlg URLs] objectAtIndex:0] path]; [pathField setStringValue:fileNameOpened];&#125; 链接 行内式链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来 简书, 是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流 参数式链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来 简书是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。 //参数定义的其他写法 分割线至少三个字符 斜体 加粗 删除线mdmd mdmd 删除 表格//例子一 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子二 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子三 123 234 345 abc bcd cde abc bcd cde abc bcd cde]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHubPages搭建个人博客]]></title>
    <url>%2F2019%2F06%2F05%2FGitHub-Pages-Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[创建github仓库 创建一个github仓库 仓库名必须与用户名相同 之后的博客地址就是：http://username.github.io 配置sshGit可以通过https和ssh两种方式连接服务器上的仓库。ssh的方式会在传输前压缩数据，这样传输的效率很高。而且不需要每次都输入账号和密码。 git的用户名和邮箱设置 12$ git config --global user.name &quot;your name”$ git config --global user.email &quot;your email&quot; 查看本地是否有ssh密钥（有这些文件说明已经有了id_rsa，id_rsa.pubknown_hosts），如果没有就自己生成 1cd ~/.ssh 12生成ssh命令 根据提示一步步操作即可ssh-keygen -t rsa -C “your email” vim打开公钥文件 复制共钥到github的设置里面 1vim id_rsa.pub 安装Hexo环境12345678910// 安装hexonpm install hexo-cli -g// 初始化一个blog文件夹hexo init blog// 到blog文件夹下启动服务 之后就可以在http://localhost:4000 看的你的博客cd blognpm installhexo server 配置Deployment 修改blog文件夹下的_config.yml文件 1234567# Deployment## Docs: https://hexo.io/docs/deployment.html### :号后面都要有空格 否则hexo d的时候会没反应deploy:type:gitrepo:git@github.com:你的github账号/你的github账号.github.io.gitbranch:master 生成新的public文件 12hexo clean //删除旧的public文件hexo generate / hexo g //生成新的public文件 部署到github上1hexo deploye / hexo d 到此就初步完成了 在打开https://lbrjms.github.io就可以看到你的博客了 更换主题Â成功之后的第一件事就是更换主题 选择自己喜欢的主题 下载到themes文件夹下面更改_config.yml 的themes 对应的名字就可以了 下面是我clone的主题 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 开启分类 tags 123$$ hexo new page tags$ hexo new page categories 创建文章$ hexo new &quot;title&quot; 关于界面 maupassant主题里有个关于导航菜单，默认点进去是不行的，需要自己新建个。在Hexo的 source 目录新建个 about 文件夹，文件夹里按模板新建个 index.md 更改主题语言支持多种语言 去config文件里面改就可以（我找了半天才找到）其实关于一些设置的东西 大多数都在config里面改]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity gameobject 的 生命周期]]></title>
    <url>%2F2018%2F08%2F08%2FUnity%20gameobject%20%E7%9A%84%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Unity3d 基础学习 脚本生命周期 Awake 脚本被载入是调用 OnEnable 对象变为可用或激活状态时调用 Start 只调用一次 FixedUpdate 固定的时间间隔被调用 不受设备的帧率等的影响 Update 更新 LateUpdate Update之后更新 OnGUI 渲染和处理GUI事件 OnDisable 当前对象不可用或处于非激活状态 脚本或对象被销毁的时候调用 OnDestroy 当物体 或是 脚本 被销毁 常用的方法 gameObt.GetComponent&lt; compomentName &gt; (); 获取到对应的compoment GetComponent ().AddForce (vec3); 给刚体添加力]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局Pop 隐藏TabBar NavigationBar]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%85%A8%E5%B1%80Pop%20%E9%9A%90%E8%97%8FTabBar%20NavigationBar%2F</url>
    <content type="text"><![CDATA[全局Pop(侧边缘滑动的拓展) 思路:给系统的侧边缘滑动runtime添加target action1234567891011121314151617181920212223242526272829303132333435363738import UIKitclass CustomNavigationController: UINavigationController &#123;override func viewDidLoad() &#123; super.viewDidLoad() // 1. 获取系统的Pop手势 let systemGes = interactivePopGestureRecognizer // 2. 获取手势的view用于添加新的手势 let gesView = systemGes?.view // 3. 获取target/action // 3.1 利用运行时机制获取所有的属性名称 var count : UInt32 = 0 let ivars = class_copyIvarList(UIGestureRecognizer.self, &amp;count)! for i in 0..&lt;count &#123; let ivar = ivars[Int(i)] let name = ivar_getName(ivar)! print(String(cString : name)) &#125; let targets = systemGes?.value(forKey: "_targets") as? [NSObject] let targetObjc = targets?.first // 3.2 取出target guard let target = targetObjc?.value(forKey: "target") else &#123; return &#125; // 3.3 取出action let action = Selector(("handleNavigationTransition:")) // 4. 创建自己的Pan手势 let panGes = UIPanGestureRecognizer() gesView?.addGestureRecognizer(panGes) panGes.addTarget(target, action: action)&#125;&#125; 隐藏tabBarimport UIKit class CustomNavigationController: UINavigationController { override func viewDidLoad() { super.viewDidLoad() } override func pushViewController(_ viewController: UIViewController, animated: Bool) { viewController.hidesBottomBarWhenPushed = true super.pushViewController(viewController, animated: animated) } }隐藏NavigationBarclass ViewController: UIViewController,UIGestureRecognizerDelegate { override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) navigationController?.setNavigationBarHidden(true, animated: true) navigationController?.interactivePopGestureRecognizer?.delegate = self navigationController?.interactivePopGestureRecognizer?.isEnabled = true } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationController?.setNavigationBarHidden(false, animated: true) } override func viewDidLoad() { super.viewDidLoad() } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[swift基础之可选型]]></title>
    <url>%2F2018%2F07%2F30%2Fswift%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%AF%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334/* * 可选型 * 主要用来表示 没有 这个概念 * 必须显示表达 * 正常会作为var 变量来存在 * 不能被直接使用 因为它有可能是空 会报错 * 被解包才能用 * ! 强制解包 * if let 解包 * ?? * 三目运算符 ? : * 隐式可选型 * var errorCode3: Int! * errorCode3 = nil */// 这不仅仅是整形 还是一个可选性var errorCode: Int? = 404errorCode = 0// 只有可选性才能被赋值为nilerrorCode = nilprint(errorCode)var errorCode2: String? = &quot;404&quot;errorCode2 = &quot;400&quot;&quot;The errorCode is &quot; + (errorCode2 ?? &quot;ss&quot;)errorCode2?.localizedUppercaseif let safeCode = errorCode2 &#123; // if let 的作用就是解包 判断空 解包成功 也就是不为空才会进来 &quot;safe&quot; + safeCode&#125;let ageIntput: String = &quot;23&quot;let age = Int(ageIntput) ?? 0print(age)let greetString = &quot;Hello&quot;greetString.range(of: &quot;o&quot;)]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种地图的坐标转换]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%90%84%E7%A7%8D%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[各种地图的坐标转换 123456789101112131415161718192021222324252627282930@interface LWJLocation : NSObject@property (nonatomic, assign) double latitude;@property (nonatomic, assign) double longitude;- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude;/* 坐标系： WGS-84：是国际标准，GPS坐标（Google Earth使用、或者GPS模块） GCJ-02：中国坐标偏移标准，Google Map、高德、腾讯使用 BD-09 ：百度坐标偏移标准，Baidu Map使用 */#pragma mark - 从GPS坐标转化到高德坐标- (id)transformFromGPSToGD;#pragma mark - 从高德坐标转化到百度坐标- (id)transformFromGDToBD;#pragma mark - 从百度坐标到高德坐标- (id)transformFromBDToGD;#pragma mark - 从高德坐标到GPS坐标- (id)transformFromGDToGPS;#pragma mark - 从百度坐标到GPS坐标- (id)transformFromBDToGPS;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#import &lt;CoreLocation/CoreLocation.h&gt;static const double a = 6378245.0;static const double ee = 0.00669342162296594323;static const double pi = M_PI;static const double xPi = M_PI * 3000.0 / 180.0;@implementation LWJLocation- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude &#123; if (self = [super init]) &#123; self.latitude = latitude; self.longitude = longitude; &#125; return self;&#125;- (id)transformFromGPSToGD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromWGSToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromGDToBD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToBaidu:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromBDToGD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromGDToGPS &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromBDToGPS &#123; //先把百度转化为高德 CLLocationCoordinate2D start_coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; CLLocationCoordinate2D end_coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(start_coor.latitude, start_coor.longitude)]; return [[LWJLocation alloc] initWithLatitude:end_coor.latitude andLongitude:end_coor.longitude];&#125;+ (CLLocationCoordinate2D)transformFromWGSToGCJ:(CLLocationCoordinate2D)wgsLoc &#123; CLLocationCoordinate2D adjustLoc; if([self isLocationOutOfChina:wgsLoc]) &#123; adjustLoc = wgsLoc; &#125; else &#123; double adjustLat = [self transformLatWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0]; double adjustLon = [self transformLonWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0]; long double radLat = wgsLoc.latitude / 180.0 * pi; long double magic = sin(radLat); magic = 1 - ee * magic * magic; long double sqrtMagic = sqrt(magic); adjustLat = (adjustLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi); adjustLon = (adjustLon * 180.0) / (a / sqrtMagic * cos(radLat) * pi); adjustLoc.latitude = wgsLoc.latitude + adjustLat; adjustLoc.longitude = wgsLoc.longitude + adjustLon; &#125; return adjustLoc;&#125;+ (double)transformLatWithX:(double)x withY:(double)y &#123; double lat = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x)); lat += (20.0 * sin(6.0 * x * pi) + 20.0 *sin(2.0 * x * pi)) * 2.0 / 3.0; lat += (20.0 * sin(y * pi) + 40.0 * sin(y / 3.0 * pi)) * 2.0 / 3.0; lat += (160.0 * sin(y / 12.0 * pi) + 320 * sin(y * pi / 30.0)) * 2.0 / 3.0; return lat;&#125;+ (double)transformLonWithX:(double)x withY:(double)y &#123; double lon = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x)); lon += (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 / 3.0; lon += (20.0 * sin(x * pi) + 40.0 * sin(x / 3.0 * pi)) * 2.0 / 3.0; lon += (150.0 * sin(x / 12.0 * pi) + 300.0 * sin(x / 30.0 * pi)) * 2.0 / 3.0; return lon;&#125;+ (CLLocationCoordinate2D)transformFromGCJToBaidu:(CLLocationCoordinate2D)p &#123; long double z = sqrt(p.longitude * p.longitude + p.latitude * p.latitude) + 0.00002 * sqrt(p.latitude * pi); long double theta = atan2(p.latitude, p.longitude) + 0.000003 * cos(p.longitude * pi); CLLocationCoordinate2D geoPoint; geoPoint.latitude = (z * sin(theta) + 0.006); geoPoint.longitude = (z * cos(theta) + 0.0065); return geoPoint;&#125;+ (CLLocationCoordinate2D)transformFromBaiduToGCJ:(CLLocationCoordinate2D)p &#123; double x = p.longitude - 0.0065, y = p.latitude - 0.006; double z = sqrt(x * x + y * y) - 0.00002 * sin(y * xPi); double theta = atan2(y, x) - 0.000003 * cos(x * xPi); CLLocationCoordinate2D geoPoint; geoPoint.latitude = z * sin(theta); geoPoint.longitude = z * cos(theta); return geoPoint;&#125;+ (CLLocationCoordinate2D)transformFromGCJToWGS:(CLLocationCoordinate2D)p &#123; double threshold = 0.00001; // The boundary double minLat = p.latitude - 0.5; double maxLat = p.latitude + 0.5; double minLng = p.longitude - 0.5; double maxLng = p.longitude + 0.5; double delta = 1; int maxIteration = 30; // Binary search while(true) &#123; CLLocationCoordinate2D leftBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = minLng&#125;]; CLLocationCoordinate2D rightBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = maxLng&#125;]; CLLocationCoordinate2D leftUp = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = maxLat,.longitude = minLng&#125;]; CLLocationCoordinate2D midPoint = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;]; delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude); if(maxIteration-- &lt;= 0 || delta &lt;= threshold) &#123; return (CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;; &#125; if(isContains(p, leftBottom, midPoint)) &#123; maxLat = (minLat + maxLat) / 2; maxLng = (minLng + maxLng) / 2; &#125; else if(isContains(p, rightBottom, midPoint)) &#123; maxLat = (minLat + maxLat) / 2; minLng = (minLng + maxLng) / 2; &#125; else if(isContains(p, leftUp, midPoint)) &#123; minLat = (minLat + maxLat) / 2; maxLng = (minLng + maxLng) / 2; &#125; else &#123; minLat = (minLat + maxLat) / 2; minLng = (minLng + maxLng) / 2; &#125; &#125;&#125;#pragma mark - 判断某个点point是否在p1和p2之间static bool isContains(CLLocationCoordinate2D point, CLLocationCoordinate2D p1, CLLocationCoordinate2D p2) &#123; return (point.latitude &gt;= MIN(p1.latitude, p2.latitude) &amp;&amp; point.latitude &lt;= MAX(p1.latitude, p2.latitude)) &amp;&amp; (point.longitude &gt;= MIN(p1.longitude,p2.longitude) &amp;&amp; point.longitude &lt;= MAX(p1.longitude, p2.longitude));&#125;#pragma mark - 判断是不是在中国+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location &#123; if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271) return YES; return NO;&#125;]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runloop]]></title>
    <url>%2F2017%2F07%2F26%2FRunloop%2F</url>
    <content type="text"><![CDATA[可用runloop控制图片加载 卡顿 等问题 RunLoop共包含5个类，但公开的只有Source、Timer、Observer相关的三个类。 CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个 enum CFRunLoopActivity { kCFRunLoopEntry = (1 &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1 &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1 &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1 &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1 &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1 &lt;&lt; 7), // 即将退出Loop kCFRunLoopAllActivities = 0x0FFFFFFFU // 包含上面所有状态};typedef enum CFRunLoopActivity CFRunLoopActivity; RunLoop主要处理以下6类事件 123456static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(); CFRunLoopMode 和 CFRunLoop的结构大致如下： 123456789101112131415struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot; CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;;struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 一个RunLoop包含了多个Mode，每个Mode又包含了若干个Source/Timer/Observer。每次调用 RunLoop的主函数时，只能指定其中一个Mode，这个Mode被称作CurrentMode。如果需要切换 Mode，只能退出Loop，再重新指定一个Mode进入。这样做主要是为了分隔开不同Mode中的Source/Timer/Observer，让其互不影响。下面是5种Mode kCFDefaultRunLoopMode App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode 界面跟踪Mode，用于ScrollView追踪触摸滑动，保证界面滑动时不受其他Mode影响 UIInitializationRunLoopMode 在刚启动App时第进入的第一个Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode 接受系统事件的内部Mode，通常用不到 kCFRunLoopCommonModes 这是一个占位用的Mode，不是一种真正的Mode 其中kCFDefaultRunLoopMode、UITrackingRunLoopMode是苹果公开的，其余的mode都是无法添加的。那为何我们又可以这么用呢 [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];什么是CommonModes？ 一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将_commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里主线程的 RunLoop 里有 kCFRunLoopDefaultMode 和 UITrackingRunLoopMode，这两个Mode都已经被标记为”Common”属性。当你创建一个Timer并加到DefaultMode时，Timer会得到重复回调，但此时滑动一个 scrollView 时，RunLoop 会将 mode 切换为TrackingRunLoopMode，这时Timer就不会被回调，并且也不会影响到滑动操作。如果想让scrollView滑动时Timer可以正常调用，一种办法就是手动将这个 Timer 分别加入这两个 Mode。另一种方法就是将 Timer 加入到CommonMode 中。怎么将事件加入到CommonMode？我们调用上面的代码将 Timer 加入到CommonMode 时，但实际并没有 CommonMode，其实系统将这个 Timer 加入到顶层的 RunLoop 的 commonModeItems 中。commonModeItems 会被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去。这一步其实是系统帮我们将Timer加到了kCFRunLoopDefaultMode和UITrackingRunLoopMode中。在项目中最常用的就是设置NSTimer的Mode，比较简单这里就不说了。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。每次线程运行RunLoop都会自动处理之前未处理的消息，并且将消息发送给观察者，让事件得到执行。RunLoop运行时首先根据modeName找到对应mode，如果mode里没有source/timer/observer，直接返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110/// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125;/// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125;/// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是_wrapRunLoopWithAutoreleasePoolHandler()。第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用_objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop()和_objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用_objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为__IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用_UIApplicationHandleEventQueue() 进行应用内部的分发。哈哈_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的_UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是_UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。 当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层: CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire• CFSocket 是最底层的接口，只负责 socket 通信。• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。下面主要介绍下 NSURLConnection 的工作过程。通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。 RunLoop 的实际应用举例 AFNetworkingAFURLConnectionOperation 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：123456789101112131415161718+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@&quot;AFNetworking&quot;]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。 12345678910- (void)start &#123; [self.lock lock]; if ([self isCancelled]) &#123; [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; else if ([self isReady]) &#123; self.state = AFOperationExecutingState; [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]]; &#125; [self.lock unlock];&#125; 当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。 AsyncDisplayKitAsyncDisplayKit 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下： UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。 排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。 其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。 为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。 ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。 Topic: Tableview卡顿与RunLoop思路：将需要的耗时动作类似图片下载放到RunLoop中defaultRunLoopMode中处理，因为滑动是在UItrackMode下的，就不会在滑动的线程下下载，只有滑动完毕回到defaultRunLoopMode下才会调用 12345UIImage *downLoadImage = ...; [self.avatarImageView performSelector:@selector(setImage:) withObject:downloadImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]]; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#import &quot;ViewController.h&quot;typedef BOOL(^RunloopBlock)(void);@interface ViewController ()/** 存放任务的数组 */@property (nonatomic, retain)NSMutableArray *tasks;/** 最大任务数 */@property (nonatomic, assign)NSUInteger max;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _max = 18; _tasks = [NSMutableArray array]; [self addRunloopObserver]; NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerMothod) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, &lt;#dispatchQueue#&gt;);// dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, &lt;#intervalInSeconds#&gt; * NSEC_PER_SEC, &lt;#leewayInSeconds#&gt; * NSEC_PER_SEC);// dispatch_source_set_event_handler(timer, ^&#123;// &lt;#code to be executed when timer fires#&gt;// &#125;);// dispatch_resume(timer);&#125;- (void)timerMothod&#123; NSLog(@&quot;timer-----&quot;);&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;&#125;- (void)addRunloopObserver&#123;// typedef struct &#123;// CFIndex version;// void * info;// const void *(*retain)(const void *info);// void (*release)(const void *info);// CFStringRef (*copyDescription)(const void *info);// &#125; CFRunLoopObserverContext; // 上下文结构体 CFRunLoopObserverContext context = &#123; 0, (__bridge void *)(self), &amp;CFRetain, &amp;CFRelease, NULL &#125;; // 1.拿到当前的runloop CFRunLoopRef runloop = CFRunLoopGetCurrent(); static CFRunLoopObserverRef defaultModeObserver; // 创建观察者 defaultModeObserver = CFRunLoopObserverCreate(NULL, kCFRunLoopAfterWaiting, YES, 0, &amp;callBack, &amp;context); // 添加当前观察者 CFRunLoopAddObserver(runloop, defaultModeObserver, kCFRunLoopDefaultMode); // c语言与create就要有release CFRelease(defaultModeObserver);&#125;static void callBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; ViewController *vc = (__bridge ViewController *)(info); if (vc.tasks.count==0) return; while (vc.tasks.count) &#123; RunloopBlock unit = vc.tasks.firstObject; [vc.tasks removeObjectAtIndex:0]; &#125;&#125;@end]]></content>
      <tags>
        <tag>Runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreMLtest]]></title>
    <url>%2F2017%2F07%2F26%2FCoreMLtest%2F</url>
    <content type="text"><![CDATA[iOS 11 机器学习练习 iOS 11 机器学习练习 图片数据1let imageData = pickImageView.image?.cgImage 用到的模型1let model = try! VNCoreMLModel(for: Resnet50().model) 配置请求12let hander = VNImageRequestHandler(cgImage: imageData!)let request = VNCoreMLRequest(model: model, completionHandler: myResultsMethod) 执行请求1try! hander.perform([request]) 请求的方法 用于model的输入输出123456789func myResultsMethod(request: VNRequest, error: Error?) &#123;guard let results = request.results as? [VNClassificationObservation]else &#123; fatalError("huh") &#125;lable.text = results[0].identifierfor classification in results &#123;print("=====++===" + classification.identifier + "----++----" )&#125;&#125; 1234567891011platform :ios, &quot;8.0&quot;inhibit_all_warnings!use_frameworks!target &apos;RAC_ObjcTest&apos; dopod &apos;ReactiveObjC&apos;pod &apos;XRCarouselView&apos;end]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AR_Swift]]></title>
    <url>%2F2017%2F07%2F26%2FAR-Swift%2F</url>
    <content type="text"><![CDATA[ios 11 出了 ar 体验一把 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import UIKitimport SceneKitimport ARKitclass ViewController: UIViewController, ARSCNViewDelegate &#123; @IBOutlet var sceneView: ARSCNView! override func viewDidLoad() &#123; super.viewDidLoad() // Set the view&apos;s delegate sceneView.delegate = self // Show statistics such as fps and timing information sceneView.showsStatistics = true // Create a new scene let scene = SCNScene(named: &quot;art.scnassets/ship.scn&quot;)! // Set the scene to the view sceneView.scene = scene &#125; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) // Create a session configuration let configuration = ARWorldTrackingSessionConfiguration() // Run the view&apos;s session sceneView.session.run(configuration) &#125; override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) // Pause the view&apos;s session sceneView.session.pause() &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Release any cached data, images, etc that aren&apos;t in use. &#125; // MARK: - ARSCNViewDelegate/* // Override to create and configure nodes for anchors added to the view&apos;s session. func renderer(_ renderer: SCNSceneRenderer, nodeFor anchor: ARAnchor) -&gt; SCNNode? &#123; let node = SCNNode() return node &#125;*/ func session(_ session: ARSession, didFailWithError error: Error) &#123; // Present an error message to the user &#125; func sessionWasInterrupted(_ session: ARSession) &#123; // Inform the user that the session has been interrupted, for example, by presenting an overlay &#125; func sessionInterruptionEnded(_ session: ARSession) &#123; // Reset tracking and/or remove existing anchors if consistent tracking is required &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有用的终端命令]]></title>
    <url>%2F2017%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android_布局]]></title>
    <url>%2F2017%2F07%2F24%2FAndroid-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[LinearLayout RectiveLayout TablbeLayout LinearLayout layout_margin 外边距(控件距离其他空间或是屏幕边缘的距离) padding 内边距 (控件内部内容距离控件边缘的距离) gravity 表示控件内部内容的对齐方式 layout_gravity 该控件在父类布局中的对齐方式 如果线性布局的对齐方式为水平layout_gravity 在水平方向上不起作用 如果线性布局的对齐方式为垂直layout_gravity 在垂直方向上不起作用 layout_weight 权重(百分比) 线性布局的特有属性如果控件划分的match_parent 成反比如果控件划分的wrap_content 成正比 无权重控件优先级高 然后按剩余页面的控件大小按照权重划分]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_无线调试脚本]]></title>
    <url>%2F2017%2F07%2F24%2FAndroid-%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[执行以下脚本 可用于Android真机无线调试 123456789101112131415161718192021222324252627282930313233343536#!/bin/bash#Modify this with your IP rangeMY_IP_RANGE="192\.168\.1"#You usually wouldn't have to modify thisPORT_BASE=5555#List the devices on the screen for your viewing pleasureadb devicesecho#Find USB devices only (no emulators, genymotion or connected devicesdeclare -a deviceArray=(`adb devices -l | grep -v emulator | grep -v vbox | grep -v "$&#123;MY_IP_RANGE&#125;" | grep " device " | awk '&#123;print $1&#125;'`)echo "found $&#123;#deviceArray[@]&#125; device(s)"echofor index in $&#123;!deviceArray[*]&#125;doecho "finding IP address for device $&#123;deviceArray[index]&#125;"IP_ADDRESS=$(adb -s $&#123;deviceArray[index]&#125; shell ifconfig wlan0 | awk '&#123;print $3&#125;')echo "IP address found : $IP_ADDRESS "echo "Connecting..."adb -s $&#123;deviceArray[index]&#125; tcpip $(($PORT_BASE + $index))adb -s $&#123;deviceArray[index]&#125; connect "$IP_ADDRESS:$(($PORT_BASE + $index))"echoechodoneadb devices -l#exit]]></content>
      <categories>
        <category>shell,Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gradle常用命令]]></title>
    <url>%2F2017%2F07%2F24%2FGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[./代表当前目录，gradlew代表 gradle wrapper，意思是gradle的一层包装，大家可以理解为在这个项目本地就封装了gradle，即gradle wrapper， 在./gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本。只要下载成功即可用grdlew wrapper的命令代替全局的gradle命令。以下的命令都是在项目目录下操作 查看版本号: 12$ ./gradlew -v第一次执行这条命令会下载安装 清除项目目录下的build文件夹 1$ ./gradlew clean 检查依赖编译打包 123$ ./gradlew build这个命令把debug、release环境的包都打出来 打Debug包 1$ ./gradlew assembleDebug 打Release包 1$ ./gradlew assembleRelease]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_Intent]]></title>
    <url>%2F2017%2F07%2F23%2FAndroid-Intent%2F</url>
    <content type="text"><![CDATA[Intent 的几大属性 ComponentName (组件名称) Action 字符串类型 1intent.setAction(&quot;com.example.lwj.activitytest&quot;); Category分类 进一步筛选要选择的内容 一般放在标签中 常用的有:LAUNCHER 、DEFAULT、 HOME Extra 附加信息(键值对) 传值putExtra() 12345if (getIntent() != null)&#123; Intent intent = getIntent(); String info = intent.getStringExtra(&quot;info&quot;);&#125; Data]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_生命周期]]></title>
    <url>%2F2017%2F07%2F23%2FAndroid-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[一把都是成对出现的 onCreate–onDestroy onStart–onStop onResume–onPause Activity生命周期 onCreate创建activity的方法 onStart启动activity onResume执行此方法之后 用户可以看到 h获取焦点 onPause失去焦点 可见 不可交互 onStop不可见 onDestroy销毁当前activity的页面实例 onRestart将置于后台的activity重新被置于前台 成对出现onCreate–onDestroy onStart–onStop onResume–onPause Task一个app启动的时候会包含多个Activity页面,这些Activity所组成的操作就是一个task任务 back Task 任务栈点击一个app 就会开启一个task任务 这个任务中所有的activity就会被放在一个任务栈(back stack)中 位于任务栈 栈顶的Activity用户可见新的Activity进入栈的时候 已存在栈中的Activity会压栈 启动activity startActivity Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(new Intent(intent)) ; startActivityForResult (带返回值的跳转) Intent intent = new Intent(MainActivity.this, SecondActivity.class);// 参数一: intent对象 参数二: 请求码 用来区分页面startActivityForResult(intent, 10); 重写系统方法 onActivityResult 123456789101112131415@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode==10&amp;&amp;resultCode==RESULT_OK)&#123; TextView tv = (TextView) findViewById(R.id.textView); /*将数据取出 并展示出来*/ tv.setText(data.getStringExtra(&quot;key&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift小知识]]></title>
    <url>%2F2017%2F07%2F21%2FSwift%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Swift的小知识点集锦 设置attributes 属性 12345//文档open func setTitleTextAttributes(_ attributes: [String : Any]?, for state: UIControlState)//例子rootNav.tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor.rawValue: UIColor.red], for: .selected) 设置image的 RenderingMode 12let selectImg = UIImage(named: selectImgName)?.withRenderingMode(.alwaysOriginal) @available #available Swift 2.0 中，引入了可用性的概念。对于函数，类，协议等，可以使用@available声明这些类型的生命周期依赖于特定的平台和操作系统版本。而#available用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑。 @available放在函数（方法），类或者协议前面。表明这些类型适用的平台和操作系统 1234@available(iOS 9, *)func myMethod() &#123; // do something&#125; #available 用在条件语句代码块中，判断不同的平台下，做不同的逻辑处理，比如： 12345678if #available(iOS 8, *) &#123; // iOS 8 及其以上系统运行&#125;guard #available(iOS 8, *) else &#123; return //iOS 8 以下系统就直接返回&#125; SelectorSwift 中的 Selector 类型其实就是 Objective-C 中的 SEL 类型。在 Swift 中，Selector 的本质是结构体。 1btn.addTarget(&lt;#T##target: Any?##Any?#&gt;, action: &lt;#T##Selector#&gt;, for: &lt;#T##UIControlEvents#&gt;) 类似 Objective-C 中的 NSSelectorFromString，Swift 中的 Selector 也可以使用字符串来构造(会有警告) 1btn.addTarget(self, action: Selector(&quot;btnClick&quot;), for: .touchUpInside) 这样写的好处 可以条用类的私有变量 类似OC的运行时机制handleNavigationTransition:还有一种方法是 1btn.addTarget(self, action: #selector(ProfileViewController.itemClick), for: .touchUpInside) 如果当期作用域下 只有这一个方法 ProfileViewController可以省略 直接写方法名 方法前加@objc我们也知道OC中的属性其实是自动生成了getter和setter方法。swift 3中支持获取属性的getter和setter方法 通过#selector: #selector(setter: &lt;#T##@objc property#&gt;) #selector(getter: &lt;#T##@objc property#&gt;) 123456789101112131415class Person: NSObject &#123; dynamic var firstName: String dynamic let lastName: String dynamic var fullName: String &#123; return &quot;\(firstName) \(lastName)&quot; &#125; init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125;&#125;let firstNameGetter = #selector(getter: Person.firstName)let firstNameSetter = #selector(setter: Person.firstName) layout的属性1234//每行之间竖直之间的最小间距 （可以大于）layout.minimumLineSpacing = 1//同行的cell与cell之间水平之间的最小间距layout.minimumInteritemSpacing = 1 参考: 链接 深入探究Swift数组背后的协议、方法、拓展]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim的基本使用]]></title>
    <url>%2F2017%2F07%2F19%2FVim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 1、vi的基本概念基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： $ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存） : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l。 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符。 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符。 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符。 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符。 「dd」：删除光标所在行。 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。 6）. 替换 「r」：替换光标所在处的字符。 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回复。 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号。 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 4、Last line mode下命令简介在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来。 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 5、vi命令列表1、下表列出命令模式下的一些键的功能： h 左移光标一个字符 l 右移光标一个字符 k 光标上移一行 j 光标下移一行 ^ 光标移动至行首 0 数字“0”，光标移至文章的开头 G 光标移至文章的最后 $ 光标移动至行尾 Ctrl+f向前翻屏 Ctrl+b向后翻屏 Ctrl+d向前翻半屏 Ctrl+u向后翻半屏 i 在光标位置前插入字符 a 在光标所在位置的后一个字符开始增加 o 插入新的一行，从行首开始输入 ESC从输入状态退至命令状态 x 删除光标后面的字符 #x删除光标后的＃个字符 X (大写X)，删除光标前面的字符 #X删除光标前面的#个字符 dd删除光标所在的行 #dd删除从光标所在行数的#行 yw复制光标所在位置的一个字 #yw复制光标所在位置的#个字 yy复制光标所在位置的一行 #yy复制从光标所在行数的#行 p 粘贴 u 取消操作 cw更改光标所在位置的一个字 #cw更改光标所在位置的#个字]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis_CI动态编译GitHub仓库]]></title>
    <url>%2F2017%2F07%2F06%2FTravis-CI%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91GitHub%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我的博客是用hexo部署在GitHub上的有时候换个电脑或是有个小改动的话 就会很不方便 Travis刚好解决了这个问题 什么是Travis_CI Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，Go的很明显的 特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 GitHub账号登录Travis_CI 在左上角有加好按钮 把需要添加的项目开关打开 github上添加access token 登录github，进入到setting =&gt; develop setting =&gt; personal access tokens在description里输入任意token 名字，比如Travis-CI，并勾选上下面所有复选框。这个时候会生成token，请务必记住，因为他只会出现一次，否则需要重新生成(这个就是)。 添加access token到travis上 在travis右上角more options里找到setting，打开后，勾选 [Build only if .travis.yml is present] 并且 在Environment Variables中添加github上的access token。 添加编写.travis.yml 在项目源码根目录(我的是troy-yang.github.io source分支), 添加.travis.yml文件，下面是我的: 123456789101112131415161718192021222324language: node_jsnode_js: stable# S: Build Lifecycleinstall:- npm install hexo-cli -g- npm installbefore_install:- git submodule update --init --remote --recursive#before_script:# - npm install -g gulpscript:- hexo gafter_script:- cd ./public- git init- git config user.name "laodaoduo"- git config user.email "2295990355@qq.com"- git add .- git commit -m "Update docs"- git push --force --quiet "https://$&#123;GitHub_TOKEN&#125;@$&#123;GH_REF&#125;" master:master# E: Build LifeCycleenv:global:- GH_REF: github.com/laodaoduo/laodaoduo.github.io.git 最后可以测试看看了 参考链接]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的Apache服务]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8B%E7%9A%84Apache%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Mac自带apache服务 在/usr/sbin/apachectl文件夹下 123456开启$ sudo /usr/sbin/apachectl start关闭$ sudo /usr/sbin/apachectl stop重启$ sudo /usr/sbin/apachectl restart 默认打开地址 1/Library/WebServer/Documents/ 可将测试文件放在上面的文件夹下 如果不方便的话可到配置文件更改Document地址 1$ vim /etc/apache2/httpd.conf 找到DocumentRoot “/Library/WebServer/Documents”更改即可]]></content>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与GitHub搭建个人博客]]></title>
    <url>%2F2017%2F07%2F05%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo与GitHub搭建个人博客过程 创建GitHub仓库,名字为: GitHub昵称.github.io 添加秘钥 1.0 终端用以下命令 按提示 生成秘钥 公钥 生成的文件 保存在 ~/.ssh 文件夹下 $ ssh-keygen -t rsa -C &quot;2295990355@qq.com&quot; 参数-t:是加密类型 -C:提供一个新注释 2.0 将公钥复制到GitHub上 https://github.com/settings/keys 安装node.js node.js官网 里面有通用版与最新版 两个版本 选择一个下载安装即可 我这里是在终端用brew安装$ brew install node 安装之后可以创建js文件测试 123456789var http = require('http');http.createServer(function (req, res) &#123;res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);res.end('Hello World\n');&#125;).listen(8124, "127.0.0.1");console.log('Server running at http://127.0.0.1:8124/');--------------------------------------------------------测试$ node ~/js文件 安装Hexo $ npm install -g hexo-cli 配置 建立一个博客文件夹，为文件夹的名称,到自己对应的博客文件夹下依次执行以下命令 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 写一个博客试试 12$ hexo new "文章标题"$ hexo s 打开网址http://localhost:4000/ 上传github ssh配置 就不说了 修改博客_config.yml文件 主要有二处 12345678910111213一、# Sitetitle: LWJsubtitle: 临帝子之长洲， 得天人之旧馆。 层峦耸翠， 上出重霄； 飞阁流丹， 下临无地。 鹤汀凫渚， 穷岛屿之萦回； 桂殿兰宫， 即冈峦之体势。description:author: LWJ_wenlanguage: zh_CNtimezone: Asia/Shanghai二、deploy: type: git repo: https://github.com/laodaoduo/laodaoduo.github.io.git branch: master 第一次上传的时候会让输入你的GitHub用户名密码 遇到的一些坑 报错信息:(node:1134) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.原因我新建了一个文件 里面都是shell脚本 可能是不能识别 报错了 (node:1299) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. ERROR Deployer not found: git 解决办法: npm install hexo-deployer-git –save]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods的安装过程]]></title>
    <url>%2F2017%2F01%2F01%2Fcocoapods%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[新mac电脑上cocoapods的安装过程 升级gem1sudo gem update --system 安装rvm123curl -L get.rvm.io | bash -s stablesource ~/.bashrcsource ~/.bash_profile 安装homebrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ruby升级1rvm install x.x.x 设置默认版本 1rvm use 2.4.0 --default 安装cocoapods查看当前源1gem sources -l 移除默认的ruby源1gem sources --remove https://rubygems.org/ 更改为国内源1gem sources -a https://gems.ruby-china.org/ 安装1sudo gem install cocoapods 成功之后执行pod setup测试 pod search AFNetworking报错：Unable to find a pod with name, author, summary, or description matching SDWebImage解决办法：rm ~/Library/Caches/CocoaPods/search_index.json再次测试 ok出现上面错误的原因是因为你在没有完全安装好cocoapods的时候执行的search操作]]></content>
      <tags>
        <tag>Pod</tag>
      </tags>
  </entry>
</search>
