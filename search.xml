<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[swift开发之算法]]></title>
    <url>%2F2019%2F08%2F05%2Fswift%E5%BC%80%E5%8F%91%E4%B9%8B%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序123456789101112func sort(_ list: inout [Int],_ n: Int) &#123; if n&lt;=1 &#123;return&#125; for i in 0..&lt;n &#123; for j in 0..&lt;n-i-1 &#123; if list[i] &gt; list[j+1] &#123; list.swapAt(j, j+1) print(j) &#125; &#125; &#125;&#125; 插入排序123456789101112131415161718192021222324*///class InsertSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var j = 0 // 每次取出后面未排序的数组的第一个值 与前面有序数组的进行比较 插入到相应的位置 for i in 1 ..&lt; list.count &#123; j = i while j &gt; 0 &#123; if list[j] &lt; list[j-1] &#123; list.swapAt(j-1, i) j = j - 1 &#125;else&#123; // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环 break &#125; &#125; &#125; return list &#125;&#125; 选择排序12345678910111213141516171819202122232425262728293031// 选择排序 // 时间复杂度永远是n*n func chooseSort(_ list: inout [Int], _ n: Int) &#123; // 数组长度大于一才排序 if n &lt;= 1 &#123; return &#125; var min = 0 var index = 0// 为false，断言被触发，终止应用。// 当条件可能为假时使用断言，但是最终一定要保证条件为真，这样你的代码才能继续运行。断言的适用情景：//// 整数类型的下标索引被传入一个自定义小标实现，但是下标索引值可能太小或者太大// 需要给函数传入一个值，但是非法的值可能导致函数不能正常执行// 一个可选值现在是nil，但是后面的代码运行需要一个非nil值 assert(index != -1, &quot;A person&apos;s age cannot be less than zero&quot;) for i in 0 ..&lt; n &#123; min = list[i] index = i for j in i ..&lt; n &#123; // 每次找到未排序数字的最小值 if list[j] &lt; min &#123; // 如果找到一个比min小的值 就赋值给min 并且记录这个值的索引 直到这层循环结束 找到的就是最小的 min = list[j] index = j &#125; &#125; // 找到最小值之后放在前面（已经排序数组的最后面） list.swapAt(i, index) &#125; &#125; 希尔排序 希尔排序（把数组通过步长（step）分成 n/step个小数组数组，再分别对这些小数组进行插入排序，直到步长等于0结束） [2,35,56,767,989,0,45,345] [0,4][1,5],[2,6],[3,7] [0,2,4,6][1,3,5,7] [0,1,2,3,4,5,6,7] 123456789101112131415161718192021222324class ShellSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var step = list.count / 2 var j = 0 // 步长等于0结束 while step &gt; 0 &#123; for i in step ..&lt; list.count &#123; j = i while j &gt;= step &#123; if list[j] &lt; list[j-step] &#123; list.swapAt(j-step, j) j = j - step &#125;else&#123; // 因为j前面的是有序数组 所以找到之后找到之后就可以结束这层循环 break &#125; &#125; &#125; step = step / 2 //缩小步长 &#125; return list &#125;&#125; 归并排序 分而治之的思想 先把整体分割成n个只有一个数据数组 这时候是有序的 将这些有序的数组两两结合成有序数组 重复上面的操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class MergeSort: SortType &#123; func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; // 拆分一个数组 为n个有序数组 放在一个大数组里面 var totalArr: Array&lt;Array&lt;Int&gt;&gt; = [] for item in list &#123; var subArray: Array&lt;Int&gt; = [] subArray.append(item) totalArr.append(subArray) &#125; // 重复拆分工作 直到就剩一个数组 while totalArr.count != 1 &#123; // 每次走完一遍 重新从0开始 var i = 0 while i &lt; totalArr.count - 1 &#123; // 两两合并 totalArr[i] = mergeArray(firstList: totalArr[i], secondList: totalArr[i+1]) totalArr.remove(at: i + 1) i = i + 1 &#125; &#125; return totalArr[0] &#125; // 合并两个有序数组 func mergeArray(firstList: Array&lt;Int&gt;, secondList: Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var resultList: Array&lt;Int&gt; = [] var firstIndex = 0 var secondIndex = 0 while firstIndex &lt; firstList.count &amp;&amp; secondIndex &lt; secondList.count &#123; if firstList[firstIndex] &lt; secondList[secondIndex] &#123; resultList.append(firstList[firstIndex]) firstIndex = firstIndex + 1 &#125;else&#123; resultList.append(secondList[secondIndex]) secondIndex = secondIndex + 1 &#125; &#125; // 如果其中一个数组还有数据没有放进结果数组里面 就把剩下的放进去 while firstIndex &lt; firstList.count &#123; resultList.append(firstList[firstIndex]) firstIndex = firstIndex + 1 &#125; while secondIndex &lt; secondList.count &#123; resultList.append(secondList[secondIndex]) secondIndex = secondIndex + 1 &#125; return resultList &#125;&#125; 快速排序123456789101112131415161718192021222324252627282930313233343536373839// 分而治之的思想 func quickSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; let pivot = array[array.count/2] let left = array.filter&#123; $0 &lt; pivot &#125; let middle = array.filter&#123; $0 == pivot &#125; let right = array.filter&#123; $0 &gt; pivot &#125; return quickSort(left) + middle + quickSort(right) &#125;// 降低空间复杂度的快排 func quickSortPro(_ array: inout [Int], _ n: Int) &#123; quickSortC(&amp;array, 0, n-1) &#125; func quickSortC(_ array: inout [Int], _ left: Int, _ right: Int) &#123; if left &gt; right &#123; return &#125; let pivot = partition(&amp;array, left, right) quickSortC(&amp;array, left, pivot - 1) quickSortC(&amp;array, pivot + 1, right) &#125; func partition(_ array: inout [Int], _ left: Int, _ right: Int) -&gt; Int &#123; let pivot = array[right] var i = left for j in left ..&lt; right &#123; if array[j] &lt; pivot &#123; array.swapAt(j, i) i = i + 1 &#125; &#125; array.swapAt(i, right) return i &#125; 桶排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283class BucketSort: SortType &#123;// inout修饰的参数是不能有默认值的，有范围的参数集合也不能被修饰；// 一个参数一旦被inout修饰，就不能再被var和let修饰了。// 1.监测属性,其实是给存储属性上添加的一种监测功能,willSet 监测新值,didSet 监测旧值// 2.如果函数的参数是inout 修饰的,你如果将监测的属性传入这个函数的时候,此时会将属性的值拷贝一份,在函数结束的时候,将值重新付给属性,所以函数执行完毕后,会触发监测函数 func sort(list: inout Array&lt;Int&gt;) -&gt; Array&lt;Int&gt; &#123; var bucket = createBucket() let maxNumber = listMaxItem(arr: list) let maxLeagth = numberLength(number: maxNumber) for digit in 1 ... maxLeagth &#123; // 入桶操作 for item in list &#123; let baseNum = fetchBaseNumber(number: item, digit: digit) // 根据基数放入对应的桶中 bucket[baseNum].append(item) &#125; var index = 0 // 出桶 for i in 0..&lt;bucket.count &#123; while !bucket[i].isEmpty &#123; list[index] = bucket[i].remove(at: 0) index = index + 1 &#125; &#125; &#125; return list &#125; /// 创建十个桶 /// /// - Returns: 放着十个桶的数组 func createBucket() -&gt; Array&lt;Array&lt;Int&gt;&gt;&#123; var buckets: Array&lt;Array&lt;Int&gt;&gt; = [] for _ in 0 ..&lt; 10 &#123; buckets.append([]) &#125; return buckets &#125; /// 取到最大值 /// /// - Parameter arr: 数组 /// - Returns: 最大值 func listMaxItem(arr : Array&lt;Int&gt;) -&gt; Int &#123; var max = arr[0] for item in arr &#123; if max &lt; item &#123; max = item &#125; &#125; return max &#125; /// 返回最大数字的长度 /// /// - Parameter number: 最大值 /// - Returns: 长度 func numberLength(number: Int) -&gt; Int &#123; return &quot;\(number)&quot;.count &#125; /// 获取相应位上的数字 /// /// - Parameters: /// - number: 操作的数字 /// - digit: 位数 /// - Returns: 返回该位上的数字 func fetchBaseNumber(number: Int, digit: Int) -&gt; Int &#123; if digit &gt; 0 &amp;&amp; digit &lt;= numberLength(number: number)&#123; var numArr: Array&lt;Int&gt; = [] for char in &quot;\(number)&quot; &#123; numArr.append(Int(&quot;\(char)&quot;)!) &#125; return numArr[numArr.count - digit] &#125; return 0 &#125;&#125; 经典之作 二分法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// while循环实现// Comparable协议继承于Equatable，实现Comparable协议可以在Equatable的基础上使类型支持&gt;，&gt;=，&lt;，&lt;=四种运算符extension Array where Element: Comparable &#123; public var isSorted: Bool&#123; var previousIndex = startIndex var currentIndex = previousIndex + 1 while currentIndex != endIndex &#123; if self[previousIndex] &gt; self[currentIndex]&#123; return false &#125; previousIndex = currentIndex currentIndex = currentIndex + 1 &#125; return true &#125; func binarySearch&lt;T: Comparable&gt;(sortedElements: [T], for element: T) -&gt; Bool &#123; assert(sortedElements.isSorted) var m = 0, n = sortedElements.count - 1 // 二分法 while m &lt; n &#123; let mid = (n-m)/2 + m if sortedElements[mid] == element &#123; return true &#125; else if sortedElements[mid] &lt; element &#123; m = mid + 1 &#125; else &#123; n = mid - 1 &#125; &#125; return false &#125;&#125;// 递归实现 二分法 var sortedElements2 = [1,2,3,4,23,24,56,78] var element = 56 func digui(_ m: Int, _ n: Int) -&gt;Int &#123; let mid = (n-m)/2 + m var mm = m var nn = n if mm&gt;nn &#123; return -1; &#125; if sortedElements2[mid] == element &#123; return mid; &#125; else if sortedElements2[mid] &lt; element &#123; mm = mid + 1 &#125; else &#123; nn = mid - 1 &#125; return digui(mm, nn) &#125; 递归实现1到n的和123456789101112func sum(n: Int) -&gt; Int &#123; if n == 0 &#123; print(&quot;000000&quot;) return 0 &#125;else if n == 1 &#123; print(&quot;111111111&quot;) return 1 &#125;else &#123; print(&quot;\(n)&quot;) return (sum(n:(n-1)) + n) &#125; &#125; 不借用第三方变量实现交换两个变量123456789a = a + bb = a - ba = a - b///////////// 按位异或a = a ^ bb = b ^ aa = a ^ b 找出数组中的两个数据值和等于 一个确定的值12345678910111213//func choseTwo(numsArr: [Int], targetValue: Int) -&gt; [Int] &#123; var dic = [Int: Int]() for (i,num) in numsArr.enumerated() &#123; if let index = dic[targetValue - num] &#123; return [index, i] &#125;else &#123; // 值为键 索引为值 储存数据 dic[num] = i &#125; &#125; return []&#125; 参考 ：https://www.cnblogs.com/ludashi/p/6065086.html http://developer.51cto.com/art/201403/430986.htm https://www.cnblogs.com/jingmoxukong/p/4303826.html https://www.jianshu.com/p/77ba54a46ad7]]></content>
  </entry>
  <entry>
    <title><![CDATA[swift开发之可POP]]></title>
    <url>%2F2019%2F08%2F03%2Fswift%E5%BC%80%E5%8F%91%E4%B9%8B%E5%8F%AFPOP%2F</url>
    <content type="text"><![CDATA[OOP的优点 封装与权限控制 .h声明公用的变量方法，.m声明私有变量和方法 public/internal/fileprivate/private 命名空间 OC没有命名空间，swift有命名空间 扩展性 extension category 另外通过代理实现更加灵活的扩展 继承多态 公用的方法变量写在父类中，继承的子类根据需求实现对应的功能 OOP的缺点 隐式共享 class是引用类型，当在代码中的改变了实例变量的时候，另一处调用此变量收到修改的影响 冗杂的父类 代码的迭代，父类越来越冗杂，职权不明确、依赖严重 多继承 POP的优点 更加灵活 不再有冗杂的父类，通过不同的协议实现]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift for循环]]></title>
    <url>%2F2019%2F07%2F25%2Fswift-for%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[for12345678910111213141516171819202122232425// &lt;font color=&quot;red&quot;&gt;闭区间&lt;/font&gt; let arr = [1, 32, 2, 3, 4] for i in 1...3 &#123; i &#125; // 前闭后开 for j in 1..&lt;3 &#123; j &#125; // 返回元组 for (i, value) in arr.enumerated() &#123; i value &#125; // 跳步循环 for i in stride(from: -5, to: 5, by: 0.1) &#123; sin(i) &#125; // 反向循环 for p in arr.reversed() &#123; p &#125; 闭区间]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS更换项目名]]></title>
    <url>%2F2019%2F07%2F19%2FiOS%E6%9B%B4%E6%8D%A2%E9%A1%B9%E7%9B%AE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# encoding: UTF-8#!/usr/bin/rubyrequire &apos;fileutils&apos;require &apos;active_support/all&apos;OLD_PREFIX = &quot;SetNickNameVC&quot;NEW_PREFIX = &quot;LHGJResetPswVC&quot;FOLDER_EXCLUDE = [&quot;Pods&quot;, &quot;.framework&quot;]CONTENT_EXCLUDE = [&quot;.xcuserstate&quot;, &quot;.a&quot;, &quot;.mp3&quot;, &quot;.avi&quot;, &quot;.mp4&quot;, &quot;.wmv&quot;, &quot;.webp&quot;, &quot;.png&quot;, &quot;.jpg&quot;, &quot;.rb&quot;]# REGEXP = &quot;([^a-zA-Z_0-9]|^)#&#123;OLD_PREFIX&#125;([A-Z].*?)&quot;REGEXP = &quot;#&#123;OLD_PREFIX&#125;(.*?)&quot;NEW_STRING = &apos;\1&apos;+NEW_PREFIX+&apos;\2&apos;def search(dir) Dir[File.join(dir, &apos;*&apos;)].each do |file| unless FOLDER_EXCLUDE.include?(File.extname(file).empty? ? File.basename(file) : File.extname(file)) # 非排除的文件夹，才进入搜索 if File.directory?(file) search(file) end end if File.file?(file) search_content(file) end filename = File.basename(file) new_filename = filename.gsub(Regexp.new(REGEXP), NEW_STRING) if filename != new_filename dirname = File.dirname(file) new_file = File.join(dirname, new_filename) puts &quot;重命名文件: #&#123;file&#125; -&gt; #&#123;new_file&#125;&quot; File.rename(file, new_file) end endenddef search_content(file) # 不对排查的文件进行内容替换 return if CONTENT_EXCLUDE.include?(File.extname(file)) encoding = `file -I &quot;#&#123;file&#125;&quot;`.strip.split(&apos;charset=&apos;).last encoding = &quot;utf-8&quot; if encoding.empty? puts &quot;分析: #&#123;file&#125; (#&#123;encoding&#125;)&quot; content = File.open(file, &quot;rb:#&#123;encoding&#125;&quot;, &amp;:read) reg = Regexp.new(REGEXP.encode(encoding)) new_content = content.gsub(reg, NEW_STRING.encode(encoding)) if content != new_content File.open(file, &quot;w:UTF-8&quot;) do |f| f.write(new_content) end puts &quot;更新文件内容: #&#123;file&#125;&quot; endendsearch(Dir.pwd) 将以上脚本copy到rename.rb文件放在项目目录下 OLD_PREFIX、 NEW_PREFIX 分别填写你想要改的名字 执行 ruby rename.rb 即可 如果项目集成了cocoapod这时候会报错 只需要重新pod install即可]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Run Script]]></title>
    <url>%2F2019%2F07%2F19%2FRun-Script%2F</url>
    <content type="text"><![CDATA[譬如启动页动态加载版本号12345# 获取当前版本号# PlistBuddy plist操作工具 可用来对plist文件增删改查versionNumber=$(/usr/libexec/PlistBuddy -c &quot;Print :CFBundleShortVersionString&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)# sed是一个非交互性文本流编辑器，可以与vi一样对文本进行编辑，但其可以在命令行或shell脚本中执行，从而避免了繁重的人机交互式的文件编辑操作sed -i bak -e &quot;/userLabel=\&quot;AppVersion\&quot;/s/text=\&quot;[^\&quot;]*\&quot;/text=\&quot;版本号：$versionNumber\&quot;/&quot; $PROJECT_DIR/LHGJiOS/Base.lproj/LaunchScreen.storyboard 常用的脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970每次构建的时候build号自增if [ $CONFIGURATION == Release ]; then echo &quot;Bumping build number...&quot; plist=$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125; #increment the build number (ie 115 to 116) buildnum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;plist&#125;&quot;) if [[ &quot;$&#123;buildnum&#125;&quot; == &quot;&quot; ]]; then echo &quot;No build number in $plist&quot; exit 2 fi buildnum=$(expr $buildnum + 1) /usr/libexec/Plistbuddy -c &quot;Set CFBundleVersion $buildnum&quot; &quot;$&#123;plist&#125;&quot; echo &quot;Bumped build number to $buildnum&quot; echo &quot;开始自增 Version 最后一位&quot; versionNum=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleShortVersionString&quot; &quot;$&#123;plist&#125;&quot;) # 取出第三个值 thirdPartVersonNum=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $3&#125;&apos;` thirdPartVersonNum=$(($thirdPartVersonNum + 1)) newVersionStr=`echo $versionNum | awk -F &quot;.&quot; &apos;&#123;print $1 &quot;.&quot; $2 &quot;.&apos;$thirdPartVersonNum&apos;&quot; &#125;&apos;` /usr/libexec/PlistBuddy -c &quot;Set CFBundleShortVersionString $newVersionStr&quot; &quot;$&#123;plist&#125;&quot;else echo $CONFIGURATION &quot; build - Not bumping build number.&quot;fi根据bundleID不同，设置不同的jpush appkey等#!/bin/bashbundleID=$&#123;PRODUCT_BUNDLE_IDENTIFIER&#125;id=&quot;com.zhoumoquan.zhoumoquan&quot;if [&quot;$bundleID&quot;=&quot;$id&quot;]; thencp zmq/PushConfig_AppStore.plist zmq/PushConfig.plistelsecp zmq/PushConfig_Enterprise.plist zmq/PushConfig.plistfi打包上传时移除第三方库中无用的部分APP_PATH=&quot;$&#123;TARGET_BUILD_DIR&#125;/$&#123;WRAPPER_NAME&#125;&quot;# This script loops through the frameworks embedded in the application and# removes unused architectures.find &quot;$APP_PATH&quot; -name &apos;*.framework&apos; -type d | while read -r FRAMEWORKdoFRAMEWORK_EXECUTABLE_NAME=$(defaults read &quot;$FRAMEWORK/Info.plist&quot; CFBundleExecutable)FRAMEWORK_EXECUTABLE_PATH=&quot;$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME&quot;echo &quot;Executable is $FRAMEWORK_EXECUTABLE_PATH&quot;EXTRACTED_ARCHS=()for ARCH in $ARCHSdoecho &quot;Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME&quot;lipo -extract &quot;$ARCH&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot; -o &quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;EXTRACTED_ARCHS+=(&quot;$FRAMEWORK_EXECUTABLE_PATH-$ARCH&quot;)doneecho &quot;Merging extracted architectures: $&#123;ARCHS&#125;&quot;lipo -o &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; -create &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;rm &quot;$&#123;EXTRACTED_ARCHS[@]&#125;&quot;echo &quot;Replacing original executable with thinned version&quot;rm &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;mv &quot;$FRAMEWORK_EXECUTABLE_PATH-merged&quot; &quot;$FRAMEWORK_EXECUTABLE_PATH&quot;done Xcode Run Script Phase，有很多环境变量。 可以添加一个 Run Script,添加一条命令：env 编译之后就可以再编译报告里看到输出的环境变量]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS崩溃日志符号化]]></title>
    <url>%2F2019%2F07%2F19%2FiOS%E5%B4%A9%E6%BA%83%E6%97%A5%E5%BF%97%E7%AC%A6%E5%8F%B7%E5%8C%96%2F</url>
    <content type="text"></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS交互之WKWebView]]></title>
    <url>%2F2019%2F07%2F18%2FiOS%E4%B8%8EJS%E4%BA%A4%E4%BA%92%E4%B9%8BWKWebView%2F</url>
    <content type="text"><![CDATA[iOS调js12两端提前协议号方法参数[self.webView evaluateJavaScript:@&quot;ocToJs(&apos;loginSucceed&apos;, &apos;oc_tokenString&apos;)&quot; completionHandler:^(id response, NSError *error) &#123;&#125;]; js调oc123456789101112131415161718192021222324WKScriptMessageHandler oc端实现此协议下的方法：- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message;、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、@interface WKScriptMessage : NSObject/*! @abstract The body of the message. @discussion Allowed types are NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull. */@property (nonatomic, readonly, copy) id body;/*! @abstract The web view sending the message. */@property (nullable, nonatomic, readonly, weak) WKWebView *webView;/*! @abstract The frame sending the message. */@property (nonatomic, readonly, copy) WKFrameInfo *frameInfo;/*! @abstract The name of the message handler to which the message is sent. */@property (nonatomic, readonly, copy) NSString *name;@end name判断是否是提前定义好的方法 body里面是想要的参数 我会对body做进一步的处理 这主要看自己和后台的定义 123456NSData * data = [body dataUsingEncoding:NSUTF8StringEncoding]; NSError * err;id jsonData = (NSDictionary *)[NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingMutableContainers error:&amp;err];if (err) &#123; jsonData = body;&#125; 加载网页过程的高度进度等控制12345678910111213141516- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@&quot;estimatedProgress&quot;]) &#123; CGFloat newprogress = [[change objectForKey:NSKeyValueChangeNewKey] doubleValue]; !self.getWebEswebEtimatedProgress?:self.getWebEswebEtimatedProgress(newprogress); &#125;else if ([keyPath isEqualToString:@&quot;title&quot;]) &#123; NSString * webTitle = [change objectForKey:NSKeyValueChangeNewKey]; !self.getWebTitle?:self.getWebTitle(webTitle); &#125;else if ([keyPath isEqualToString:NSStringFromSelector(@selector(contentSize))]) &#123; //sizeThatFits: 返回一个合适的大小以布局，默认实现是返回当前视图的已知大小 CGSize webViewSize = self.wkWebView.scrollView.contentSize; if (_observeScrollHeight) &#123; _observeScrollHeight(webViewSize.height); &#125; &#125;&#125; 网页加载成功后的高度回调123456789101112///网页加载成功- (void)webView:(WKWebView *)webView didFinishNavigation:(WKNavigation *)navigation&#123; !self.didFinishNavigation?:self.didFinishNavigation(); /* 获取webView的高度 @&quot;document.body.scrollHeight&quot; @&quot;document.body.offsetHeight&quot; @&quot;document.body.clientHeight&quot;*/ __weak typeof(self) weakSelf = self; [webView evaluateJavaScript:@&quot;document.body.scrollHeight&quot; completionHandler:^(id h, NSError * _Nullable error) &#123; __strong typeof(self) strongSelf = weakSelf; if (!error) &#123; !strongSelf.getWebDocumentBodyScrollHeight?:strongSelf.getWebDocumentBodyScrollHeight([h floatValue]); &#125; &#125;];&#125; 参考 https://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA?]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS 重签名]]></title>
    <url>%2F2019%2F07%2F05%2FiOS-%E9%87%8D%E7%AD%BE%E5%90%8D%2F</url>
    <content type="text"><![CDATA[xcode Profiles地址 ~/Library/MobileDevice/Provisioning Profiles 签名的基本流程1、在Mac上生成一对公私钥，这里称公钥M，私钥M。 2、苹果自己有固定的一对公私钥，跟上面AppStore例子一样，私钥在苹果后台，公钥内置在每个iOS设备上，这里称为公钥A，私钥A。 3、把公钥M上传到苹果后台，用苹果后台里的私钥A去签名公钥M。得到一份数据包含了公钥M以及其签名（也就是公钥的HASH值），把这份数据称为证书。 4、在开发时，编译完一个App后，用本地的私钥M对这个App进行签名，同时把第三步得到的证书一起打包进App里，安装到手机。 5、在安装时，iOS系统取得证书，通过系统内置的公钥A，去验证证书的数字签名是否正确。 验证证书确保公钥M是苹果认证过的，再用公钥M去验证App的签名，这里就间接验证了这个App的安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证App是否被改动，因为开发阶段App内容总是不断变化的，苹果不需要管）。 https://www.jianshu.com/p/fc56a70ee4fb plis文件的生成 根据mobileprovision生成相关的plistsecurity cms -D -i 123.mobileprovision &gt; embedded.plist 根据plist 截取其中的Entitlements部分/usr/libexec/PlistBuddy -x -c &#39;Print:Entitlements&#39; embedded.plist &gt; entitlements.plist 签名脚本1234567891011121314151617181920212223242526272829303132333435#!/bin/shif ! ([ -f &quot;$1&quot; ]); thenecho ----- \&quot;$&#123;1&#125;\&quot;文件不存在exitfiipaName=$&#123;1%.ipa&#125;if [ &quot;$ipaName&quot; = &quot;$1&quot; ]; thenecho ----- \&quot;$&#123;1&#125;\&quot;error 不是ipa文件exitfi## step 1 解压ipaunzip $&#123;ipaName&#125;.ipa## step 2 删除旧签名文件rm -rf Payload/*.app/_CodeSignature/## step 3 拷贝证书配置和权限文件cp embedded.mobileprovision Payload/*.app/embedded.mobileprovisioncp entitlements.plist Payload/*.app/## step 4 重签名(/usr/bin/codesign -f -s &quot;Iris Info-Tech(Shanghai) Co.,Ltd&quot; --entitlements Payload/*.app/entitlements.plist Payload/*.app/) || &#123;rm -rf Payload/rm -rf __MACOSX/exit&#125;## step 5 打包zip -r $&#123;ipaName&#125;_resign.ipa Payload/rm -rf Payload/rm -rf __MACOSX/ 签名工具iReSign]]></content>
      <tags>
        <tag>重签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods制作自己的Pod库]]></title>
    <url>%2F2019%2F06%2F12%2FCocoapods%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84Pod%E5%BA%93%2F</url>
    <content type="text"><![CDATA[整体流程 GitHub上创建仓库 test 克隆仓库到本地 在仓库下面建项目（即你要开放的代码） 创建.podspec文件 pod spec create test 编辑.podspec文件 123456789101112131415161718Pod::Spec.new do |s| s.name = &quot;WJDetailHeaderView&quot; s.version = &quot;1.0.1&quot; s.summary = &quot;标详情页的头部&quot; # 这个必须得写否则会报错 并且要比summary长 s.description = &lt;&lt;-DESC 这是新建的标信息仓库 DESC s.homepage = &quot;https://github.com/lbrjms/WJDetailHeaderView&quot; s.license = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;FILE_LICENSE&quot; &#125; s.author = &#123; &quot;lwj_code&quot; =&gt; &quot;wallien@163.com&quot; &#125; s.platform = :ios, &quot;8.0&quot; s.source = &#123; :git =&gt; &quot;https://github.com/lbrjms/WJDetailHeaderView.git&quot;, :tag =&gt; s.version &#125; s.source_files = &quot;Classes&quot;, &quot;WJDetailHeaderView/WJDetailHeaderView/DetailHeaderView.swift&quot; # 指定swift的版本 否则有警告 s.swift_version = &apos;3.2&apos;end 项目打源码tag并上传git 123456git add .git statusgit commit -m &quot;this is 1.0.0&quot;git tag &apos;1.0.0&apos;git push --tagsgit push origin master 验证podspec 1pod spec lint 注册pod 123pod trunk register wallien@163.com &quot;lwj_code&quot;注册之后记得邮箱认证 发布pod 1pod trunk push test.podspec 到这里没问题就是成功了 遇到的问题xcrun: error: unable to find utility “simctl”, not a developer tool or in PATH ) during validation 到xcode的偏好设置里面设置command line tools： Xcode&gt;preferences&gt;Locations里面，设置之后再运行终端即可]]></content>
      <tags>
        <tag>Pod</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSS订阅打开都是xml的问题]]></title>
    <url>%2F2019%2F06%2F06%2FRSS%E8%AE%A2%E9%98%85%E6%89%93%E5%BC%80%E9%83%BD%E6%98%AFxml%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装rss插件 npm install hexo-generator-feed 在这个各种信息混杂的时代，rss真的感觉是一股清流，我们可以通过这个功能订阅自己先看的文章，节目…. 刚接触rss遇到最多的问题就是点击网站的rss订阅 显示的都是xml代码，这是由于没有安装RSS客户端 或是没有支持RSS的插件 如果是google浏览器可以安装feeder插件挺好用 https://juejin.im/post/5c382a326fb9a049f15469eb https://www.inoreader.com/]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MD常用语法]]></title>
    <url>%2F2019%2F06%2F05%2Fmd%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[md简单语法二级标题三级标题四级标题五级标题六级标题无序列表//形式一 a b c //形式二 d e f //形式三 g h i 无序列表嵌套 123 abc bcd cde 465 789 有序列表嵌套 abcd abcde abcde abcde bcde cdef 引用 引用内容、说明内容。在语句前面加一个 &gt; ，注意是英文的那个右尖括号，注意空格，引用因为是一个区块，理论上是应该什么内容都可以放，比如说：标题，列表，引用等等。 一级引用 二级引用 三级引用 四级引用 五级引用 六级引用 代码块NSOpenPanel* openDlg = [NSOpenPanel openPanel] 1234567891011121314NSOpenPanel* openDlg = [NSOpenPanel openPanel];[openDlg setCanChooseFiles:TRUE];[openDlg setCanChooseDirectories:FALSE];[openDlg setAllowsMultipleSelection:FALSE];[openDlg setAllowsOtherFileTypes:FALSE];[openDlg setAllowedFileTypes:@[@&quot;ipa&quot;, @&quot;IPA&quot;, @&quot;xcarchive&quot;]];if ([openDlg runModal] == NSOKButton)&#123; NSString* fileNameOpened = [[[openDlg URLs] objectAtIndex:0] path]; [pathField setStringValue:fileNameOpened];&#125; 链接 行内式链接的文字放在[]中，链接地址放在随后的()中，链接也可以带title属性，链接地址后面空一格，然后用引号引起来 简书, 是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流 参数式链接的文字放在[]中，链接地址放在随后的:后，链接地址后面空一格，然后用引号引起来 简书是一个创作社区,任何人均可以在其上进行创作。用户在简书上面可以方便的创作自己的作品,互相交流。 //参数定义的其他写法 分割线至少三个字符 斜体 加粗 删除线mdmd mdmd 删除 表格//例子一 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子二 123 234 345 abc bcd cde abc bcd cde abc bcd cde //例子三 123 234 345 abc bcd cde abc bcd cde abc bcd cde]]></content>
      <categories>
        <category>文章</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo + GitHubPages搭建个人博客]]></title>
    <url>%2F2019%2F06%2F05%2FGitHub-Pages-Hexo%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[创建github仓库 创建一个github仓库 仓库名必须与用户名相同 之后的博客地址就是：http://username.github.io 配置sshGit可以通过https和ssh两种方式连接服务器上的仓库。ssh的方式会在传输前压缩数据，这样传输的效率很高。而且不需要每次都输入账号和密码。 git的用户名和邮箱设置 12$ git config --global user.name &quot;your name”$ git config --global user.email &quot;your email&quot; 查看本地是否有ssh密钥（有这些文件说明已经有了id_rsa，id_rsa.pubknown_hosts），如果没有就自己生成 1cd ~/.ssh 12生成ssh命令 根据提示一步步操作即可ssh-keygen -t rsa -C “your email” vim打开公钥文件 复制共钥到github的设置里面 1vim id_rsa.pub 安装Hexo环境12345678910// 安装hexonpm install hexo-cli -g// 初始化一个blog文件夹hexo init blog// 到blog文件夹下启动服务 之后就可以在http://localhost:4000 看的你的博客cd blognpm installhexo server 配置Deployment 修改blog文件夹下的_config.yml文件 1234567# Deployment## Docs: https://hexo.io/docs/deployment.html### :号后面都要有空格 否则hexo d的时候会没反应deploy:type:gitrepo:git@github.com:你的github账号/你的github账号.github.io.gitbranch:master 生成新的public文件 12hexo clean //删除旧的public文件hexo generate / hexo g //生成新的public文件 部署到github上1hexo deploye / hexo d 到此就初步完成了 在打开https://lbrjms.github.io就可以看到你的博客了 更换主题Â成功之后的第一件事就是更换主题 选择自己喜欢的主题 下载到themes文件夹下面更改_config.yml 的themes 对应的名字就可以了 下面是我clone的主题 123$ git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant$ npm install hexo-renderer-pug --save$ npm install hexo-renderer-sass --save 开启分类 tags 123$$ hexo new page tags$ hexo new page categories 创建文章$ hexo new &quot;title&quot; 关于界面 maupassant主题里有个关于导航菜单，默认点进去是不行的，需要自己新建个。在Hexo的 source 目录新建个 about 文件夹，文件夹里按模板新建个 index.md 更改主题语言支持多种语言 去config文件里面改就可以（我找了半天才找到）其实关于一些设置的东西 大多数都在config里面改]]></content>
      <categories>
        <category>文章</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F06%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Unity gameobject 的 生命周期]]></title>
    <url>%2F2018%2F08%2F08%2FUnity%20gameobject%20%E7%9A%84%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Unity3d 基础学习 脚本生命周期 Awake 脚本被载入是调用 OnEnable 对象变为可用或激活状态时调用 Start 只调用一次 FixedUpdate 固定的时间间隔被调用 不受设备的帧率等的影响 Update 更新 LateUpdate Update之后更新 OnGUI 渲染和处理GUI事件 OnDisable 当前对象不可用或处于非激活状态 脚本或对象被销毁的时候调用 OnDestroy 当物体 或是 脚本 被销毁 常用的方法 gameObt.GetComponent&lt; compomentName &gt; (); 获取到对应的compoment GetComponent ().AddForce (vec3); 给刚体添加力]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全局Pop 隐藏TabBar NavigationBar]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%85%A8%E5%B1%80Pop%20%E9%9A%90%E8%97%8FTabBar%20NavigationBar%2F</url>
    <content type="text"><![CDATA[全局Pop(侧边缘滑动的拓展) 思路:给系统的侧边缘滑动runtime添加target action1234567891011121314151617181920212223242526272829303132333435363738import UIKitclass CustomNavigationController: UINavigationController &#123;override func viewDidLoad() &#123; super.viewDidLoad() // 1. 获取系统的Pop手势 let systemGes = interactivePopGestureRecognizer // 2. 获取手势的view用于添加新的手势 let gesView = systemGes?.view // 3. 获取target/action // 3.1 利用运行时机制获取所有的属性名称 var count : UInt32 = 0 let ivars = class_copyIvarList(UIGestureRecognizer.self, &amp;count)! for i in 0..&lt;count &#123; let ivar = ivars[Int(i)] let name = ivar_getName(ivar)! print(String(cString : name)) &#125; let targets = systemGes?.value(forKey: "_targets") as? [NSObject] let targetObjc = targets?.first // 3.2 取出target guard let target = targetObjc?.value(forKey: "target") else &#123; return &#125; // 3.3 取出action let action = Selector(("handleNavigationTransition:")) // 4. 创建自己的Pan手势 let panGes = UIPanGestureRecognizer() gesView?.addGestureRecognizer(panGes) panGes.addTarget(target, action: action)&#125;&#125; 隐藏tabBarimport UIKit class CustomNavigationController: UINavigationController { override func viewDidLoad() { super.viewDidLoad() } override func pushViewController(_ viewController: UIViewController, animated: Bool) { viewController.hidesBottomBarWhenPushed = true super.pushViewController(viewController, animated: animated) } }隐藏NavigationBarclass ViewController: UIViewController,UIGestureRecognizerDelegate { override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) navigationController?.setNavigationBarHidden(true, animated: true) navigationController?.interactivePopGestureRecognizer?.delegate = self navigationController?.interactivePopGestureRecognizer?.isEnabled = true } override func viewWillDisappear(_ animated: Bool) { super.viewWillDisappear(animated) navigationController?.setNavigationBarHidden(false, animated: true) } override func viewDidLoad() { super.viewDidLoad() } }]]></content>
  </entry>
  <entry>
    <title><![CDATA[swift基础之可选型]]></title>
    <url>%2F2018%2F07%2F30%2Fswift%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%AF%E9%80%89%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334/* * 可选型 * 主要用来表示 没有 这个概念 * 必须显示表达 * 正常会作为var 变量来存在 * 不能被直接使用 因为它有可能是空 会报错 * 被解包才能用 * ! 强制解包 * if let 解包 * ?? * 三目运算符 ? : * 隐式可选型 * var errorCode3: Int! * errorCode3 = nil */// 这不仅仅是整形 还是一个可选性var errorCode: Int? = 404errorCode = 0// 只有可选性才能被赋值为nilerrorCode = nilprint(errorCode)var errorCode2: String? = &quot;404&quot;errorCode2 = &quot;400&quot;&quot;The errorCode is &quot; + (errorCode2 ?? &quot;ss&quot;)errorCode2?.localizedUppercaseif let safeCode = errorCode2 &#123; // if let 的作用就是解包 判断空 解包成功 也就是不为空才会进来 &quot;safe&quot; + safeCode&#125;let ageIntput: String = &quot;23&quot;let age = Int(ageIntput) ?? 0print(age)let greetString = &quot;Hello&quot;greetString.range(of: &quot;o&quot;)]]></content>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各种地图的坐标转换]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%90%84%E7%A7%8D%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%9D%90%E6%A0%87%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[各种地图的坐标转换 123456789101112131415161718192021222324252627282930@interface LWJLocation : NSObject@property (nonatomic, assign) double latitude;@property (nonatomic, assign) double longitude;- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude;/* 坐标系： WGS-84：是国际标准，GPS坐标（Google Earth使用、或者GPS模块） GCJ-02：中国坐标偏移标准，Google Map、高德、腾讯使用 BD-09 ：百度坐标偏移标准，Baidu Map使用 */#pragma mark - 从GPS坐标转化到高德坐标- (id)transformFromGPSToGD;#pragma mark - 从高德坐标转化到百度坐标- (id)transformFromGDToBD;#pragma mark - 从百度坐标到高德坐标- (id)transformFromBDToGD;#pragma mark - 从高德坐标到GPS坐标- (id)transformFromGDToGPS;#pragma mark - 从百度坐标到GPS坐标- (id)transformFromBDToGPS;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#import &lt;CoreLocation/CoreLocation.h&gt;static const double a = 6378245.0;static const double ee = 0.00669342162296594323;static const double pi = M_PI;static const double xPi = M_PI * 3000.0 / 180.0;@implementation LWJLocation- (id)initWithLatitude:(double)latitude andLongitude:(double)longitude &#123; if (self = [super init]) &#123; self.latitude = latitude; self.longitude = longitude; &#125; return self;&#125;- (id)transformFromGPSToGD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromWGSToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromGDToBD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToBaidu:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromBDToGD &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromGDToGPS &#123; CLLocationCoordinate2D coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; return [[LWJLocation alloc] initWithLatitude:coor.latitude andLongitude:coor.longitude];&#125;- (id)transformFromBDToGPS &#123; //先把百度转化为高德 CLLocationCoordinate2D start_coor = [LWJLocation transformFromBaiduToGCJ:CLLocationCoordinate2DMake(self.latitude, self.longitude)]; CLLocationCoordinate2D end_coor = [LWJLocation transformFromGCJToWGS:CLLocationCoordinate2DMake(start_coor.latitude, start_coor.longitude)]; return [[LWJLocation alloc] initWithLatitude:end_coor.latitude andLongitude:end_coor.longitude];&#125;+ (CLLocationCoordinate2D)transformFromWGSToGCJ:(CLLocationCoordinate2D)wgsLoc &#123; CLLocationCoordinate2D adjustLoc; if([self isLocationOutOfChina:wgsLoc]) &#123; adjustLoc = wgsLoc; &#125; else &#123; double adjustLat = [self transformLatWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0]; double adjustLon = [self transformLonWithX:wgsLoc.longitude - 105.0 withY:wgsLoc.latitude - 35.0]; long double radLat = wgsLoc.latitude / 180.0 * pi; long double magic = sin(radLat); magic = 1 - ee * magic * magic; long double sqrtMagic = sqrt(magic); adjustLat = (adjustLat * 180.0) / ((a * (1 - ee)) / (magic * sqrtMagic) * pi); adjustLon = (adjustLon * 180.0) / (a / sqrtMagic * cos(radLat) * pi); adjustLoc.latitude = wgsLoc.latitude + adjustLat; adjustLoc.longitude = wgsLoc.longitude + adjustLon; &#125; return adjustLoc;&#125;+ (double)transformLatWithX:(double)x withY:(double)y &#123; double lat = -100.0 + 2.0 * x + 3.0 * y + 0.2 * y * y + 0.1 * x * y + 0.2 * sqrt(fabs(x)); lat += (20.0 * sin(6.0 * x * pi) + 20.0 *sin(2.0 * x * pi)) * 2.0 / 3.0; lat += (20.0 * sin(y * pi) + 40.0 * sin(y / 3.0 * pi)) * 2.0 / 3.0; lat += (160.0 * sin(y / 12.0 * pi) + 320 * sin(y * pi / 30.0)) * 2.0 / 3.0; return lat;&#125;+ (double)transformLonWithX:(double)x withY:(double)y &#123; double lon = 300.0 + x + 2.0 * y + 0.1 * x * x + 0.1 * x * y + 0.1 * sqrt(fabs(x)); lon += (20.0 * sin(6.0 * x * pi) + 20.0 * sin(2.0 * x * pi)) * 2.0 / 3.0; lon += (20.0 * sin(x * pi) + 40.0 * sin(x / 3.0 * pi)) * 2.0 / 3.0; lon += (150.0 * sin(x / 12.0 * pi) + 300.0 * sin(x / 30.0 * pi)) * 2.0 / 3.0; return lon;&#125;+ (CLLocationCoordinate2D)transformFromGCJToBaidu:(CLLocationCoordinate2D)p &#123; long double z = sqrt(p.longitude * p.longitude + p.latitude * p.latitude) + 0.00002 * sqrt(p.latitude * pi); long double theta = atan2(p.latitude, p.longitude) + 0.000003 * cos(p.longitude * pi); CLLocationCoordinate2D geoPoint; geoPoint.latitude = (z * sin(theta) + 0.006); geoPoint.longitude = (z * cos(theta) + 0.0065); return geoPoint;&#125;+ (CLLocationCoordinate2D)transformFromBaiduToGCJ:(CLLocationCoordinate2D)p &#123; double x = p.longitude - 0.0065, y = p.latitude - 0.006; double z = sqrt(x * x + y * y) - 0.00002 * sin(y * xPi); double theta = atan2(y, x) - 0.000003 * cos(x * xPi); CLLocationCoordinate2D geoPoint; geoPoint.latitude = z * sin(theta); geoPoint.longitude = z * cos(theta); return geoPoint;&#125;+ (CLLocationCoordinate2D)transformFromGCJToWGS:(CLLocationCoordinate2D)p &#123; double threshold = 0.00001; // The boundary double minLat = p.latitude - 0.5; double maxLat = p.latitude + 0.5; double minLng = p.longitude - 0.5; double maxLng = p.longitude + 0.5; double delta = 1; int maxIteration = 30; // Binary search while(true) &#123; CLLocationCoordinate2D leftBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = minLng&#125;]; CLLocationCoordinate2D rightBottom = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = minLat,.longitude = maxLng&#125;]; CLLocationCoordinate2D leftUp = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = maxLat,.longitude = minLng&#125;]; CLLocationCoordinate2D midPoint = [[self class] transformFromWGSToGCJ:(CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;]; delta = fabs(midPoint.latitude - p.latitude) + fabs(midPoint.longitude - p.longitude); if(maxIteration-- &lt;= 0 || delta &lt;= threshold) &#123; return (CLLocationCoordinate2D)&#123;.latitude = ((minLat + maxLat) / 2),.longitude = ((minLng + maxLng) / 2)&#125;; &#125; if(isContains(p, leftBottom, midPoint)) &#123; maxLat = (minLat + maxLat) / 2; maxLng = (minLng + maxLng) / 2; &#125; else if(isContains(p, rightBottom, midPoint)) &#123; maxLat = (minLat + maxLat) / 2; minLng = (minLng + maxLng) / 2; &#125; else if(isContains(p, leftUp, midPoint)) &#123; minLat = (minLat + maxLat) / 2; maxLng = (minLng + maxLng) / 2; &#125; else &#123; minLat = (minLat + maxLat) / 2; minLng = (minLng + maxLng) / 2; &#125; &#125;&#125;#pragma mark - 判断某个点point是否在p1和p2之间static bool isContains(CLLocationCoordinate2D point, CLLocationCoordinate2D p1, CLLocationCoordinate2D p2) &#123; return (point.latitude &gt;= MIN(p1.latitude, p2.latitude) &amp;&amp; point.latitude &lt;= MAX(p1.latitude, p2.latitude)) &amp;&amp; (point.longitude &gt;= MIN(p1.longitude,p2.longitude) &amp;&amp; point.longitude &lt;= MAX(p1.longitude, p2.longitude));&#125;#pragma mark - 判断是不是在中国+ (BOOL)isLocationOutOfChina:(CLLocationCoordinate2D)location &#123; if (location.longitude &lt; 72.004 || location.longitude &gt; 137.8347 || location.latitude &lt; 0.8293 || location.latitude &gt; 55.8271) return YES; return NO;&#125;]]></content>
      <tags>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Runloop]]></title>
    <url>%2F2017%2F07%2F26%2FRunloop%2F</url>
    <content type="text"><![CDATA[可用runloop控制图片加载 卡顿 等问题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#import &quot;ViewController.h&quot;typedef BOOL(^RunloopBlock)(void);@interface ViewController ()/** 存放任务的数组 */@property (nonatomic, retain)NSMutableArray *tasks;/** 最大任务数 */@property (nonatomic, assign)NSUInteger max;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; _max = 18; _tasks = [NSMutableArray array]; [self addRunloopObserver]; NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(timerMothod) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];// dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, &lt;#dispatchQueue#&gt;);// dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, &lt;#intervalInSeconds#&gt; * NSEC_PER_SEC, &lt;#leewayInSeconds#&gt; * NSEC_PER_SEC);// dispatch_source_set_event_handler(timer, ^&#123;// &lt;#code to be executed when timer fires#&gt;// &#125;);// dispatch_resume(timer);&#125;- (void)timerMothod&#123; NSLog(@&quot;timer-----&quot;);&#125;-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123;&#125;- (void)addRunloopObserver&#123;// typedef struct &#123;// CFIndex version;// void * info;// const void *(*retain)(const void *info);// void (*release)(const void *info);// CFStringRef (*copyDescription)(const void *info);// &#125; CFRunLoopObserverContext; // 上下文结构体 CFRunLoopObserverContext context = &#123; 0, (__bridge void *)(self), &amp;CFRetain, &amp;CFRelease, NULL &#125;; // 1.拿到当前的runloop CFRunLoopRef runloop = CFRunLoopGetCurrent(); static CFRunLoopObserverRef defaultModeObserver; // 创建观察者 defaultModeObserver = CFRunLoopObserverCreate(NULL, kCFRunLoopAfterWaiting, YES, 0, &amp;callBack, &amp;context); // 添加当前观察者 CFRunLoopAddObserver(runloop, defaultModeObserver, kCFRunLoopDefaultMode); // c语言与create就要有release CFRelease(defaultModeObserver);&#125;static void callBack(CFRunLoopObserverRef observer, CFRunLoopActivity activity, void *info) &#123; ViewController *vc = (__bridge ViewController *)(info); if (vc.tasks.count==0) return; while (vc.tasks.count) &#123; RunloopBlock unit = vc.tasks.firstObject; [vc.tasks removeObjectAtIndex:0]; &#125;&#125;@end]]></content>
      <tags>
        <tag>Runloop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreMLtest]]></title>
    <url>%2F2017%2F07%2F26%2FCoreMLtest%2F</url>
    <content type="text"><![CDATA[iOS 11 机器学习练习 iOS 11 机器学习练习 图片数据1let imageData = pickImageView.image?.cgImage 用到的模型1let model = try! VNCoreMLModel(for: Resnet50().model) 配置请求12let hander = VNImageRequestHandler(cgImage: imageData!)let request = VNCoreMLRequest(model: model, completionHandler: myResultsMethod) 执行请求1try! hander.perform([request]) 请求的方法 用于model的输入输出123456789func myResultsMethod(request: VNRequest, error: Error?) &#123;guard let results = request.results as? [VNClassificationObservation]else &#123; fatalError("huh") &#125;lable.text = results[0].identifierfor classification in results &#123;print("=====++===" + classification.identifier + "----++----" )&#125;&#125; 1234567891011platform :ios, &quot;8.0&quot;inhibit_all_warnings!use_frameworks!target &apos;RAC_ObjcTest&apos; dopod &apos;ReactiveObjC&apos;pod &apos;XRCarouselView&apos;end]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AR_Swift]]></title>
    <url>%2F2017%2F07%2F26%2FAR-Swift%2F</url>
    <content type="text"><![CDATA[ios 11 出了 ar 体验一把 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import UIKitimport SceneKitimport ARKitclass ViewController: UIViewController, ARSCNViewDelegate &#123; @IBOutlet var sceneView: ARSCNView! override func viewDidLoad() &#123; super.viewDidLoad() // Set the view&apos;s delegate sceneView.delegate = self // Show statistics such as fps and timing information sceneView.showsStatistics = true // Create a new scene let scene = SCNScene(named: &quot;art.scnassets/ship.scn&quot;)! // Set the scene to the view sceneView.scene = scene &#125; override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) // Create a session configuration let configuration = ARWorldTrackingSessionConfiguration() // Run the view&apos;s session sceneView.session.run(configuration) &#125; override func viewWillDisappear(_ animated: Bool) &#123; super.viewWillDisappear(animated) // Pause the view&apos;s session sceneView.session.pause() &#125; override func didReceiveMemoryWarning() &#123; super.didReceiveMemoryWarning() // Release any cached data, images, etc that aren&apos;t in use. &#125; // MARK: - ARSCNViewDelegate/* // Override to create and configure nodes for anchors added to the view&apos;s session. func renderer(_ renderer: SCNSceneRenderer, nodeFor anchor: ARAnchor) -&gt; SCNNode? &#123; let node = SCNNode() return node &#125;*/ func session(_ session: ARSession, didFailWithError error: Error) &#123; // Present an error message to the user &#125; func sessionWasInterrupted(_ session: ARSession) &#123; // Inform the user that the session has been interrupted, for example, by presenting an overlay &#125; func sessionInterruptionEnded(_ session: ARSession) &#123; // Reset tracking and/or remove existing anchors if consistent tracking is required &#125;&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些有用的终端命令]]></title>
    <url>%2F2017%2F07%2F25%2F%E4%B8%80%E4%BA%9B%E6%9C%89%E7%94%A8%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Android_布局]]></title>
    <url>%2F2017%2F07%2F24%2FAndroid-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[LinearLayout RectiveLayout TablbeLayout LinearLayout layout_margin 外边距(控件距离其他空间或是屏幕边缘的距离) padding 内边距 (控件内部内容距离控件边缘的距离) gravity 表示控件内部内容的对齐方式 layout_gravity 该控件在父类布局中的对齐方式 如果线性布局的对齐方式为水平layout_gravity 在水平方向上不起作用 如果线性布局的对齐方式为垂直layout_gravity 在垂直方向上不起作用 layout_weight 权重(百分比) 线性布局的特有属性如果控件划分的match_parent 成反比如果控件划分的wrap_content 成正比 无权重控件优先级高 然后按剩余页面的控件大小按照权重划分]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_无线调试脚本]]></title>
    <url>%2F2017%2F07%2F24%2FAndroid-%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[执行以下脚本 可用于Android真机无线调试 123456789101112131415161718192021222324252627282930313233343536#!/bin/bash#Modify this with your IP rangeMY_IP_RANGE="192\.168\.1"#You usually wouldn't have to modify thisPORT_BASE=5555#List the devices on the screen for your viewing pleasureadb devicesecho#Find USB devices only (no emulators, genymotion or connected devicesdeclare -a deviceArray=(`adb devices -l | grep -v emulator | grep -v vbox | grep -v "$&#123;MY_IP_RANGE&#125;" | grep " device " | awk '&#123;print $1&#125;'`)echo "found $&#123;#deviceArray[@]&#125; device(s)"echofor index in $&#123;!deviceArray[*]&#125;doecho "finding IP address for device $&#123;deviceArray[index]&#125;"IP_ADDRESS=$(adb -s $&#123;deviceArray[index]&#125; shell ifconfig wlan0 | awk '&#123;print $3&#125;')echo "IP address found : $IP_ADDRESS "echo "Connecting..."adb -s $&#123;deviceArray[index]&#125; tcpip $(($PORT_BASE + $index))adb -s $&#123;deviceArray[index]&#125; connect "$IP_ADDRESS:$(($PORT_BASE + $index))"echoechodoneadb devices -l#exit]]></content>
      <categories>
        <category>shell,Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gradle常用命令]]></title>
    <url>%2F2017%2F07%2F24%2FGradle%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[./代表当前目录，gradlew代表 gradle wrapper，意思是gradle的一层包装，大家可以理解为在这个项目本地就封装了gradle，即gradle wrapper， 在./gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本。只要下载成功即可用grdlew wrapper的命令代替全局的gradle命令。以下的命令都是在项目目录下操作 查看版本号: 12$ ./gradlew -v第一次执行这条命令会下载安装 清除项目目录下的build文件夹 1$ ./gradlew clean 检查依赖编译打包 123$ ./gradlew build这个命令把debug、release环境的包都打出来 打Debug包 1$ ./gradlew assembleDebug 打Release包 1$ ./gradlew assembleRelease]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_Intent]]></title>
    <url>%2F2017%2F07%2F23%2FAndroid-Intent%2F</url>
    <content type="text"><![CDATA[Intent 的几大属性 ComponentName (组件名称) Action 字符串类型 1intent.setAction(&quot;com.example.lwj.activitytest&quot;); Category分类 进一步筛选要选择的内容 一般放在标签中 常用的有:LAUNCHER 、DEFAULT、 HOME Extra 附加信息(键值对) 传值putExtra() 12345if (getIntent() != null)&#123; Intent intent = getIntent(); String info = intent.getStringExtra(&quot;info&quot;);&#125; Data]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android_生命周期]]></title>
    <url>%2F2017%2F07%2F23%2FAndroid-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[一把都是成对出现的 onCreate–onDestroy onStart–onStop onResume–onPause Activity生命周期 onCreate创建activity的方法 onStart启动activity onResume执行此方法之后 用户可以看到 h获取焦点 onPause失去焦点 可见 不可交互 onStop不可见 onDestroy销毁当前activity的页面实例 onRestart将置于后台的activity重新被置于前台 成对出现onCreate–onDestroy onStart–onStop onResume–onPause Task一个app启动的时候会包含多个Activity页面,这些Activity所组成的操作就是一个task任务 back Task 任务栈点击一个app 就会开启一个task任务 这个任务中所有的activity就会被放在一个任务栈(back stack)中 位于任务栈 栈顶的Activity用户可见新的Activity进入栈的时候 已存在栈中的Activity会压栈 启动activity startActivity Intent intent = new Intent(MainActivity.this, SecondActivity.class); startActivity(new Intent(intent)) ; startActivityForResult (带返回值的跳转) Intent intent = new Intent(MainActivity.this, SecondActivity.class);// 参数一: intent对象 参数二: 请求码 用来区分页面startActivityForResult(intent, 10); 重写系统方法 onActivityResult 123456789101112131415@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode==10&amp;&amp;resultCode==RESULT_OK)&#123; TextView tv = (TextView) findViewById(R.id.textView); /*将数据取出 并展示出来*/ tv.setText(data.getStringExtra(&quot;key&quot;)); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Swift小知识]]></title>
    <url>%2F2017%2F07%2F21%2FSwift%E5%B0%8F%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Swift的小知识点集锦 设置attributes 属性 12345//文档open func setTitleTextAttributes(_ attributes: [String : Any]?, for state: UIControlState)//例子rootNav.tabBarItem.setTitleTextAttributes([NSAttributedStringKey.foregroundColor.rawValue: UIColor.red], for: .selected) 设置image的 RenderingMode 12let selectImg = UIImage(named: selectImgName)?.withRenderingMode(.alwaysOriginal) @available #available Swift 2.0 中，引入了可用性的概念。对于函数，类，协议等，可以使用@available声明这些类型的生命周期依赖于特定的平台和操作系统版本。而#available用在判断语句中（if, guard, while等），在不同的平台上做不同的逻辑。 @available放在函数（方法），类或者协议前面。表明这些类型适用的平台和操作系统 1234@available(iOS 9, *)func myMethod() &#123; // do something&#125; #available 用在条件语句代码块中，判断不同的平台下，做不同的逻辑处理，比如： 12345678if #available(iOS 8, *) &#123; // iOS 8 及其以上系统运行&#125;guard #available(iOS 8, *) else &#123; return //iOS 8 以下系统就直接返回&#125; SelectorSwift 中的 Selector 类型其实就是 Objective-C 中的 SEL 类型。在 Swift 中，Selector 的本质是结构体。 1btn.addTarget(&lt;#T##target: Any?##Any?#&gt;, action: &lt;#T##Selector#&gt;, for: &lt;#T##UIControlEvents#&gt;) 类似 Objective-C 中的 NSSelectorFromString，Swift 中的 Selector 也可以使用字符串来构造(会有警告) 1btn.addTarget(self, action: Selector(&quot;btnClick&quot;), for: .touchUpInside) 这样写的好处 可以条用类的私有变量 类似OC的运行时机制handleNavigationTransition:还有一种方法是 1btn.addTarget(self, action: #selector(ProfileViewController.itemClick), for: .touchUpInside) 如果当期作用域下 只有这一个方法 ProfileViewController可以省略 直接写方法名 方法前加@objc我们也知道OC中的属性其实是自动生成了getter和setter方法。swift 3中支持获取属性的getter和setter方法 通过#selector: #selector(setter: &lt;#T##@objc property#&gt;) #selector(getter: &lt;#T##@objc property#&gt;) 123456789101112131415class Person: NSObject &#123; dynamic var firstName: String dynamic let lastName: String dynamic var fullName: String &#123; return &quot;\(firstName) \(lastName)&quot; &#125; init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125;&#125;let firstNameGetter = #selector(getter: Person.firstName)let firstNameSetter = #selector(setter: Person.firstName) layout的属性1234//每行之间竖直之间的最小间距 （可以大于）layout.minimumLineSpacing = 1//同行的cell与cell之间水平之间的最小间距layout.minimumInteritemSpacing = 1 参考: 链接]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim的基本使用]]></title>
    <url>%2F2017%2F07%2F19%2FVim%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[vi编辑器是所有Unix及Linux系统下标准的编辑器，它的强大不逊色于任何最新的文本编辑器，这里只是简单地介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。 1、vi的基本概念基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下： 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 2、vi的基本操作a) 进入vi 在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面： $ vi myfile 不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！ b) 切换至插入模式（Insert mode）编辑文件 在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。 c) Insert 的切换 您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。 d) 退出vi及保存文件 在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如： : w filename （输入 「w filename」将文章以指定的文件名filename保存） : wq (输入「wq」，存盘并退出vi) : q! (输入q!， 不存盘强制退出vi) 3、命令行模式（command mode）功能键1）. 插入模式 按「i」切换进入插入模式「insert mode」，按“i”进入插入模式后是从光标当前位置开始输入文件； 按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字； 按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。 2）. 从插入模式切换为命令行模式 按「ESC」键。 3）. 移动光标 vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。 按「ctrl」+「b」：屏幕往“后”移动一页。 按「ctrl」+「f」：屏幕往“前”移动一页。 按「ctrl」+「u」：屏幕往“后”移动半页。 按「ctrl」+「d」：屏幕往“前”移动半页。 按数字「0」：移到文章的开头。 按「G」：移动到文章的最后。 按「$」：移动到光标所在行的“行尾”。 按「^」：移动到光标所在行的“行首” 按「w」：光标跳到下个字的开头 按「e」：光标跳到下个字的字尾 按「b」：光标回到上个字的开头 按「#l」：光标移到该行的第#个位置，如：5l,56l。 4）. 删除文字 「x」：每按一次，删除光标所在位置的“后面”一个字符。 「#x」：例如，「6x」表示删除光标所在位置的“后面”6个字符。 「X」：大写的X，每按一次，删除光标所在位置的“前面”一个字符。 「#X」：例如，「20X」表示删除光标所在位置的“前面”20个字符。 「dd」：删除光标所在行。 「#dd」：从光标所在行开始删除#行 5）. 复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「#yw」：复制#个字到缓冲区 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行“往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与“y”有关的复制命令都必须与“p”配合才能完成复制与粘贴功能。 6）. 替换 「r」：替换光标所在处的字符。 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 7）. 回复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次“u”可以执行多次回复。 8）. 更改 「cw」：更改光标所在处的字到字尾处 「c#w」：例如，「c3w」表示更改3个字 9）. 跳至指定的行 「ctrl」+「g」列出光标所在行的行号。 「#G」：例如，「15G」，表示移动光标至文章的第15行行首。 4、Last line mode下命令简介在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。 A) 列出行号 「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。 B) 跳到文件中的某一行 「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。 C) 查找字符 「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。 「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。 D) 保存文件 「w」：在冒号输入字母「w」就可以将文件保存起来。 E) 离开vi 「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。 「qw」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。 5、vi命令列表1、下表列出命令模式下的一些键的功能： h 左移光标一个字符 l 右移光标一个字符 k 光标上移一行 j 光标下移一行 ^ 光标移动至行首 0 数字“0”，光标移至文章的开头 G 光标移至文章的最后 $ 光标移动至行尾 Ctrl+f向前翻屏 Ctrl+b向后翻屏 Ctrl+d向前翻半屏 Ctrl+u向后翻半屏 i 在光标位置前插入字符 a 在光标所在位置的后一个字符开始增加 o 插入新的一行，从行首开始输入 ESC从输入状态退至命令状态 x 删除光标后面的字符 #x删除光标后的＃个字符 X (大写X)，删除光标前面的字符 #X删除光标前面的#个字符 dd删除光标所在的行 #dd删除从光标所在行数的#行 yw复制光标所在位置的一个字 #yw复制光标所在位置的#个字 yy复制光标所在位置的一行 #yy复制从光标所在行数的#行 p 粘贴 u 取消操作 cw更改光标所在位置的一个字 #cw更改光标所在位置的#个字]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis_CI动态编译GitHub仓库]]></title>
    <url>%2F2017%2F07%2F06%2FTravis-CI%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91GitHub%E4%BB%93%E5%BA%93%2F</url>
    <content type="text"><![CDATA[我的博客是用hexo部署在GitHub上的有时候换个电脑或是有个小改动的话 就会很不方便 Travis刚好解决了这个问题 什么是Travis_CI Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，Go的很明显的 特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 GitHub账号登录Travis_CI 在左上角有加好按钮 把需要添加的项目开关打开 github上添加access token 登录github，进入到setting =&gt; develop setting =&gt; personal access tokens在description里输入任意token 名字，比如Travis-CI，并勾选上下面所有复选框。这个时候会生成token，请务必记住，因为他只会出现一次，否则需要重新生成(这个就是)。 添加access token到travis上 在travis右上角more options里找到setting，打开后，勾选 [Build only if .travis.yml is present] 并且 在Environment Variables中添加github上的access token。 添加编写.travis.yml 在项目源码根目录(我的是troy-yang.github.io source分支), 添加.travis.yml文件，下面是我的: 123456789101112131415161718192021222324language: node_jsnode_js: stable# S: Build Lifecycleinstall:- npm install hexo-cli -g- npm installbefore_install:- git submodule update --init --remote --recursive#before_script:# - npm install -g gulpscript:- hexo gafter_script:- cd ./public- git init- git config user.name "laodaoduo"- git config user.email "2295990355@qq.com"- git add .- git commit -m "Update docs"- git push --force --quiet "https://$&#123;GitHub_TOKEN&#125;@$&#123;GH_REF&#125;" master:master# E: Build LifeCycleenv:global:- GH_REF: github.com/laodaoduo/laodaoduo.github.io.git 最后可以测试看看了 参考链接]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下的Apache服务]]></title>
    <url>%2F2017%2F07%2F06%2FMac%E4%B8%8B%E7%9A%84Apache%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[Mac自带apache服务 在/usr/sbin/apachectl文件夹下 123456开启$ sudo /usr/sbin/apachectl start关闭$ sudo /usr/sbin/apachectl stop重启$ sudo /usr/sbin/apachectl restart 默认打开地址 1/Library/WebServer/Documents/ 可将测试文件放在上面的文件夹下 如果不方便的话可到配置文件更改Document地址 1$ vim /etc/apache2/httpd.conf 找到DocumentRoot “/Library/WebServer/Documents”更改即可]]></content>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo与GitHub搭建个人博客]]></title>
    <url>%2F2017%2F07%2F05%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo与GitHub搭建个人博客过程 创建GitHub仓库,名字为: GitHub昵称.github.io 添加秘钥 1.0 终端用以下命令 按提示 生成秘钥 公钥 生成的文件 保存在 ~/.ssh 文件夹下 $ ssh-keygen -t rsa -C &quot;2295990355@qq.com&quot; 参数-t:是加密类型 -C:提供一个新注释 2.0 将公钥复制到GitHub上 https://github.com/settings/keys 安装node.js node.js官网 里面有通用版与最新版 两个版本 选择一个下载安装即可 我这里是在终端用brew安装$ brew install node 安装之后可以创建js文件测试 123456789var http = require('http');http.createServer(function (req, res) &#123;res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;);res.end('Hello World\n');&#125;).listen(8124, "127.0.0.1");console.log('Server running at http://127.0.0.1:8124/');--------------------------------------------------------测试$ node ~/js文件 安装Hexo $ npm install -g hexo-cli 配置 建立一个博客文件夹，为文件夹的名称,到自己对应的博客文件夹下依次执行以下命令 $ hexo init &lt;folder&gt; $ cd &lt;folder&gt; $ npm install 写一个博客试试 12$ hexo new "文章标题"$ hexo s 打开网址http://localhost:4000/ 上传github ssh配置 就不说了 修改博客_config.yml文件 主要有二处 12345678910111213一、# Sitetitle: LWJsubtitle: 临帝子之长洲， 得天人之旧馆。 层峦耸翠， 上出重霄； 飞阁流丹， 下临无地。 鹤汀凫渚， 穷岛屿之萦回； 桂殿兰宫， 即冈峦之体势。description:author: LWJ_wenlanguage: zh_CNtimezone: Asia/Shanghai二、deploy: type: git repo: https://github.com/laodaoduo/laodaoduo.github.io.git branch: master 第一次上传的时候会让输入你的GitHub用户名密码 遇到的一些坑 报错信息:(node:1134) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated.原因我新建了一个文件 里面都是shell脚本 可能是不能识别 报错了 (node:1299) [DEP0061] DeprecationWarning: fs.SyncWriteStream is deprecated. ERROR Deployer not found: git 解决办法: npm install hexo-deployer-git –save]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cocoapods的安装过程]]></title>
    <url>%2F2017%2F01%2F01%2Fcocoapods%E7%9A%84%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[新mac电脑上cocoapods的安装过程 升级gem1sudo gem update --system 安装rvm123curl -L get.rvm.io | bash -s stablesource ~/.bashrcsource ~/.bash_profile 安装homebrew1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; ruby升级1rvm install x.x.x 设置默认版本 1rvm use 2.4.0 --default 安装cocoapods查看当前源1gem sources -l 移除默认的ruby源1gem sources --remove https://rubygems.org/ 更改为国内源1gem sources -a https://gems.ruby-china.org/ 安装1sudo gem install cocoapods 成功之后执行pod setup测试 pod search AFNetworking报错：Unable to find a pod with name, author, summary, or description matching SDWebImage解决办法：rm ~/Library/Caches/CocoaPods/search_index.json再次测试 ok出现上面错误的原因是因为你在没有完全安装好cocoapods的时候执行的search操作]]></content>
      <tags>
        <tag>Pod</tag>
      </tags>
  </entry>
</search>
